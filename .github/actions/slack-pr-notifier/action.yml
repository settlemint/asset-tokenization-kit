name: "Slack PR Notifier"
description: "Send or update Slack notifications for PR events"
inputs:
  pr_number:
    description: "Pull request number"
    required: true
  pr_title:
    description: "Pull request title"
    required: true
  pr_url:
    description: "Pull request URL"
    required: true
  pr_author:
    description: "Pull request author"
    required: true
  pr_author_avatar:
    description: "Pull request author avatar URL"
    required: true
  slack_bot_token:
    description: "Slack bot token"
    required: true
  slack_channel_id:
    description: "Slack channel ID"
    required: true
  update_message:
    description: "Whether to update the message format"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Wait for labels to be applied
      shell: bash
      run: sleep 3

    - name: Get PR labels and send Slack notification
      uses: actions/github-script@v7
      env:
        SLACK_BOT_TOKEN: ${{ inputs.slack_bot_token }}
        SLACK_CHANNEL_ID: ${{ inputs.slack_channel_id }}
      with:
        script: |
          // Get PR labels
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }}
          });

          const labels = pr.labels || [];
          const pr_title = ${{ toJSON(inputs.pr_title) }};
          const pr_url = ${{ toJSON(inputs.pr_url) }};
          const pr_number = ${{ inputs.pr_number }};
          const pr_author = ${{ toJSON(inputs.pr_author) }};
          const author_avatar = ${{ toJSON(inputs.pr_author_avatar) }};
          const update_message = '${{ inputs.update_message }}' === 'true';

          // Extract repo name without org
          const repoName = context.repo.repo;

          // Check if PR is from a bot
          const isBot = pr_author.endsWith('[bot]');
          if (isBot) {
            console.log('Skipping notification for bot PR');
            return;
          }

          // Check if PR is draft
          const isDraft = Array.isArray(labels) && labels.some(label => label.name === 'status:draft');
          if (isDraft) {
            console.log('Skipping notification for draft PR');
            return;
          }

          // Define status reactions mapping
          const statusReactions = {
            'qa:pending': 'hourglass_flowing_sand',
            'qa:running': 'runner',
            'qa:success': 'white_check_mark',
            'qa:failed': 'x',
            'status:ready-for-review': 'eyes',
            'status:approved': 'thumbsup',
            'status:mergeable': 'rocket',
            'status:merged': 'tada'
          };

          // Define mutually exclusive groups (only one can be active at a time)
          const exclusiveGroups = {
            'qa': ['hourglass_flowing_sand', 'runner', 'white_check_mark', 'x'],
            'status': ['eyes', 'thumbsup', 'rocket', 'tada']
          };

          // All possible status reactions we manage
          const allStatusReactions = Object.values(statusReactions);

          // Get current status labels
          console.log('Current PR labels:', labels.map(l => l.name));
          console.log('QA labels found:', labels.filter(l => l.name.startsWith('qa:')).map(l => l.name));

          // Filter labels and determine appropriate reactions
          const qaLabels = labels.filter(l => l.name.startsWith('qa:'));
          const statusLabels = labels.filter(l => l.name.startsWith('status:'));

          let currentStatuses = [];

          // Priority order for QA labels (if multiple exist due to race conditions)
          const qaPriority = ['qa:failed', 'qa:success', 'qa:running', 'qa:pending'];

          // Find the highest priority QA label
          let selectedQaLabel = null;
          for (const priorityLabel of qaPriority) {
            if (qaLabels.some(l => l.name === priorityLabel)) {
              selectedQaLabel = priorityLabel;
              break;
            }
          }

          // Add only the selected QA reaction
          if (selectedQaLabel && statusReactions[selectedQaLabel]) {
            currentStatuses.push(statusReactions[selectedQaLabel]);
            console.log(`Selected QA reaction: ${selectedQaLabel} -> ${statusReactions[selectedQaLabel]}`);
          }

          // Only add status reaction if QA is not running or pending
          const qaRunning = selectedQaLabel === 'qa:running' || selectedQaLabel === 'qa:pending';
          if (!qaRunning) {
            const statusLabel = statusLabels.find(l => Object.keys(statusReactions).includes(l.name));
            if (statusLabel) {
              currentStatuses.push(statusReactions[statusLabel.name]);
            }
          }

          console.log('Reactions to add:', currentStatuses);

          // Debug: Check if we have multiple QA reactions (should never happen)
          const qaReactionsToAdd = currentStatuses.filter(r => exclusiveGroups.qa.includes(r));
          if (qaReactionsToAdd.length > 1) {
            console.error('ERROR: Multiple QA reactions detected:', qaReactionsToAdd);
            console.error('This should not happen! QA labels:', qaLabels.map(l => l.name));
          }

          // Check if there's an existing Slack message
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr_number
          });

          console.log(`Found ${comments.length} comments on PR`);
          const slackComment = comments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
          let slackTs = null;

          if (slackComment) {
            const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
            if (match) {
              slackTs = match[1];
              console.log(`Found existing Slack message timestamp: ${slackTs}`);
            }
          } else {
            console.log('No existing Slack message found');
          }

          // Helper function to make Slack API calls
          async function slackAPI(method, body = {}) {
            const response = await fetch(`https://slack.com/api/${method}`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body)
            });

            const data = await response.json();
            if (!data.ok) {
              throw new Error(`Slack API error: ${data.error}`);
            }
            return data;
          }

          // Message blocks
          const messageBlocks = [
            {
              type: 'header',
              text: {
                type: 'plain_text',
                text: `[#${pr_number}] ${pr_title}`,
                emoji: false
              }
            },
            {
              type: 'section',
              fields: [
                {
                  type: 'mrkdwn',
                  text: `*Author*\n${pr_author}`
                },
                {
                  type: 'mrkdwn',
                  text: `*Repository*\n${repoName}`
                }
              ],
              accessory: {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'View PR',
                  emoji: false
                },
                url: pr_url,
                style: 'primary'
              }
            }
          ];

          try {
            if (!slackTs) {
              // Send new message
              const result = await slackAPI('chat.postMessage', {
                channel: process.env.SLACK_CHANNEL_ID,
                text: `#${pr_number}: ${pr_title}`,
                blocks: messageBlocks
              });

              // Store timestamp
              if (result.ts) {
                console.log(`Storing Slack timestamp ${result.ts} as PR comment`);
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr_number,
                  body: `<!-- slack-ts:${result.ts} -->`
                });
                slackTs = result.ts;
                console.log('Successfully stored Slack timestamp');
              }
            } else {
              // Always update the message to ensure latest title and content
              console.log('Updating Slack message with latest content');
              await slackAPI('chat.update', {
                channel: process.env.SLACK_CHANNEL_ID,
                ts: slackTs,
                text: `#${pr_number}: ${pr_title}`,
                blocks: messageBlocks
              });
            }

            if (slackTs) {
              // Small delay to ensure previous operations have completed
              await new Promise(resolve => setTimeout(resolve, 500));

              // Get existing reactions
              let existingReactions = [];
              try {
                const reactions = await slackAPI('reactions.get', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  timestamp: slackTs,
                  full: true
                });

                if (reactions.message && reactions.message.reactions) {
                  existingReactions = reactions.message.reactions.map(r => r.name);
                  console.log('Existing reactions on message:', existingReactions);
                }
              } catch (e) {
                console.log('Could not get existing reactions:', e.message);
                // Continue anyway - we'll handle errors when adding/removing
              }

              // Smart reaction management
              const reactionsToAdd = [];
              let reactionsToRemove = [];

              // SPECIAL CASE: When QA is starting (running), clear ALL managed reactions first
              if (selectedQaLabel === 'qa:running') {
                console.log('QA is starting - clearing ALL managed reactions');
                // Remove all reactions that we manage
                reactionsToRemove = existingReactions.filter(r => allStatusReactions.includes(r));
              } else {
                // Normal case: selective removal
                // For each desired reaction, check if we need to add it
                for (const desiredReaction of currentStatuses) {
                  if (!existingReactions.includes(desiredReaction)) {
                    reactionsToAdd.push(desiredReaction);
                  }
                }

                // Aggressive cleanup: Remove ALL reactions from exclusive groups first
                // This ensures we don't have multiple QA reactions showing
                for (const existingReaction of existingReactions) {
                  // Check if this reaction belongs to any exclusive group
                  for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
                    if (groupReactions.includes(existingReaction)) {
                      // If we want a reaction from this group, only remove if it's different
                      const desiredFromGroup = currentStatuses.find(r => groupReactions.includes(r));
                      if (!desiredFromGroup || existingReaction !== desiredFromGroup) {
                        if (!reactionsToRemove.includes(existingReaction)) {
                          reactionsToRemove.push(existingReaction);
                        }
                      }
                    }
                  }
                }

                // Special handling: If QA is pending, ensure no status reactions
                const qaInProgress = selectedQaLabel === 'qa:pending';
                if (qaInProgress) {
                  for (const statusReaction of exclusiveGroups.status) {
                    if (existingReactions.includes(statusReaction) && !reactionsToRemove.includes(statusReaction)) {
                      reactionsToRemove.push(statusReaction);
                    }
                  }
                }
              }

              // If QA is running and we're clearing all, we still need to add the runner
              if (selectedQaLabel === 'qa:running') {
                reactionsToAdd.push('runner');
              }

              console.log('Reactions to remove:', reactionsToRemove);
              console.log('Reactions to add:', reactionsToAdd);

              // Final sanity check: ensure we're not adding multiple reactions from same group
              const finalReactionsToAdd = [];
              const addedGroups = new Set();

              for (const reaction of reactionsToAdd) {
                let reactionGroup = null;
                for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
                  if (groupReactions.includes(reaction)) {
                    reactionGroup = groupName;
                    break;
                  }
                }

                if (!reactionGroup || !addedGroups.has(reactionGroup)) {
                  finalReactionsToAdd.push(reaction);
                  if (reactionGroup) addedGroups.add(reactionGroup);
                } else {
                  console.log(`WARNING: Skipping duplicate ${reactionGroup} reaction: ${reaction}`);
                }
              }

              console.log('Final reactions to add after sanity check:', finalReactionsToAdd);

              // Remove outdated reactions first (with proper synchronization)
              for (const reactionName of reactionsToRemove) {
                try {
                  console.log(`Removing outdated reaction: ${reactionName}`);
                  await slackAPI('reactions.remove', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    name: reactionName
                  });
                  // Increased delay to ensure proper synchronization
                  await new Promise(resolve => setTimeout(resolve, 200));
                } catch (e) {
                  if (e.message.includes('missing_scope')) {
                    console.error(`ERROR: Slack bot missing permission to remove reactions. Please add 'reactions:write' scope to the Slack app.`);
                    break;
                  } else if (e.message.includes('no_reaction')) {
                    console.log(`Reaction ${reactionName} was already removed`);
                  } else {
                    console.log(`Could not remove reaction ${reactionName}: ${e.message}`);
                  }
                }
              }

              // Wait a bit after removals to ensure Slack has processed them
              if (reactionsToRemove.length > 0) {
                await new Promise(resolve => setTimeout(resolve, 500));
              }

              // Add new reactions
              for (const reaction of finalReactionsToAdd) {
                try {
                  console.log(`Adding reaction: ${reaction}`);
                  await slackAPI('reactions.add', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    name: reaction
                  });
                  console.log(`Successfully added reaction: ${reaction}`);
                  // Increased delay to ensure proper synchronization
                  await new Promise(resolve => setTimeout(resolve, 200));
                } catch (e) {
                  if (e.message.includes('missing_scope')) {
                    console.error(`ERROR: Slack bot missing permission to add reactions. Please add 'reactions:write' scope to the Slack app.`);
                    break;
                  } else if (e.message.includes('already_reacted')) {
                    console.log(`Reaction ${reaction} already exists (race condition)`);
                  } else {
                    console.log(`Could not add reaction ${reaction}: ${e.message}`);
                  }
                }
              }
            }
          } catch (error) {
            console.error('Slack notification error:', error);
            // Don't fail the workflow for Slack errors
          }
