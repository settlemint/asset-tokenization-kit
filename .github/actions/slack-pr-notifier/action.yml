name: "Slack PR Notifier"
description: "Send or update Slack notifications for PR events"
inputs:
  pr_number:
    description: "Pull request number"
    required: true
  pr_title:
    description: "Pull request title"
    required: true
  pr_url:
    description: "Pull request URL"
    required: true
  pr_author:
    description: "Pull request author"
    required: true
  pr_author_type:
    description: "Pull request author type (User or Bot)"
    required: false
    default: "User"
  pr_author_avatar:
    description: "Pull request author avatar URL"
    required: true
  slack_bot_token:
    description: "Slack bot token"
    required: true
  slack_channel_id:
    description: "Slack channel ID"
    required: true
  update_message:
    description: "Whether to update the message format"
    required: false
    default: "false"
  is_abandoned:
    description: "Whether the PR was abandoned (closed without merging)"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Wait for labels to be applied
      shell: bash
      run: sleep 3

    - name: Get PR labels and send Slack notification
      uses: actions/github-script@v7
      env:
        SLACK_BOT_TOKEN: ${{ inputs.slack_bot_token }}
        SLACK_CHANNEL_ID: ${{ inputs.slack_channel_id }}
        PR_NUMBER: ${{ inputs.pr_number }}
        PR_TITLE: ${{ inputs.pr_title }}
        PR_URL: ${{ inputs.pr_url }}
        PR_AUTHOR: ${{ inputs.pr_author }}
        PR_AUTHOR_TYPE: ${{ inputs.pr_author_type }}
        PR_AUTHOR_AVATAR: ${{ inputs.pr_author_avatar }}
        IS_ABANDONED: ${{ inputs.is_abandoned }}
      with:
        script: |
          const {data:labels}=await github.rest.issues.listLabelsOnIssue({owner:context.repo.owner,repo:context.repo.repo,issue_number:process.env.PR_NUMBER});
          const {data:comments}=await github.rest.issues.listComments({owner:context.repo.owner,repo:context.repo.repo,issue_number:process.env.PR_NUMBER});
          let slackTs=null;
          const slackComment=comments.find(c=>c.body&&c.body.includes('<!-- slack-ts:'));
          if(slackComment){const m=slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);if(m)slackTs=m[1];}
          const allowedBots=['dependabot[bot]','renovate[bot]','github-actions[bot]'];
          if(process.env.PR_AUTHOR_TYPE==='Bot'&&!allowedBots.includes(process.env.PR_AUTHOR))return;
          const isDraft=labels.some(l=>l.name==='status:draft');
          if(isDraft&&process.env.PR_AUTHOR_TYPE!=='Bot')return;
          if(!slackTs&&(labels.some(l=>l.name==='status:merged')||process.env.IS_ABANDONED==='true'))return;
          const sL=[{l:'status:draft',t:':pencil2: Draft'},{l:'status:ready-for-review',t:':mag: Ready for Review'},{l:'status:in-review',t:':eyes: In Review'},{l:'qa:running',t:':hourglass_flowing_sand: QA Running'},{l:'qa:failed',t:':x: QA Failed'},{l:'qa:passed',t:':white_check_mark: QA Passed'},{l:'status:changes-requested',t:':warning: Changes Requested'},{l:'status:approved',t:':white_check_mark: Approved'},{l:'status:on-hold',t:':pause_button: On Hold'},{l:'status:blocked',t:':octagonal_sign: Blocked'},{l:'status:ready-to-merge',t:':rocket: Ready to Merge'},{l:'status:merged',t:':tada: Merged'}];
          const pL=[{l:'priority:critical',t:':rotating_light:'},{l:'priority:high',t:':arrow_up:'},{l:'priority:medium',t:':arrow_right:'},{l:'priority:low',t:':arrow_down:'}];
          const cL=[{l:'type:bug',t:':bug:'},{l:'type:feature',t:':sparkles:'},{l:'type:refactor',t:':recycle:'},{l:'type:test',t:':test_tube:'},{l:'type:docs',t:':books:'},{l:'type:chore',t:':wrench:'},{l:'type:style',t:':art:'},{l:'type:perf',t:':zap:'},{l:'type:security',t:':shield:'},{l:'type:breaking',t:':boom:'}];
          const sT=[];
          const aS=sL.find(s=>labels.some(l=>l.name===s.l));
          if(aS)sT.push(aS.t);
          const aP=pL.find(p=>labels.some(l=>l.name===p.l));
          if(aP)sT.push(aP.t);
          const aC=cL.filter(c=>labels.some(l=>l.name===c.l));
          sT.push(...aC.map(c=>c.t));
          const sS=sT.length>0?sT.join(' ')+' ':'';
          try{
          async function sA(m,p){
            const r=await fetch(`https://slack.com/api/${m}`,{method:'POST',headers:{'Authorization':`Bearer ${process.env.SLACK_BOT_TOKEN}`,'Content-Type':'application/json'},body:JSON.stringify(p)});
            const d=await r.json();
            if(!d.ok)throw new Error(`Slack API error: ${d.error}`);
            return d;
          }
          function eT(t){return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}
          const iM=labels.some(l=>l.name==='status:merged');
          const iA=process.env.IS_ABANDONED==='true';
          const eTitle=eT(process.env.PR_TITLE);
          let mB;
          if(iM){
            mB=[{type:'section',text:{type:'mrkdwn',text:`:tada: ${eTitle}`},accessory:{type:'button',text:{type:'plain_text',text:'View PR',emoji:false},url:process.env.PR_URL,style:'primary'}}];
          }else if(iA){
            mB=[{type:'section',text:{type:'mrkdwn',text:`:file_folder: ${eTitle}`},accessory:{type:'button',text:{type:'plain_text',text:'View PR',emoji:false},url:process.env.PR_URL}}];
          }else{
            let oU;
            if(!slackTs){
              const qR=labels.some(l=>l.name==='qa:running');
              const cK=qR?`qa-${Date.now()}`:Date.now();
              oU=`https://opengraph.githubassets.com/${cK}/${context.repo.owner}/${context.repo.repo}/pull/${process.env.PR_NUMBER}`;
            }else{
              oU=`https://opengraph.githubassets.com/1/${context.repo.owner}/${context.repo.repo}/pull/${process.env.PR_NUMBER}`;
            }
            mB=[{type:'image',image_url:oU,alt_text:`PR #${process.env.PR_NUMBER}: ${eTitle}`},{type:'actions',elements:[{type:'button',text:{type:'plain_text',text:'View PR',emoji:false},url:process.env.PR_URL,style:'primary'},{type:'button',text:{type:'plain_text',text:'Files',emoji:false},url:`${process.env.PR_URL}/files`},{type:'button',text:{type:'plain_text',text:'Checks',emoji:false},url:`${process.env.PR_URL}/checks`}]}];
          }
          async function sM(isNew){
            let r,rc=0;
            const mR=2;
            while(rc<=mR){
              try{
                if(isNew){
                  r=await sA('chat.postMessage',{channel:process.env.SLACK_CHANNEL_ID,text:`#${process.env.PR_NUMBER}: ${eTitle}`,blocks:mB});
                }else{
                  await sA('chat.update',{channel:process.env.SLACK_CHANNEL_ID,ts:slackTs,text:`#${process.env.PR_NUMBER}: ${eTitle}`,blocks:mB});
                }
                break;
              }catch(e){
                if(e.message.includes('invalid_blocks')&&rc<mR){
                  rc++;
                  await new Promise(rs=>setTimeout(rs,1000*rc));
                }else if(e.message.includes('invalid_blocks')){
                  const fB=mB.filter(b=>b.type!=='image');
                  if(!iM&&!iA){
                    fB.unshift({type:'section',text:{type:'mrkdwn',text:`*<${process.env.PR_URL}|#${process.env.PR_NUMBER}: ${eTitle}>*\n_by ${process.env.PR_AUTHOR}_`}});
                  }
                  if(isNew){
                    r=await sA('chat.postMessage',{channel:process.env.SLACK_CHANNEL_ID,text:`#${process.env.PR_NUMBER}: ${eTitle}`,blocks:fB});
                  }else{
                    await sA('chat.update',{channel:process.env.SLACK_CHANNEL_ID,ts:slackTs,text:`#${process.env.PR_NUMBER}: ${eTitle}`,blocks:fB});
                  }
                  break;
                }else{
                  throw e;
                }
              }
            }
            return r;
          }
          if(!slackTs){
            const lC=await github.rest.issues.createComment({owner:context.repo.owner,repo:context.repo.repo,issue_number:process.env.PR_NUMBER,body:'<!-- slack-creating-lock -->'});
            const {data:cC}=await github.rest.issues.listComments({owner:context.repo.owner,repo:context.repo.repo,issue_number:process.env.PR_NUMBER});
            const eC=cC.find(c=>c.body&&c.body.includes('<!-- slack-ts:')&&c.id!==lC.data.id);
            if(eC){
              await github.rest.issues.deleteComment({owner:context.repo.owner,repo:context.repo.repo,comment_id:lC.data.id});
              const m=eC.body.match(/<!-- slack-ts:([0-9.]+) -->/);
              if(m){slackTs=m[1];}
            }else{
              const r=await sM(true);
              if(r&&r.ts){
                const cB=[`<!-- slack-ts:${r.ts} -->`,`To view in Slack, search for: ${r.ts}`].join('\n');
                await github.rest.issues.updateComment({owner:context.repo.owner,repo:context.repo.repo,comment_id:lC.data.id,body:cB});
                slackTs=r.ts;
              }
              try{await github.rest.issues.deleteComment({owner:context.repo.owner,repo:context.repo.repo,comment_id:lC.data.id});}catch(e){}
            }
          }else{
            await sM(false);
          }
          if(slackTs){
            await new Promise(rs=>setTimeout(rs,500));
            const rA={draft:':pencil2:','ready-for-review':':mag:','in-review':':eyes:','qa:running':':hourglass_flowing_sand:','qa:failed':':x:','qa:passed':':white_check_mark:','changes-requested':':warning:',approved:':white_check_mark:','on-hold':':pause_button:',blocked:':octagonal_sign:','ready-to-merge':':rocket:',merged:':tada:'};
            const pA={'priority:critical':':rotating_light:','priority:high':':arrow_up:','priority:medium':':arrow_right:','priority:low':':arrow_down:'};
            const tA={'type:bug':':bug:','type:feature':':sparkles:','type:refactor':':recycle:','type:test':':test_tube:','type:docs':':books:','type:chore':':wrench:','type:style':':art:','type:perf':':zap:','type:security':':shield:','type:breaking':':boom:'};
            const cD={...rA,...pA,...tA};
            try{
              const {data:m}=await sA('conversations.history',{channel:process.env.SLACK_CHANNEL_ID,latest:slackTs,limit:1,inclusive:true});
              if(m.messages&&m.messages.length>0){
                const cR=await sA('reactions.get',{channel:process.env.SLACK_CHANNEL_ID,timestamp:slackTs});
                const eR=(cR.message.reactions||[]).map(r=>r.name);
                for(const[l,e]of Object.entries(cD)){
                  const hL=labels.some(lbl=>lbl.name===l||lbl.name===`status:${l}`);
                  const hR=eR.includes(e.replace(/:/g,''));
                  if(hL&&!hR){
                    try{await sA('reactions.add',{channel:process.env.SLACK_CHANNEL_ID,timestamp:slackTs,name:e.replace(/:/g,'')});}catch(e){}
                  }else if(!hL&&hR){
                    try{await sA('reactions.remove',{channel:process.env.SLACK_CHANNEL_ID,timestamp:slackTs,name:e.replace(/:/g,'')});}catch(e){}
                  }
                }
              }
            }catch(e){}
          }
          }catch(e){console.error('Failed to send Slack notification:',e);throw e;}