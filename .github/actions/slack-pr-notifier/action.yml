name: "Slack PR Notifier"
description: "Send or update Slack notifications for PR events"
inputs:
  pr_number:
    description: "Pull request number"
    required: true
  pr_title:
    description: "Pull request title"
    required: true
  pr_url:
    description: "Pull request URL"
    required: true
  pr_author:
    description: "Pull request author"
    required: true
  pr_author_type:
    description: "Pull request author type (User or Bot)"
    required: false
    default: "User"
  pr_author_avatar:
    description: "Pull request author avatar URL"
    required: true
  slack_bot_token:
    description: "Slack bot token"
    required: true
  slack_channel_id:
    description: "Slack channel ID"
    required: true
  update_message:
    description: "Whether to update the message format"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Wait for labels to be applied
      shell: bash
      run: sleep 3

    - name: Get PR labels and send Slack notification
      uses: actions/github-script@v7
      env:
        SLACK_BOT_TOKEN: ${{ inputs.slack_bot_token }}
        SLACK_CHANNEL_ID: ${{ inputs.slack_channel_id }}
      with:
        script: |
          // Add random jitter to prevent race conditions when multiple steps run in parallel
          const jitter = Math.floor(Math.random() * 3000);
          console.log(`Waiting ${jitter}ms to prevent race conditions...`);
          await new Promise(resolve => setTimeout(resolve, jitter));
          // Get PR labels
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: ${{ inputs.pr_number }}
          });

          const labels = pr.labels || [];
          const pr_title = ${{ toJSON(inputs.pr_title) }};
          const pr_url = ${{ toJSON(inputs.pr_url) }};
          const pr_number = ${{ inputs.pr_number }};
          const pr_author = ${{ toJSON(inputs.pr_author) }};
          const pr_author_type = '${{ inputs.pr_author_type }}';
          const author_avatar = ${{ toJSON(inputs.pr_author_avatar) }};
          const update_message = '${{ inputs.update_message }}' === 'true';

          // Extract repo name without org
          const repoName = context.repo.repo;

          // Check if PR is from a bot
          if (pr_author_type === 'Bot') {
            console.log(`Skipping notification for bot PR from ${pr_author}`);
            return;
          }

          // Check if PR is draft
          const isDraft = Array.isArray(labels) && labels.some(label => label.name === 'status:draft');
          if (isDraft) {
            console.log('Skipping notification for draft PR');
            return;
          }

          // Define status reactions mapping
          const statusReactions = {
            'qa:pending': 'hourglass_flowing_sand',
            'qa:running': 'runner',
            'qa:success': 'white_check_mark',
            'qa:failed': 'x',
            'status:ready-for-review': 'eyes',
            'status:approved': 'thumbsup',
            'status:mergeable': 'rocket',
            'status:merged': 'tada'
          };

          // Define mutually exclusive groups (only one can be active at a time)
          const exclusiveGroups = {
            'qa': ['hourglass_flowing_sand', 'runner', 'white_check_mark', 'x'],
            'status': ['eyes', 'thumbsup', 'rocket', 'tada']
          };

          // All possible status reactions we manage
          const allStatusReactions = Object.values(statusReactions);

          // Get current status labels
          console.log('Current PR labels:', labels.map(l => l.name));
          console.log('QA labels found:', labels.filter(l => l.name.startsWith('qa:')).map(l => l.name));

          // STRICT LABEL-TO-REACTION MAPPING
          // Only show reactions that have exact corresponding labels
          const currentStatuses = [];
          
          // Map each label to its reaction
          for (const label of labels) {
            if (statusReactions[label.name]) {
              currentStatuses.push(statusReactions[label.name]);
              console.log(`Label "${label.name}" maps to reaction "${statusReactions[label.name]}"`);
            }
          }
          
          // Apply exclusive group rules
          const finalStatuses = [];
          const usedGroups = new Set();
          
          // Priority order for exclusive groups
          const groupPriority = {
            'qa': ['qa:failed', 'qa:success', 'qa:running', 'qa:pending'],
            'status': ['status:merged', 'status:mergeable', 'status:approved', 'status:ready-for-review']
          };
          
          // For each group, pick only the highest priority reaction
          for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
            const priorityOrder = groupPriority[groupName] || [];
            
            // Find the highest priority label from this group
            let selectedReaction = null;
            for (const priorityLabel of priorityOrder) {
              if (labels.some(l => l.name === priorityLabel) && statusReactions[priorityLabel]) {
                selectedReaction = statusReactions[priorityLabel];
                break;
              }
            }
            
            if (selectedReaction && currentStatuses.includes(selectedReaction)) {
              finalStatuses.push(selectedReaction);
              usedGroups.add(groupName);
            }
          }
          
          // If QA is running or pending, don't show status reactions
          const hasQaInProgress = labels.some(l => l.name === 'qa:running' || l.name === 'qa:pending');
          const filteredStatuses = hasQaInProgress 
            ? finalStatuses.filter(r => exclusiveGroups.qa.includes(r))
            : finalStatuses;
          
          console.log('All label names:', labels.map(l => l.name));
          console.log('Final reactions (strict sync with labels):', filteredStatuses);

          // Check if there's an existing Slack message or a lock
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr_number
          });

          console.log(`Found ${comments.length} comments on PR`);
          
          // Check for a creation lock first
          const lockComment = comments.find(c => c.body && c.body.includes('<!-- slack-creating-lock -->'));
          if (lockComment) {
            // Check if lock is recent (within 30 seconds)
            const lockAge = Date.now() - new Date(lockComment.created_at).getTime();
            if (lockAge < 30000) {
              console.log(`Found recent creation lock (${lockAge}ms old), waiting for other process to complete...`);
              // Wait and retry to find the created message
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Re-fetch comments
              const { data: newComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number
              });
              
              const slackComment = newComments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
              if (slackComment) {
                const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
                if (match) {
                  slackTs = match[1];
                  console.log(`Found Slack message created by another process: ${slackTs}`);
                }
              }
            } else {
              console.log(`Found stale creation lock (${lockAge}ms old), ignoring...`);
              // Delete stale lock
              try {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: lockComment.id
                });
              } catch (e) {
                console.log('Could not delete stale lock:', e.message);
              }
            }
          }
          
          // Look for existing Slack message
          const slackComment = comments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
          let slackTs = null;

          if (slackComment) {
            const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
            if (match) {
              slackTs = match[1];
              console.log(`Found existing Slack message timestamp: ${slackTs}`);
            }
          } else {
            console.log('No existing Slack message found');
          }

          // Helper function to make Slack API calls
          async function slackAPI(method, body = {}) {
            const response = await fetch(`https://slack.com/api/${method}`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body)
            });

            const data = await response.json();
            if (!data.ok) {
              throw new Error(`Slack API error: ${data.error}`);
            }
            return data;
          }

          // Check if PR is merged
          const isMerged = labels.some(l => l.name === 'status:merged');
          
          let messageBlocks;
          
          if (isMerged) {
            // Simplified message for merged PRs
            messageBlocks = [
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: `:tada: ${pr_title}`
                },
                accessory: {
                  type: 'button',
                  text: {
                    type: 'plain_text',
                    text: 'View PR',
                    emoji: false
                  },
                  url: pr_url,
                  style: 'primary'
                }
              }
            ];
          } else {
            // Full message for open PRs
            // GitHub OG image URL construction with cache busting
            // Use a combination of timestamp and QA state to force refresh when runs start
            const qaRunning = labels.some(l => l.name === 'qa:running');
            const cacheKey = qaRunning ? `qa-${Date.now()}` : Date.now();
            const ogImageUrl = `https://opengraph.githubassets.com/${cacheKey}/${context.repo.owner}/${context.repo.repo}/pull/${pr_number}`;
            
            console.log(`Using OG image URL with cache key: ${cacheKey}`);
            
            messageBlocks = [
              {
                type: 'image',
                image_url: ogImageUrl,
                alt_text: `PR #${pr_number}: ${pr_title}`
              },
              {
                type: 'actions',
                elements: [
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'View PR',
                      emoji: false
                    },
                    url: pr_url,
                    style: 'primary'
                  },
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'Files',
                      emoji: false
                    },
                    url: `${pr_url}/files`
                  },
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'Checks',
                      emoji: false
                    },
                    url: `${pr_url}/checks`
                  },
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'Commits',
                      emoji: false
                    },
                    url: `${pr_url}/commits`
                  },
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'Review',
                      emoji: false
                    },
                    url: `${pr_url}#pullrequestreview-new_comment_form`
                  }
                ]
              }
            ];
          }

          try {
            if (!slackTs) {
              // Create a lock to prevent race conditions
              console.log('Creating lock to prevent duplicate messages...');
              const lockComment = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                body: '<!-- slack-creating-lock -->'
              });

              // Double-check that no other process created a message while we were creating the lock
              const { data: checkComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number
              });
              
              const existingSlackComment = checkComments.find(c => 
                c.body && c.body.includes('<!-- slack-ts:') && c.id !== lockComment.id
              );
              
              if (existingSlackComment) {
                console.log('Another process created a Slack message while we were locking, using that instead');
                // Delete our lock
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: lockComment.id
                });
                
                const match = existingSlackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
                if (match) {
                  slackTs = match[1];
                }
              } else {
                // Send new message
                const result = await slackAPI('chat.postMessage', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  text: `#${pr_number}: ${pr_title}`,
                  blocks: messageBlocks
                });

                // Store timestamp
                if (result.ts) {
                console.log(`Storing Slack timestamp ${result.ts} as PR comment`);
                
                // Get Slack workspace info for the permalink
                let permalink = '';
                try {
                  const messageTs = result.ts.replace('.', '');
                  // Note: This requires the Slack workspace URL to be configured
                  // For now, we'll include instructions on how to find the message
                  permalink = `To view this PR in Slack, search for message timestamp: ${result.ts}`;
                } catch (e) {
                  console.log('Could not generate Slack permalink:', e.message);
                }
                
                const commentBody = [
                  `<!-- slack-ts:${result.ts} -->`,
                  `This pull request is being tracked in Slack.`,
                  ``,
                  permalink,
                  ``,
                  `<details>`,
                  `<summary>Slack Message Details</summary>`,
                  ``,
                  `- **Channel ID**: ${process.env.SLACK_CHANNEL_ID}`,
                  `- **Message Timestamp**: ${result.ts}`,
                  `- **PR Number**: #${pr_number}`,
                  ``,
                  `</details>`
                ].join('\n');
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr_number,
                  body: commentBody
                });
                
                // Delete the lock comment
                try {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: lockComment.id
                  });
                  console.log('Deleted creation lock');
                } catch (e) {
                  console.log('Could not delete lock comment:', e.message);
                }
                
                slackTs = result.ts;
                console.log('Successfully stored Slack timestamp');
              }
              }
            } else {
              // Always update the message to ensure latest title and content
              console.log('Updating Slack message with latest content');
              await slackAPI('chat.update', {
                channel: process.env.SLACK_CHANNEL_ID,
                ts: slackTs,
                text: `#${pr_number}: ${pr_title}`,
                blocks: messageBlocks
              });
            }

            if (slackTs) {
              // Small delay to ensure previous operations have completed
              await new Promise(resolve => setTimeout(resolve, 500));

              // Get existing reactions
              let existingReactions = [];
              try {
                // Use conversations.history instead of reactions.get
                const history = await slackAPI('conversations.history', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  latest: slackTs,
                  inclusive: true,
                  limit: 1
                });

                if (history.messages && history.messages.length > 0) {
                  const message = history.messages[0];
                  if (message.reactions) {
                    existingReactions = message.reactions
                      .filter(r => r.users && r.users.length > 0) // Only reactions that have users
                      .map(r => r.name);
                    console.log('Existing reactions on message:', existingReactions);
                  }
                }
              } catch (e) {
                console.log('Could not get existing reactions:', e.message);
                // Continue anyway - we'll handle errors when adding/removing
              }

              // STRICT SYNC: Only show reactions that have corresponding labels
              // This ensures 100% sync between labels and reactions
              
              let reactionsToRemove, reactionsToAdd;
              
              if (isMerged) {
                // For merged PRs, remove ALL managed reactions
                reactionsToRemove = existingReactions.filter(reaction => 
                  allStatusReactions.includes(reaction)
                );
                reactionsToAdd = [];
              } else {
                // Step 1: Determine ALL reactions that should be removed
                // Remove any reaction that doesn't have a corresponding label
                reactionsToRemove = existingReactions.filter(reaction => {
                  // Check if this is a managed reaction
                  if (!allStatusReactions.includes(reaction)) {
                    return false; // Don't remove reactions we don't manage
                  }
                  
                  // Check if this reaction has a corresponding current label
                  return !filteredStatuses.includes(reaction);
                });
                
                // Step 2: Determine what reactions need to be added
                // Only add reactions that correspond to current labels and aren't already present
                reactionsToAdd = filteredStatuses.filter(reaction => 
                  !existingReactions.includes(reaction)
                );
              }
              
              console.log('Current label-based reactions:', filteredStatuses);
              console.log('Existing reactions:', existingReactions);
              console.log('Reactions to remove (not in labels):', reactionsToRemove);
              console.log('Reactions to add (from labels):', reactionsToAdd);

              // Remove outdated reactions first (with proper synchronization)
              for (const reactionName of reactionsToRemove) {
                try {
                  console.log(`Removing outdated reaction: ${reactionName}`);
                  await slackAPI('reactions.remove', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    name: reactionName
                  });
                  // Increased delay to ensure proper synchronization
                  await new Promise(resolve => setTimeout(resolve, 200));
                } catch (e) {
                  if (e.message.includes('missing_scope')) {
                    console.error(`ERROR: Slack bot missing permission to remove reactions. Please add 'reactions:write' scope to the Slack app.`);
                    break;
                  } else if (e.message.includes('no_reaction')) {
                    console.log(`Reaction ${reactionName} was already removed`);
                  } else {
                    console.log(`Could not remove reaction ${reactionName}: ${e.message}`);
                  }
                }
              }

              // Wait a bit after removals to ensure Slack has processed them
              if (reactionsToRemove.length > 0) {
                await new Promise(resolve => setTimeout(resolve, 500));
              }

              // Add new reactions
              for (const reaction of reactionsToAdd) {
                try {
                  console.log(`Adding reaction: ${reaction}`);
                  await slackAPI('reactions.add', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    name: reaction
                  });
                  console.log(`Successfully added reaction: ${reaction}`);
                  // Increased delay to ensure proper synchronization
                  await new Promise(resolve => setTimeout(resolve, 200));
                } catch (e) {
                  if (e.message.includes('missing_scope')) {
                    console.error(`ERROR: Slack bot missing permission to add reactions. Please add 'reactions:write' scope to the Slack app.`);
                    break;
                  } else if (e.message.includes('already_reacted')) {
                    console.log(`Reaction ${reaction} already exists (race condition)`);
                  } else {
                    console.log(`Could not add reaction ${reaction}: ${e.message}`);
                  }
                }
              }
            }
          } catch (error) {
            console.error('Slack notification error:', error);
            // Don't fail the workflow for Slack errors
          }
