name: "Unified PR Labeler"
description: "Unified labeling system for PRs - handles all label updates in one place"
inputs:
  pr_number:
    description: "Pull request number"
    required: true
  pr_title:
    description: "Pull request title"
    required: true
  pr_body:
    description: "Pull request body"
    required: false
    default: ""
  pr_author:
    description: "Pull request author"
    required: true
  pr_author_type:
    description: "Pull request author type (User or Bot)"
    required: false
    default: "User"
  is_draft:
    description: "Whether the PR is a draft"
    required: false
    default: "false"
  is_merged:
    description: "Whether the PR is merged"
    required: false
    default: "false"
  qa_status:
    description: "QA workflow status (pending/running/success/failed)"
    required: false
    default: "pending"
  has_approval:
    description: "Whether the PR has been approved"
    required: false
    default: "false"
  update_type:
    description: "Type of update (initial/qa-status/review-status/merged)"
    required: true

runs:
  using: "composite"
  steps:
    - name: Update PR labels
      uses: actions/github-script@v7
      with:
        script: |
          const pr_number = parseInt(${{ inputs.pr_number }});
          const pr_title = ${{ toJSON(inputs.pr_title) }};
          const pr_body = ${{ toJSON(inputs.pr_body) }};
          const pr_author = ${{ toJSON(inputs.pr_author) }};
          const pr_author_type = '${{ inputs.pr_author_type }}';
          const is_draft = '${{ inputs.is_draft }}' === 'true';
          const is_merged = '${{ inputs.is_merged }}' === 'true';
          const qa_status = '${{ inputs.qa_status }}';
          const has_approval = '${{ inputs.has_approval }}' === 'true';
          const update_type = '${{ inputs.update_type }}';

          console.log(`Unified labeler - Update type: ${update_type}`);
          console.log(`PR #${pr_number}: Draft=${is_draft}, QA=${qa_status}, Approved=${has_approval}, Merged=${is_merged}`);

          // Define all labels in one place
          const labelDefinitions = {
            // Conventional commit labels
            feat: { color: '0366d6', description: '✨ New feature' },
            fix: { color: 'd73a4a', description: '🐛 Bug fix' },
            docs: { color: '0075ca', description: '📝 Documentation' },
            style: { color: 'e4e669', description: '💄 Style changes' },
            refactor: { color: '008672', description: '♻️ Code refactoring' },
            perf: { color: 'a2eeef', description: '⚡ Performance improvements' },
            test: { color: 'f9d0c4', description: '✅ Tests' },
            build: { color: 'f06292', description: '🔨 Build system' },
            ci: { color: 'fbca04', description: '👷 CI/CD' },
            chore: { color: 'fef2c0', description: '🔧 Chores' },
            revert: { color: '6f42c1', description: '⏪ Reverts' },
            dependencies: { color: '0366d6', description: '📦 Dependencies' },
            breaking: { color: 'd93f0b', description: '💥 Breaking changes' },
            
            // QA status labels
            'qa:pending': { color: 'e4e669', description: 'QA workflow needs to run' },
            'qa:running': { color: 'fbca04', description: 'QA workflow is running' },
            'qa:success': { color: '0e8a16', description: 'QA workflow passed' },
            'qa:failed': { color: 'd73a4a', description: 'QA workflow failed' },
            
            // PR status labels
            'status:draft': { color: '6a737d', description: 'PR is in draft mode' },
            'status:ready-for-review': { color: 'fbca04', description: 'PR is ready for review' },
            'status:approved': { color: '0e8a16', description: 'PR has been approved' },
            'status:mergeable': { color: '0e8a16', description: 'PR is ready to merge' },
            'status:merged': { color: '6f42c1', description: 'PR has been merged' }
          };

          // Ensure all label definitions exist
          const ensureLabels = async () => {
            const { data: existingLabels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const existingLabelNames = new Set(existingLabels.map(l => l.name));

            for (const [name, config] of Object.entries(labelDefinitions)) {
              if (!existingLabelNames.has(name)) {
                console.log(`Creating label: ${name}`);
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name,
                  color: config.color,
                  description: config.description
                });
              }
            }
          };

          // Parse conventional commit from title
          const parseConventionalCommit = (title) => {
            const regex = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([\w\-\s,]+\))?(!)?:\s+(.+)$/;
            const match = title.match(regex);
            
            if (match) {
              const [, type, scope, breaking] = match;
              const labels = [type];
              
              // Check for dependencies in scope
              if (scope && scope.includes('deps')) {
                labels.push('dependencies');
                // Remove the original type label for dependency updates
                const typeIndex = labels.indexOf(type);
                if (typeIndex > -1) labels.splice(typeIndex, 1);
              }
              
              if (breaking) {
                labels.push('breaking');
              }
              
              return labels;
            }
            
            return ['chore']; // Default if no match
          };

          // Determine which labels to apply based on current state
          const determineLabels = () => {
            const labels = new Set();

            // Add conventional commit labels (only on initial)
            if (update_type === 'initial') {
              const commitLabels = parseConventionalCommit(pr_title);
              commitLabels.forEach(l => labels.add(l));
            }

            // Add QA status label
            if (qa_status && qa_status !== 'none') {
              labels.add(`qa:${qa_status}`);
            }

            // Add PR status label
            if (is_merged) {
              labels.add('status:merged');
            } else if (qa_status === 'success' && has_approval) {
              labels.add('status:mergeable');
            } else if (has_approval) {
              labels.add('status:approved');
            } else if (is_draft) {
              labels.add('status:draft');
            } else {
              labels.add('status:ready-for-review');
            }

            return Array.from(labels);
          };

          try {
            // Ensure all labels exist
            await ensureLabels();

            // Get current labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            const currentLabelNames = currentLabels.map(l => l.name);
            const newLabels = determineLabels();

            // Determine labels to add/remove
            const labelsToAdd = newLabels.filter(l => !currentLabelNames.includes(l));
            const labelsToRemove = currentLabelNames.filter(l => {
              // Only remove labels we manage
              const isQaLabel = l.startsWith('qa:');
              const isStatusLabel = l.startsWith('status:');
              const isConventionalLabel = labelDefinitions.hasOwnProperty(l);
              
              if (isQaLabel || isStatusLabel) {
                return !newLabels.includes(l);
              }
              
              // Don't remove conventional commit labels after initial
              if (isConventionalLabel && update_type !== 'initial') {
                return false;
              }
              
              return isConventionalLabel && !newLabels.includes(l);
            });

            console.log('Current labels:', currentLabelNames);
            console.log('New labels:', newLabels);
            console.log('Labels to add:', labelsToAdd);
            console.log('Labels to remove:', labelsToRemove);

            // Apply label changes
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                labels: labelsToAdd
              });
            }

            for (const label of labelsToRemove) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                name: label
              });
            }

            console.log('Label update complete');
          } catch (error) {
            console.error('Error updating labels:', error);
            throw error;
          }