name: QA - Pull Request

on:
  pull_request:
    types:
      [
        opened,
        synchronize,
        reopened,
        ready_for_review,
        converted_to_draft,
        closed,
        review_requested,
        edited,
      ]
    branches:
      - main
  pull_request_review:
    types: [submitted, dismissed]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.action }}
  cancel-in-progress: ${{ github.event.action == 'synchronize' }}

jobs:
  # Label PR based on draft/ready status
  label-pr-status:
    name: Label PR Status
    if: |
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]') &&
      (github.event.action == 'opened' ||
       github.event.action == 'ready_for_review' ||
       github.event.action == 'converted_to_draft' ||
       github.event.action == 'synchronize')
    uses: ./.github/workflows/reusable-pr-status-labeler.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      is_draft: ${{ github.event.pull_request.draft }}
      runs-on: namespace-profile-atk-services

  # Send Slack notification after PR status labeling
  slack-notify-pr-status:
    name: Slack Notify - PR Status
    needs: [label-pr-status]
    if: |
      always() &&
      needs.label-pr-status.result == 'success' &&
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    runs-on: namespace-profile-atk-services
    steps:
      - name: Setup 1Password
        uses: 1password/load-secrets-action/configure@v2
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load secrets
        uses: 1password/load-secrets-action@v2
        env:
          SLACK_BOT_TOKEN: op://platform/slack-bot/SLACK_BOT_TOKEN
          SLACK_CHANNEL_ID: op://platform/slack-bot/SLACK_CHANNEL_ID

      - name: Wait for labels to be applied
        run: sleep 2

      - name: Get PR labels and send Slack notification
        uses: actions/github-script@v7
        env:
          SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ env.SLACK_CHANNEL_ID }}
        with:
          script: |
            // Get PR labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.pull_request.number }}
            });
            
            const labels = pr.labels || [];
            const pr_title = ${{ toJSON(github.event.pull_request.title) }};
            const pr_url = ${{ toJSON(github.event.pull_request.html_url) }};
            const pr_number = ${{ github.event.pull_request.number }};
            
            // Extract repo name without org
            const repoName = context.repo.repo;

            // Check if PR is draft
            const isDraft = Array.isArray(labels) && labels.some(label => label.name === 'status:draft');
            if (isDraft) {
              console.log('Skipping notification for draft PR');
              return;
            }

            // Define status reactions mapping
            const statusReactions = {
              'qa:pending': 'hourglass_flowing_sand',
              'qa:running': 'runner',
              'qa:success': 'white_check_mark',
              'qa:failed': 'x',
              'status:ready-for-review': 'eyes',
              'status:approved': 'thumbsup',
              'status:mergeable': 'rocket',
              'status:merged': 'tada'
            };
            
            // Define mutually exclusive groups (only one can be active at a time)
            const exclusiveGroups = {
              'qa': ['hourglass_flowing_sand', 'runner', 'white_check_mark', 'x'],
              'status': ['eyes', 'thumbsup', 'rocket', 'tada']
            };
            
            // All possible status reactions we manage
            const allStatusReactions = Object.values(statusReactions);

            // Get current status labels
            console.log('Current PR labels:', labels.map(l => l.name));
            const currentStatuses = labels
              .filter(label => Object.keys(statusReactions).includes(label.name))
              .map(label => statusReactions[label.name]);
            console.log('Reactions to add:', currentStatuses);

            // Check if there's an existing Slack message
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            console.log(`Found ${comments.length} comments on PR`);
            const slackComment = comments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
            let slackTs = null;

            if (slackComment) {
              const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
              if (match) {
                slackTs = match[1];
                console.log(`Found existing Slack message timestamp: ${slackTs}`);
              }
            } else {
              console.log('No existing Slack message found');
            }

            // Helper function to make Slack API calls
            async function slackAPI(method, body = {}) {
              const response = await fetch(`https://slack.com/api/${method}`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
              });

              const data = await response.json();
              if (!data.ok) {
                throw new Error(`Slack API error: ${data.error}`);
              }
              return data;
            }

            try {
              if (!slackTs) {
                // Send new message
                // Get PR author info
                const pr_author = `${{ github.event.pull_request.user.login }}`;
                const author_avatar = `${{ github.event.pull_request.user.avatar_url }}`;
                
                const result = await slackAPI('chat.postMessage', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  text: `PR #${pr_number}: ${pr_title}`,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: `PR #${pr_number}`,
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*${pr_title}*`
                      }
                    },
                    {
                      type: 'context',
                      elements: [
                        {
                          type: 'image',
                          image_url: author_avatar,
                          alt_text: pr_author
                        },
                        {
                          type: 'mrkdwn',
                          text: `*Author:* ${pr_author} â€¢ *Repository:* ${repoName}`
                        }
                      ]
                    },
                    {
                      type: 'divider'
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'ðŸ‘€ View PR',
                            emoji: true
                          },
                          url: pr_url,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                });

                // Store timestamp
                if (result.ts) {
                  console.log(`Storing Slack timestamp ${result.ts} as PR comment`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr_number,
                    body: `<!-- slack-ts:${result.ts} -->`
                  });
                  slackTs = result.ts;
                  console.log('Successfully stored Slack timestamp');
                }
              }

              if (slackTs) {
                // Get existing reactions
                let existingReactions = [];
                try {
                  const reactions = await slackAPI('reactions.get', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    full: true
                  });
                  
                  if (reactions.message && reactions.message.reactions) {
                    existingReactions = reactions.message.reactions.map(r => r.name);
                    console.log('Existing reactions on message:', existingReactions);
                  }

                  // Smart reaction management to avoid flickering
                  // First, determine what needs to change
                  const reactionsToAdd = [];
                  const reactionsToRemove = [];
                  
                  // For each desired reaction, check if we need to add it
                  for (const desiredReaction of currentStatuses) {
                    if (!existingReactions.includes(desiredReaction)) {
                      reactionsToAdd.push(desiredReaction);
                    }
                  }
                  
                  // For each exclusive group, find reactions that need to be removed
                  for (const desiredReaction of currentStatuses) {
                    for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
                      if (groupReactions.includes(desiredReaction)) {
                        // Remove other reactions in this group that currently exist
                        for (const groupReaction of groupReactions) {
                          if (groupReaction !== desiredReaction && existingReactions.includes(groupReaction)) {
                            reactionsToRemove.push(groupReaction);
                          }
                        }
                      }
                    }
                  }
                  
                  console.log('Reactions to remove:', reactionsToRemove);
                  console.log('Reactions to add:', reactionsToAdd);
                  
                  // Remove outdated reactions first
                  for (const reactionName of reactionsToRemove) {
                    try {
                      console.log(`Removing outdated reaction: ${reactionName}`);
                      await slackAPI('reactions.remove', {
                        channel: process.env.SLACK_CHANNEL_ID,
                        timestamp: slackTs,
                        name: reactionName
                      });
                      // Small delay to avoid rate limits
                      await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (e) {
                      if (e.message.includes('missing_scope')) {
                        console.error(`ERROR: Slack bot missing permission to remove reactions. Please add 'reactions:write' scope to the Slack app.`);
                        break;
                      } else if (e.message.includes('no_reaction')) {
                        console.log(`Reaction ${reactionName} was already removed`);
                      } else {
                        console.log(`Could not remove reaction ${reactionName}: ${e.message}`);
                      }
                    }
                  }
                } catch (e) {
                  console.log('Could not get existing reactions:', e.message);
                  // Continue anyway - we'll handle errors when adding/removing
                }

                // Add new reactions
                for (const reaction of reactionsToAdd) {
                  try {
                    console.log(`Adding reaction: ${reaction}`);
                    await slackAPI('reactions.add', {
                      channel: process.env.SLACK_CHANNEL_ID,
                      timestamp: slackTs,
                      name: reaction
                    });
                    console.log(`Successfully added reaction: ${reaction}`);
                    // Small delay to avoid rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                  } catch (e) {
                    if (e.message.includes('missing_scope')) {
                      console.error(`ERROR: Slack bot missing permission to add reactions. Please add 'reactions:write' scope to the Slack app.`);
                      break;
                    } else if (e.message.includes('already_reacted')) {
                      console.log(`Reaction ${reaction} already exists (race condition)`);
                    } else {
                      console.log(`Could not add reaction ${reaction}: ${e.message}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.error('Slack notification error:', error);
              // Don't fail the workflow for Slack errors
            }

  # Label PR as QA running when workflow starts (skip pending label)
  label-qa-start:
    name: Label QA Start
    if: |
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]') &&
      (github.event.action == 'synchronize' || github.event.action == 'opened')
    uses: ./.github/workflows/reusable-build-status-labeler.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      workflow_status: 'running'
      runs-on: namespace-profile-atk-services

  # Send Slack notification for QA start
  slack-notify-qa-start:
    name: Slack Notify - QA Running
    needs: [label-qa-start]
    if: |
      always() &&
      needs.label-qa-start.result == 'success' &&
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    runs-on: namespace-profile-atk-services
    steps:
      - name: Setup 1Password
        uses: 1password/load-secrets-action/configure@v2
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load secrets
        uses: 1password/load-secrets-action@v2
        env:
          SLACK_BOT_TOKEN: op://platform/slack-bot/SLACK_BOT_TOKEN
          SLACK_CHANNEL_ID: op://platform/slack-bot/SLACK_CHANNEL_ID

      - name: Wait for labels to be applied
        run: sleep 2

      - name: Get PR labels and send Slack notification
        uses: actions/github-script@v7
        env:
          SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ env.SLACK_CHANNEL_ID }}
        with:
          script: |
            // Get PR labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.pull_request.number }}
            });
            
            const labels = pr.labels || [];
            const pr_title = ${{ toJSON(github.event.pull_request.title) }};
            const pr_url = ${{ toJSON(github.event.pull_request.html_url) }};
            const pr_number = ${{ github.event.pull_request.number }};
            
            // Extract repo name without org
            const repoName = context.repo.repo;

            // Check if PR is draft
            const isDraft = Array.isArray(labels) && labels.some(label => label.name === 'status:draft');
            if (isDraft) {
              console.log('Skipping notification for draft PR');
              return;
            }

            // Define status reactions mapping
            const statusReactions = {
              'qa:pending': 'hourglass_flowing_sand',
              'qa:running': 'runner',
              'qa:success': 'white_check_mark',
              'qa:failed': 'x',
              'status:ready-for-review': 'eyes',
              'status:approved': 'thumbsup',
              'status:mergeable': 'rocket',
              'status:merged': 'tada'
            };
            
            // Define mutually exclusive groups (only one can be active at a time)
            const exclusiveGroups = {
              'qa': ['hourglass_flowing_sand', 'runner', 'white_check_mark', 'x'],
              'status': ['eyes', 'thumbsup', 'rocket', 'tada']
            };
            
            // All possible status reactions we manage
            const allStatusReactions = Object.values(statusReactions);

            // Get current status labels
            console.log('Current PR labels:', labels.map(l => l.name));
            const currentStatuses = labels
              .filter(label => Object.keys(statusReactions).includes(label.name))
              .map(label => statusReactions[label.name]);
            console.log('Reactions to add:', currentStatuses);

            // Check if there's an existing Slack message
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            console.log(`Found ${comments.length} comments on PR`);
            const slackComment = comments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
            let slackTs = null;

            if (slackComment) {
              const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
              if (match) {
                slackTs = match[1];
                console.log(`Found existing Slack message timestamp: ${slackTs}`);
              }
            } else {
              console.log('No existing Slack message found');
            }

            // Helper function to make Slack API calls
            async function slackAPI(method, body = {}) {
              const response = await fetch(`https://slack.com/api/${method}`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
              });

              const data = await response.json();
              if (!data.ok) {
                throw new Error(`Slack API error: ${data.error}`);
              }
              return data;
            }

            try {
              if (!slackTs) {
                // Send new message
                // Get PR author info
                const pr_author = `${{ github.event.pull_request.user.login }}`;
                const author_avatar = `${{ github.event.pull_request.user.avatar_url }}`;
                
                const result = await slackAPI('chat.postMessage', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  text: `PR #${pr_number}: ${pr_title}`,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: `PR #${pr_number}`,
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*${pr_title}*`
                      }
                    },
                    {
                      type: 'context',
                      elements: [
                        {
                          type: 'image',
                          image_url: author_avatar,
                          alt_text: pr_author
                        },
                        {
                          type: 'mrkdwn',
                          text: `*Author:* ${pr_author} â€¢ *Repository:* ${repoName}`
                        }
                      ]
                    },
                    {
                      type: 'divider'
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'ðŸ‘€ View PR',
                            emoji: true
                          },
                          url: pr_url,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                });

                // Store timestamp
                if (result.ts) {
                  console.log(`Storing Slack timestamp ${result.ts} as PR comment`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr_number,
                    body: `<!-- slack-ts:${result.ts} -->`
                  });
                  slackTs = result.ts;
                  console.log('Successfully stored Slack timestamp');
                }
              }

              if (slackTs) {
                // Get existing reactions
                let existingReactions = [];
                try {
                  const reactions = await slackAPI('reactions.get', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    full: true
                  });
                  
                  if (reactions.message && reactions.message.reactions) {
                    existingReactions = reactions.message.reactions.map(r => r.name);
                    console.log('Existing reactions on message:', existingReactions);
                  }

                  // Smart reaction management to avoid flickering
                  // First, determine what needs to change
                  const reactionsToAdd = [];
                  const reactionsToRemove = [];
                  
                  // For each desired reaction, check if we need to add it
                  for (const desiredReaction of currentStatuses) {
                    if (!existingReactions.includes(desiredReaction)) {
                      reactionsToAdd.push(desiredReaction);
                    }
                  }
                  
                  // For each exclusive group, find reactions that need to be removed
                  for (const desiredReaction of currentStatuses) {
                    for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
                      if (groupReactions.includes(desiredReaction)) {
                        // Remove other reactions in this group that currently exist
                        for (const groupReaction of groupReactions) {
                          if (groupReaction !== desiredReaction && existingReactions.includes(groupReaction)) {
                            reactionsToRemove.push(groupReaction);
                          }
                        }
                      }
                    }
                  }
                  
                  console.log('Reactions to remove:', reactionsToRemove);
                  console.log('Reactions to add:', reactionsToAdd);
                  
                  // Remove outdated reactions first
                  for (const reactionName of reactionsToRemove) {
                    try {
                      console.log(`Removing outdated reaction: ${reactionName}`);
                      await slackAPI('reactions.remove', {
                        channel: process.env.SLACK_CHANNEL_ID,
                        timestamp: slackTs,
                        name: reactionName
                      });
                      // Small delay to avoid rate limits
                      await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (e) {
                      if (e.message.includes('missing_scope')) {
                        console.error(`ERROR: Slack bot missing permission to remove reactions. Please add 'reactions:write' scope to the Slack app.`);
                        break;
                      } else if (e.message.includes('no_reaction')) {
                        console.log(`Reaction ${reactionName} was already removed`);
                      } else {
                        console.log(`Could not remove reaction ${reactionName}: ${e.message}`);
                      }
                    }
                  }
                } catch (e) {
                  console.log('Could not get existing reactions:', e.message);
                  // Continue anyway - we'll handle errors when adding/removing
                }

                // Add new reactions
                for (const reaction of reactionsToAdd) {
                  try {
                    console.log(`Adding reaction: ${reaction}`);
                    await slackAPI('reactions.add', {
                      channel: process.env.SLACK_CHANNEL_ID,
                      timestamp: slackTs,
                      name: reaction
                    });
                    console.log(`Successfully added reaction: ${reaction}`);
                    // Small delay to avoid rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                  } catch (e) {
                    if (e.message.includes('missing_scope')) {
                      console.error(`ERROR: Slack bot missing permission to add reactions. Please add 'reactions:write' scope to the Slack app.`);
                      break;
                    } else if (e.message.includes('already_reacted')) {
                      console.log(`Reaction ${reaction} already exists (race condition)`);
                    } else {
                      console.log(`Could not add reaction ${reaction}: ${e.message}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.error('Slack notification error:', error);
              // Don't fail the workflow for Slack errors
            }
  qa:
    name: QA
    needs: [label-qa-start, slack-notify-qa-start]
    if: |
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]') &&
      (github.event.action == 'synchronize' || github.event.action == 'opened')
    uses: ./.github/workflows/reusable-qa.yml
    with:
      runs-on: namespace-profile-atk
      fetch-depth: 2
    secrets:
      OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

  pr-labels:
    name: PR Labels
    if: |
      github.event_name == 'pull_request' &&
      (github.event.action == 'opened' ||
       github.event.action == 'synchronize' ||
       github.event.action == 'edited')
    uses: ./.github/workflows/reusable-pr-labeler.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      pr_title: ${{ github.event.pull_request.title }}
      pr_body: ${{ github.event.pull_request.body }}
      runs-on: namespace-profile-atk-services

  secret-scanning:
    name: Secret Scanning
    if: |
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]') &&
      (github.event.action == 'synchronize' || github.event.action == 'opened')
    uses: ./.github/workflows/reusable-secret-scanning.yml
    with:
      runs-on: namespace-profile-atk-services
      trivy-config: trivy-secret.yaml
      severity: "HIGH,CRITICAL"


  # Label PR with final QA status
  label-qa-end:
    name: Label QA End
    needs: [qa, secret-scanning]
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]') &&
      (github.event.action == 'synchronize' || github.event.action == 'opened')
    uses: ./.github/workflows/reusable-build-status-labeler.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      workflow_status: ${{ (needs.qa.result == 'success' && needs.secret-scanning.result == 'success') && 'success' || 'failure' }}
      runs-on: namespace-profile-atk-services

  # Send Slack notification for QA completion
  slack-notify-qa-end:
    name: Slack Notify - QA Complete
    needs: [label-qa-end, qa, secret-scanning]
    if: |
      always() &&
      needs.label-qa-end.result == 'success' &&
      github.event_name == 'pull_request' &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    runs-on: namespace-profile-atk-services
    steps:
      - name: Setup 1Password
        uses: 1password/load-secrets-action/configure@v2
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load secrets
        uses: 1password/load-secrets-action@v2
        env:
          SLACK_BOT_TOKEN: op://platform/slack-bot/SLACK_BOT_TOKEN
          SLACK_CHANNEL_ID: op://platform/slack-bot/SLACK_CHANNEL_ID

      - name: Wait for labels to be applied
        run: sleep 2

      - name: Get PR labels and send Slack notification
        uses: actions/github-script@v7
        env:
          SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ env.SLACK_CHANNEL_ID }}
        with:
          script: |
            // Get PR labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.pull_request.number }}
            });
            
            const labels = pr.labels || [];
            const pr_title = ${{ toJSON(github.event.pull_request.title) }};
            const pr_url = ${{ toJSON(github.event.pull_request.html_url) }};
            const pr_number = ${{ github.event.pull_request.number }};
            
            // Extract repo name without org
            const repoName = context.repo.repo;

            // Check if PR is draft
            const isDraft = Array.isArray(labels) && labels.some(label => label.name === 'status:draft');
            if (isDraft) {
              console.log('Skipping notification for draft PR');
              return;
            }

            // Define status reactions mapping
            const statusReactions = {
              'qa:pending': 'hourglass_flowing_sand',
              'qa:running': 'runner',
              'qa:success': 'white_check_mark',
              'qa:failed': 'x',
              'status:ready-for-review': 'eyes',
              'status:approved': 'thumbsup',
              'status:mergeable': 'rocket',
              'status:merged': 'tada'
            };
            
            // Define mutually exclusive groups (only one can be active at a time)
            const exclusiveGroups = {
              'qa': ['hourglass_flowing_sand', 'runner', 'white_check_mark', 'x'],
              'status': ['eyes', 'thumbsup', 'rocket', 'tada']
            };
            
            // All possible status reactions we manage
            const allStatusReactions = Object.values(statusReactions);

            // Get current status labels
            console.log('Current PR labels:', labels.map(l => l.name));
            const currentStatuses = labels
              .filter(label => Object.keys(statusReactions).includes(label.name))
              .map(label => statusReactions[label.name]);
            console.log('Reactions to add:', currentStatuses);

            // Check if there's an existing Slack message
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            console.log(`Found ${comments.length} comments on PR`);
            const slackComment = comments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
            let slackTs = null;

            if (slackComment) {
              const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
              if (match) {
                slackTs = match[1];
                console.log(`Found existing Slack message timestamp: ${slackTs}`);
              }
            } else {
              console.log('No existing Slack message found');
            }

            // Helper function to make Slack API calls
            async function slackAPI(method, body = {}) {
              const response = await fetch(`https://slack.com/api/${method}`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
              });

              const data = await response.json();
              if (!data.ok) {
                throw new Error(`Slack API error: ${data.error}`);
              }
              return data;
            }

            try {
              if (!slackTs) {
                // Send new message
                // Get PR author info
                const pr_author = `${{ github.event.pull_request.user.login }}`;
                const author_avatar = `${{ github.event.pull_request.user.avatar_url }}`;
                
                const result = await slackAPI('chat.postMessage', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  text: `PR #${pr_number}: ${pr_title}`,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: `PR #${pr_number}`,
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*${pr_title}*`
                      }
                    },
                    {
                      type: 'context',
                      elements: [
                        {
                          type: 'image',
                          image_url: author_avatar,
                          alt_text: pr_author
                        },
                        {
                          type: 'mrkdwn',
                          text: `*Author:* ${pr_author} â€¢ *Repository:* ${repoName}`
                        }
                      ]
                    },
                    {
                      type: 'divider'
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'ðŸ‘€ View PR',
                            emoji: true
                          },
                          url: pr_url,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                });

                // Store timestamp
                if (result.ts) {
                  console.log(`Storing Slack timestamp ${result.ts} as PR comment`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr_number,
                    body: `<!-- slack-ts:${result.ts} -->`
                  });
                  slackTs = result.ts;
                  console.log('Successfully stored Slack timestamp');
                }
              }

              if (slackTs) {
                // Get existing reactions
                let existingReactions = [];
                try {
                  const reactions = await slackAPI('reactions.get', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    full: true
                  });
                  
                  if (reactions.message && reactions.message.reactions) {
                    existingReactions = reactions.message.reactions.map(r => r.name);
                    console.log('Existing reactions on message:', existingReactions);
                  }

                  // Smart reaction management to avoid flickering
                  // First, determine what needs to change
                  const reactionsToAdd = [];
                  const reactionsToRemove = [];
                  
                  // For each desired reaction, check if we need to add it
                  for (const desiredReaction of currentStatuses) {
                    if (!existingReactions.includes(desiredReaction)) {
                      reactionsToAdd.push(desiredReaction);
                    }
                  }
                  
                  // For each exclusive group, find reactions that need to be removed
                  for (const desiredReaction of currentStatuses) {
                    for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
                      if (groupReactions.includes(desiredReaction)) {
                        // Remove other reactions in this group that currently exist
                        for (const groupReaction of groupReactions) {
                          if (groupReaction !== desiredReaction && existingReactions.includes(groupReaction)) {
                            reactionsToRemove.push(groupReaction);
                          }
                        }
                      }
                    }
                  }
                  
                  console.log('Reactions to remove:', reactionsToRemove);
                  console.log('Reactions to add:', reactionsToAdd);
                  
                  // Remove outdated reactions first
                  for (const reactionName of reactionsToRemove) {
                    try {
                      console.log(`Removing outdated reaction: ${reactionName}`);
                      await slackAPI('reactions.remove', {
                        channel: process.env.SLACK_CHANNEL_ID,
                        timestamp: slackTs,
                        name: reactionName
                      });
                      // Small delay to avoid rate limits
                      await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (e) {
                      if (e.message.includes('missing_scope')) {
                        console.error(`ERROR: Slack bot missing permission to remove reactions. Please add 'reactions:write' scope to the Slack app.`);
                        break;
                      } else if (e.message.includes('no_reaction')) {
                        console.log(`Reaction ${reactionName} was already removed`);
                      } else {
                        console.log(`Could not remove reaction ${reactionName}: ${e.message}`);
                      }
                    }
                  }
                } catch (e) {
                  console.log('Could not get existing reactions:', e.message);
                  // Continue anyway - we'll handle errors when adding/removing
                }

                // Add new reactions
                for (const reaction of reactionsToAdd) {
                  try {
                    console.log(`Adding reaction: ${reaction}`);
                    await slackAPI('reactions.add', {
                      channel: process.env.SLACK_CHANNEL_ID,
                      timestamp: slackTs,
                      name: reaction
                    });
                    console.log(`Successfully added reaction: ${reaction}`);
                    // Small delay to avoid rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                  } catch (e) {
                    if (e.message.includes('missing_scope')) {
                      console.error(`ERROR: Slack bot missing permission to add reactions. Please add 'reactions:write' scope to the Slack app.`);
                      break;
                    } else if (e.message.includes('already_reacted')) {
                      console.log(`Reaction ${reaction} already exists (race condition)`);
                    } else {
                      console.log(`Could not add reaction ${reaction}: ${e.message}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.error('Slack notification error:', error);
              // Don't fail the workflow for Slack errors
            }

  # Update PR status with review and QA information
  update-pr-status:
    name: Update PR Status
    needs: [label-qa-end, qa, secret-scanning, slack-notify-qa-end]
    if: |
      always() &&
      !endsWith(github.event.pull_request.user.login, '[bot]') &&
      (github.event.action == 'synchronize' || github.event.action == 'opened' ||
       github.event.action == 'ready_for_review' || github.event.action == 'converted_to_draft' ||
       github.event.action == 'submitted' || github.event.action == 'dismissed')
    runs-on: namespace-profile-atk-services
    steps:
      - name: Get PR reviews
        id: check_approval
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = ${{ github.event.pull_request.number }};

            // Get reviews
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number
            });

            // Check if PR has approval (excluding the PR author)
            const pr_author = `${{ github.event.pull_request.user.login }}`;
            const has_approval = reviews.data.some(review =>
              review.state === 'APPROVED' &&
              review.user.login !== pr_author
            );

            core.setOutput('has_approval', has_approval);

      - name: Determine QA status
        id: qa_status
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = ${{ github.event.pull_request.number }};

            // For review events, we need to check labels since qa job doesn't run
            if ('${{ github.event_name }}' === 'pull_request_review') {
              // Get current labels
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr_number
              });

              const labels = pr.labels.map(l => l.name);
              let qa_status = '';

              if (labels.includes('qa:success')) {
                qa_status = 'success';
              } else if (labels.includes('qa:failed')) {
                qa_status = 'failed';
              } else if (labels.includes('qa:running')) {
                qa_status = 'running';
              } else if (labels.includes('qa:pending')) {
                qa_status = 'pending';
              }

              core.setOutput('qa_status', qa_status);
            } else {
              // For PR events, use the job results
              if ('${{ needs.qa.result }}' === 'success' && '${{ needs.secret-scanning.result }}' === 'success') {
                core.setOutput('qa_status', 'success');
              } else {
                core.setOutput('qa_status', 'failed');
              }
            }
    outputs:
      has_approval: ${{ steps.check_approval.outputs.has_approval }}
      qa_status: ${{ steps.qa_status.outputs.qa_status }}

  # Apply final PR status label
  label-pr-final-status:
    name: Label PR Final Status
    needs: [update-pr-status]
    if: |
      always() &&
      (github.event_name == 'pull_request' || github.event_name == 'pull_request_review') &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    uses: ./.github/workflows/reusable-pr-status-labeler.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      is_draft: ${{ github.event.pull_request.draft }}
      has_approval: ${{ needs.update-pr-status.outputs.has_approval == 'true' }}
      qa_status: ${{ needs.update-pr-status.outputs.qa_status }}
      runs-on: namespace-profile-atk-services

  # Send Slack notification for final PR status
  slack-notify-final-status:
    name: Slack Notify - Final Status
    needs: [label-pr-final-status, update-pr-status]
    if: |
      always() &&
      needs.label-pr-final-status.result == 'success' &&
      (github.event_name == 'pull_request' || github.event_name == 'pull_request_review') &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    runs-on: namespace-profile-atk-services
    steps:
      - name: Setup 1Password
        uses: 1password/load-secrets-action/configure@v2
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load secrets
        uses: 1password/load-secrets-action@v2
        env:
          SLACK_BOT_TOKEN: op://platform/slack-bot/SLACK_BOT_TOKEN
          SLACK_CHANNEL_ID: op://platform/slack-bot/SLACK_CHANNEL_ID

      - name: Wait for labels to be applied
        run: sleep 2

      - name: Get PR labels and send Slack notification
        uses: actions/github-script@v7
        env:
          SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ env.SLACK_CHANNEL_ID }}
        with:
          script: |
            // Get PR labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.pull_request.number }}
            });
            
            const labels = pr.labels || [];
            const pr_title = ${{ toJSON(github.event.pull_request.title) }};
            const pr_url = ${{ toJSON(github.event.pull_request.html_url) }};
            const pr_number = ${{ github.event.pull_request.number }};
            
            // Extract repo name without org
            const repoName = context.repo.repo;

            // Check if PR is draft
            const isDraft = Array.isArray(labels) && labels.some(label => label.name === 'status:draft');
            if (isDraft) {
              console.log('Skipping notification for draft PR');
              return;
            }

            // Define status reactions mapping
            const statusReactions = {
              'qa:pending': 'hourglass_flowing_sand',
              'qa:running': 'runner',
              'qa:success': 'white_check_mark',
              'qa:failed': 'x',
              'status:ready-for-review': 'eyes',
              'status:approved': 'thumbsup',
              'status:mergeable': 'rocket',
              'status:merged': 'tada'
            };
            
            // Define mutually exclusive groups (only one can be active at a time)
            const exclusiveGroups = {
              'qa': ['hourglass_flowing_sand', 'runner', 'white_check_mark', 'x'],
              'status': ['eyes', 'thumbsup', 'rocket', 'tada']
            };
            
            // All possible status reactions we manage
            const allStatusReactions = Object.values(statusReactions);

            // Get current status labels
            console.log('Current PR labels:', labels.map(l => l.name));
            const currentStatuses = labels
              .filter(label => Object.keys(statusReactions).includes(label.name))
              .map(label => statusReactions[label.name]);
            console.log('Reactions to add:', currentStatuses);

            // Check if there's an existing Slack message
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            console.log(`Found ${comments.length} comments on PR`);
            const slackComment = comments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
            let slackTs = null;

            if (slackComment) {
              const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
              if (match) {
                slackTs = match[1];
                console.log(`Found existing Slack message timestamp: ${slackTs}`);
              }
            } else {
              console.log('No existing Slack message found');
            }

            // Helper function to make Slack API calls
            async function slackAPI(method, body = {}) {
              const response = await fetch(`https://slack.com/api/${method}`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
              });

              const data = await response.json();
              if (!data.ok) {
                throw new Error(`Slack API error: ${data.error}`);
              }
              return data;
            }

            try {
              if (!slackTs) {
                // Send new message
                // Get PR author info
                const pr_author = `${{ github.event.pull_request.user.login }}`;
                const author_avatar = `${{ github.event.pull_request.user.avatar_url }}`;
                
                const result = await slackAPI('chat.postMessage', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  text: `PR #${pr_number}: ${pr_title}`,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: `PR #${pr_number}`,
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*${pr_title}*`
                      }
                    },
                    {
                      type: 'context',
                      elements: [
                        {
                          type: 'image',
                          image_url: author_avatar,
                          alt_text: pr_author
                        },
                        {
                          type: 'mrkdwn',
                          text: `*Author:* ${pr_author} â€¢ *Repository:* ${repoName}`
                        }
                      ]
                    },
                    {
                      type: 'divider'
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'ðŸ‘€ View PR',
                            emoji: true
                          },
                          url: pr_url,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                });

                // Store timestamp
                if (result.ts) {
                  console.log(`Storing Slack timestamp ${result.ts} as PR comment`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr_number,
                    body: `<!-- slack-ts:${result.ts} -->`
                  });
                  slackTs = result.ts;
                  console.log('Successfully stored Slack timestamp');
                }
              }

              if (slackTs) {
                // Get existing reactions
                let existingReactions = [];
                try {
                  const reactions = await slackAPI('reactions.get', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    full: true
                  });
                  
                  if (reactions.message && reactions.message.reactions) {
                    existingReactions = reactions.message.reactions.map(r => r.name);
                    console.log('Existing reactions on message:', existingReactions);
                  }

                  // Smart reaction management to avoid flickering
                  // First, determine what needs to change
                  const reactionsToAdd = [];
                  const reactionsToRemove = [];
                  
                  // For each desired reaction, check if we need to add it
                  for (const desiredReaction of currentStatuses) {
                    if (!existingReactions.includes(desiredReaction)) {
                      reactionsToAdd.push(desiredReaction);
                    }
                  }
                  
                  // For each exclusive group, find reactions that need to be removed
                  for (const desiredReaction of currentStatuses) {
                    for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
                      if (groupReactions.includes(desiredReaction)) {
                        // Remove other reactions in this group that currently exist
                        for (const groupReaction of groupReactions) {
                          if (groupReaction !== desiredReaction && existingReactions.includes(groupReaction)) {
                            reactionsToRemove.push(groupReaction);
                          }
                        }
                      }
                    }
                  }
                  
                  console.log('Reactions to remove:', reactionsToRemove);
                  console.log('Reactions to add:', reactionsToAdd);
                  
                  // Remove outdated reactions first
                  for (const reactionName of reactionsToRemove) {
                    try {
                      console.log(`Removing outdated reaction: ${reactionName}`);
                      await slackAPI('reactions.remove', {
                        channel: process.env.SLACK_CHANNEL_ID,
                        timestamp: slackTs,
                        name: reactionName
                      });
                      // Small delay to avoid rate limits
                      await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (e) {
                      if (e.message.includes('missing_scope')) {
                        console.error(`ERROR: Slack bot missing permission to remove reactions. Please add 'reactions:write' scope to the Slack app.`);
                        break;
                      } else if (e.message.includes('no_reaction')) {
                        console.log(`Reaction ${reactionName} was already removed`);
                      } else {
                        console.log(`Could not remove reaction ${reactionName}: ${e.message}`);
                      }
                    }
                  }
                } catch (e) {
                  console.log('Could not get existing reactions:', e.message);
                  // Continue anyway - we'll handle errors when adding/removing
                }

                // Add new reactions
                for (const reaction of reactionsToAdd) {
                  try {
                    console.log(`Adding reaction: ${reaction}`);
                    await slackAPI('reactions.add', {
                      channel: process.env.SLACK_CHANNEL_ID,
                      timestamp: slackTs,
                      name: reaction
                    });
                    console.log(`Successfully added reaction: ${reaction}`);
                    // Small delay to avoid rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                  } catch (e) {
                    if (e.message.includes('missing_scope')) {
                      console.error(`ERROR: Slack bot missing permission to add reactions. Please add 'reactions:write' scope to the Slack app.`);
                      break;
                    } else if (e.message.includes('already_reacted')) {
                      console.log(`Reaction ${reaction} already exists (race condition)`);
                    } else {
                      console.log(`Could not add reaction ${reaction}: ${e.message}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.error('Slack notification error:', error);
              // Don't fail the workflow for Slack errors
            }

  # Handle PR closed/merged
  label-pr-closed:
    name: Label PR Closed
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    uses: ./.github/workflows/reusable-pr-status-labeler.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      is_draft: ${{ github.event.pull_request.draft || false }}
      is_merged: ${{ github.event.pull_request.merged || false }}
      runs-on: namespace-profile-atk-services

  # Send Slack notification for PR closed/merged
  slack-notify-pr-closed:
    name: Slack Notify - PR Closed
    needs: [label-pr-closed]
    if: |
      always() &&
      needs.label-pr-closed.result == 'success' &&
      github.event.action == 'closed' &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    runs-on: namespace-profile-atk-services
    steps:
      - name: Setup 1Password
        uses: 1password/load-secrets-action/configure@v2
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Load secrets
        uses: 1password/load-secrets-action@v2
        env:
          SLACK_BOT_TOKEN: op://platform/slack-bot/SLACK_BOT_TOKEN
          SLACK_CHANNEL_ID: op://platform/slack-bot/SLACK_CHANNEL_ID

      - name: Wait for labels to be applied
        run: sleep 2

      - name: Get PR labels and send Slack notification
        uses: actions/github-script@v7
        env:
          SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ env.SLACK_CHANNEL_ID }}
        with:
          script: |
            // Get PR labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.pull_request.number }}
            });
            
            const labels = pr.labels || [];
            const pr_title = ${{ toJSON(github.event.pull_request.title) }};
            const pr_url = ${{ toJSON(github.event.pull_request.html_url) }};
            const pr_number = ${{ github.event.pull_request.number }};
            
            // Extract repo name without org
            const repoName = context.repo.repo;

            // Check if PR is draft
            const isDraft = Array.isArray(labels) && labels.some(label => label.name === 'status:draft');
            if (isDraft) {
              console.log('Skipping notification for draft PR');
              return;
            }

            // Define status reactions mapping
            const statusReactions = {
              'qa:pending': 'hourglass_flowing_sand',
              'qa:running': 'runner',
              'qa:success': 'white_check_mark',
              'qa:failed': 'x',
              'status:ready-for-review': 'eyes',
              'status:approved': 'thumbsup',
              'status:mergeable': 'rocket',
              'status:merged': 'tada'
            };
            
            // Define mutually exclusive groups (only one can be active at a time)
            const exclusiveGroups = {
              'qa': ['hourglass_flowing_sand', 'runner', 'white_check_mark', 'x'],
              'status': ['eyes', 'thumbsup', 'rocket', 'tada']
            };
            
            // All possible status reactions we manage
            const allStatusReactions = Object.values(statusReactions);

            // Get current status labels
            console.log('Current PR labels:', labels.map(l => l.name));
            const currentStatuses = labels
              .filter(label => Object.keys(statusReactions).includes(label.name))
              .map(label => statusReactions[label.name]);
            console.log('Reactions to add:', currentStatuses);

            // Check if there's an existing Slack message
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number
            });

            console.log(`Found ${comments.length} comments on PR`);
            const slackComment = comments.find(c => c.body && c.body.includes('<!-- slack-ts:'));
            let slackTs = null;

            if (slackComment) {
              const match = slackComment.body.match(/<!-- slack-ts:([0-9.]+) -->/);
              if (match) {
                slackTs = match[1];
                console.log(`Found existing Slack message timestamp: ${slackTs}`);
              }
            } else {
              console.log('No existing Slack message found');
            }

            // Helper function to make Slack API calls
            async function slackAPI(method, body = {}) {
              const response = await fetch(`https://slack.com/api/${method}`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
              });

              const data = await response.json();
              if (!data.ok) {
                throw new Error(`Slack API error: ${data.error}`);
              }
              return data;
            }

            try {
              if (!slackTs) {
                // Send new message
                // Get PR author info
                const pr_author = `${{ github.event.pull_request.user.login }}`;
                const author_avatar = `${{ github.event.pull_request.user.avatar_url }}`;
                
                const result = await slackAPI('chat.postMessage', {
                  channel: process.env.SLACK_CHANNEL_ID,
                  text: `PR #${pr_number}: ${pr_title}`,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: `PR #${pr_number}`,
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*${pr_title}*`
                      }
                    },
                    {
                      type: 'context',
                      elements: [
                        {
                          type: 'image',
                          image_url: author_avatar,
                          alt_text: pr_author
                        },
                        {
                          type: 'mrkdwn',
                          text: `*Author:* ${pr_author} â€¢ *Repository:* ${repoName}`
                        }
                      ]
                    },
                    {
                      type: 'divider'
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'ðŸ‘€ View PR',
                            emoji: true
                          },
                          url: pr_url,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                });

                // Store timestamp
                if (result.ts) {
                  console.log(`Storing Slack timestamp ${result.ts} as PR comment`);
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr_number,
                    body: `<!-- slack-ts:${result.ts} -->`
                  });
                  slackTs = result.ts;
                  console.log('Successfully stored Slack timestamp');
                }
              }

              if (slackTs) {
                // Get existing reactions
                let existingReactions = [];
                try {
                  const reactions = await slackAPI('reactions.get', {
                    channel: process.env.SLACK_CHANNEL_ID,
                    timestamp: slackTs,
                    full: true
                  });
                  
                  if (reactions.message && reactions.message.reactions) {
                    existingReactions = reactions.message.reactions.map(r => r.name);
                    console.log('Existing reactions on message:', existingReactions);
                  }

                  // Smart reaction management to avoid flickering
                  // First, determine what needs to change
                  const reactionsToAdd = [];
                  const reactionsToRemove = [];
                  
                  // For each desired reaction, check if we need to add it
                  for (const desiredReaction of currentStatuses) {
                    if (!existingReactions.includes(desiredReaction)) {
                      reactionsToAdd.push(desiredReaction);
                    }
                  }
                  
                  // For each exclusive group, find reactions that need to be removed
                  for (const desiredReaction of currentStatuses) {
                    for (const [groupName, groupReactions] of Object.entries(exclusiveGroups)) {
                      if (groupReactions.includes(desiredReaction)) {
                        // Remove other reactions in this group that currently exist
                        for (const groupReaction of groupReactions) {
                          if (groupReaction !== desiredReaction && existingReactions.includes(groupReaction)) {
                            reactionsToRemove.push(groupReaction);
                          }
                        }
                      }
                    }
                  }
                  
                  console.log('Reactions to remove:', reactionsToRemove);
                  console.log('Reactions to add:', reactionsToAdd);
                  
                  // Remove outdated reactions first
                  for (const reactionName of reactionsToRemove) {
                    try {
                      console.log(`Removing outdated reaction: ${reactionName}`);
                      await slackAPI('reactions.remove', {
                        channel: process.env.SLACK_CHANNEL_ID,
                        timestamp: slackTs,
                        name: reactionName
                      });
                      // Small delay to avoid rate limits
                      await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (e) {
                      if (e.message.includes('missing_scope')) {
                        console.error(`ERROR: Slack bot missing permission to remove reactions. Please add 'reactions:write' scope to the Slack app.`);
                        break;
                      } else if (e.message.includes('no_reaction')) {
                        console.log(`Reaction ${reactionName} was already removed`);
                      } else {
                        console.log(`Could not remove reaction ${reactionName}: ${e.message}`);
                      }
                    }
                  }
                } catch (e) {
                  console.log('Could not get existing reactions:', e.message);
                  // Continue anyway - we'll handle errors when adding/removing
                }

                // Add new reactions
                for (const reaction of reactionsToAdd) {
                  try {
                    console.log(`Adding reaction: ${reaction}`);
                    await slackAPI('reactions.add', {
                      channel: process.env.SLACK_CHANNEL_ID,
                      timestamp: slackTs,
                      name: reaction
                    });
                    console.log(`Successfully added reaction: ${reaction}`);
                    // Small delay to avoid rate limits
                    await new Promise(resolve => setTimeout(resolve, 100));
                  } catch (e) {
                    if (e.message.includes('missing_scope')) {
                      console.error(`ERROR: Slack bot missing permission to add reactions. Please add 'reactions:write' scope to the Slack app.`);
                      break;
                    } else if (e.message.includes('already_reacted')) {
                      console.log(`Reaction ${reaction} already exists (race condition)`);
                    } else {
                      console.log(`Could not add reaction ${reaction}: ${e.message}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.error('Slack notification error:', error);
              // Don't fail the workflow for Slack errors
            }

  # Manage auto-merge based on PR state
  manage-auto-merge:
    name: Manage Auto-Merge
    needs: [update-pr-status, label-pr-final-status, slack-notify-final-status]
    if: |
      always() &&
      (github.event_name == 'pull_request' || github.event_name == 'pull_request_review') &&
      !endsWith(github.event.pull_request.user.login, '[bot]')
    runs-on: namespace-profile-atk-services
    steps:
      - name: Manage auto-merge for PR
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = ${{ github.event.pull_request.number }};
            const has_approval = '${{ needs.update-pr-status.outputs.has_approval }}' === 'true';
            const qa_status = '${{ needs.update-pr-status.outputs.qa_status }}';
            const is_draft = ${{ github.event.pull_request.draft }};

            // Check if PR is mergeable
            const is_mergeable = has_approval && qa_status === 'success' && !is_draft;

            try {
              if (is_mergeable) {
                // Enable auto-merge
                await github.rest.pulls.enableAutoMerge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr_number,
                  merge_method: 'squash'
                });
                console.log(`Auto-merge enabled for PR #${pr_number}`);
              } else {
                // Disable auto-merge if it was enabled
                await github.rest.pulls.disableAutoMerge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr_number
                });
                console.log(`Auto-merge disabled for PR #${pr_number} - no longer mergeable`);
              }
            } catch (error) {
              if (error.message.includes('Auto-merge is not enabled')) {
                console.log('Auto-merge is already disabled');
              } else if (error.message.includes('already enabled')) {
                console.log('Auto-merge is already enabled');
              } else if (error.message.includes('Auto-merge is not allowed')) {
                console.log('Auto-merge is not allowed for this repository. Please enable it in repository settings.');
              } else {
                console.log(`Error managing auto-merge: ${error.message}`);
              }
            }
