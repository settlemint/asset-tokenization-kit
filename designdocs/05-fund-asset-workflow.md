# Fund Asset Workflow & Implementation

## üí∞ Fund Overview

Fund tokens in the Asset Tokenization Kit represent shares in managed investment vehicles with built-in fee collection mechanisms. They combine equity-like governance features with automated management fee accrual and distribution systems.

## üìã Fund Contract Structure

```mermaid
classDiagram
    class ATKFundImplementation {
        +uint16 managementFeeBps
        +uint256 lastFeeCollection
        +mapping feeAccrued
        
        +collectManagementFee()
        +calculateAccruedFees()
        +updateFeeCalculation()
    }
    
    class SMARTUpgradeable {
        +transfer()
        +mint()
        +burn()
        +compliance checks
    }
    
    class IVotes {
        +delegate()
        +getVotes()
        +getPastVotes()
        +delegateBySig()
    }
    
    class ERC20VotesUpgradeable {
        +_moveVotingPower()
        +_writeCheckpoint()
        +clock()
        +CLOCK_MODE()
    }
    
    ATKFundImplementation --|> SMARTUpgradeable
    ATKFundImplementation --|> IVotes
    ATKFundImplementation --|> ERC20VotesUpgradeable
    
    style ATKFundImplementation fill:#bbdefb,stroke:#1976d2,stroke-width:3px
    style SMARTUpgradeable fill:#e3f2fd,stroke:#1565c0
    style IVotes fill:#fff3e0,stroke:#ef6c00,color:#000000,color:#000000
    style ERC20VotesUpgradeable fill:#f3e5f5,stroke:#7b1fa2
```

## üöÄ Fund Creation Workflow

```mermaid
sequenceDiagram
    participant M as üè¢ Fund Manager
    participant F as üè≠ FundFactory
    participant T as üí∞ Fund Token
    participant A as üíº Asset Pool
    participant S as üìä Subgraph
    
    M->>F: üöÄ Create Fund Request
    Note over F: Set management fee BPS
    
    F->>T: üìã Deploy Fund Contract
    T->>T: üîß Initialize Fee System
    Note over T: Set fee rate, voting
    
    F->>S: üì° Emit FundCreated Event
    S->>S: üìä Index New Fund
    
    M->>A: üí∞ Deposit Initial Assets
    A->>T: üìä Calculate Share Value
    
    M->>T: üíé Mint Initial Shares
    T->>T: ‚úÖ Start Fee Accrual
    T->>T: üìä Initialize Voting Power
    
    T->>S: üì° Emit MintCompleted
    S->>S: üìä Update Fund Statistics
    
    Note over T: üí∞ Fund Ready for Investment
```

## üè≠ Fund Factory Implementation

### Factory Contract Features
- **üí∞ Fee Configuration**: Customizable management fee rates
- **üó≥Ô∏è Governance Setup**: Shareholder voting mechanisms
- **üìä Performance Tracking**: NAV calculation systems
- **‚öñÔ∏è Compliance Integration**: Investment fund regulations

```solidity
contract ATKFundFactoryImplementation {
    event FundCreated(
        indexed address creator,
        indexed address fundProxy,
        indexed address accessManager,
        string name,
        string symbol,
        uint8 decimals,
        uint16 managementFeeBps,
        uint16 performanceFeeBps
    );
    
    function createFund(
        string calldata name,
        string calldata symbol,
        uint8 decimals,
        uint16 managementFeeBps,
        SMARTComplianceModuleParamPair[] calldata initialModulePairs
    ) external returns (address fundProxy) {
        // Validate fee parameters
        require(managementFeeBps <= 1000, "Management fee too high"); // Max 10%
        
        // Deploy minimal proxy
        fundProxy = Clones.clone(_fundImplementation);
        
        // Initialize fund with fee parameters
        IATKFund(fundProxy).initialize(
            name, symbol, decimals, managementFeeBps,
            initialModulePairs,
            _identityRegistry, _compliance, accessManager
        );
        
        // Emit creation event
        emit FundCreated(/*...parameters...*/);
        
        return fundProxy;
    }
}
```

## üí∞ Management Fee System

### Fee Accrual Mechanism

```mermaid
flowchart TD
    A[‚è∞ Time Passage] -->|üìä Calculate| B[üí∞ Accrued Fees]
    B -->|üîç Check| C{üëë Manager Action?}
    C -->|‚úÖ Collect| D[üíé Mint Fee Shares]
    C -->|‚ùå Wait| E[üìà Continue Accrual]
    
    D -->|üìä Update| F[üîÑ Reset Fee Timer]
    D -->|üì° Emit| G[üìã Fee Collection Event]
    D -->|üìä Dilute| H[üë• Existing Shareholders]
    
    E --> A
    F --> A
    
    subgraph "üí∞ Fee Calculation"
        I[üìä Total Supply]
        J[‚è∞ Time Period]
        K[üìà Fee Rate BPS]
        L[üßÆ Fee Formula]
    end
    
    B --> I
    I --> L
    J --> L
    K --> L
    
    style A fill:#fff3e0,stroke:#ef6c00,color:#000000,color:#000000
    style D fill:#c8e6c9,stroke:#388e3c
    style H fill:#ffcdd2,stroke:#d32f2f
    style L fill:#e3f2fd,stroke:#1565c0
```

### Fee Collection Implementation

```solidity
contract ATKFundImplementation {
    uint16 private _managementFeeBps;
    uint256 private _lastFeeCollection;
    
    event ManagementFeeCollected(
        address indexed sender,
        uint256 indexed amount,
        uint256 indexed timestamp
    );
    
    function collectManagementFee() external returns (uint256) {
        require(hasRole(FUNDS_MANAGER_ROLE, _msgSender()), "Unauthorized");
        
        uint256 feeAmount = _calculateAccruedFees();
        require(feeAmount > 0, "No fees to collect");
        
        // Mint fee shares to fund manager
        _mint(_msgSender(), feeAmount);
        
        // Update last collection timestamp
        _lastFeeCollection = block.timestamp;
        
        emit ManagementFeeCollected(_msgSender(), feeAmount, block.timestamp);
        
        return feeAmount;
    }
    
    function _calculateAccruedFees() internal view returns (uint256) {
        if (_lastFeeCollection == 0) return 0;
        
        uint256 timeElapsed = block.timestamp - _lastFeeCollection;
        uint256 annualFeeRate = _managementFeeBps; // BPS
        uint256 currentSupply = totalSupply();
        
        // Calculate annual fee amount
        uint256 annualFeeAmount = (currentSupply * annualFeeRate) / 10000;
        
        // Pro-rate for time elapsed (assuming 365.25 days per year)
        uint256 feeAmount = (annualFeeAmount * timeElapsed) / (365.25 days);
        
        return feeAmount;
    }
    
    function managementFeeBps() external view returns (uint16) {
        return _managementFeeBps;
    }
}
```

## üìä Fund Lifecycle Management

### Investment Flow

```mermaid
sequenceDiagram
    participant I as üë§ Investor
    participant T as üí∞ Fund Token
    participant P as üíº Asset Pool
    participant M as üè¢ Fund Manager
    participant V as üìä Valuation
    
    I->>T: üí∞ Investment Request
    T->>V: üìä Get Current NAV
    V-->>T: üí∞ Share Price
    
    T->>T: üîç Compliance Check
    T->>T: üßÆ Calculate Shares
    
    I->>P: üí≥ Transfer Assets
    P->>T: ‚úÖ Confirm Receipt
    
    T->>T: üíé Mint Shares
    T->>T: üìä Update Voting Power
    
    M->>T: üìà Accrue Management Fees
    T->>T: ‚è∞ Update Fee Timer
    
    T->>I: üìã Issue Share Certificate
    
    Note over T: üìä Fund AUM Increased
```

### Redemption Process

```mermaid
stateDiagram-v2
    [*] --> RedemptionRequest: üí∏ Investor Request
    RedemptionRequest --> ComplianceCheck: üîç Verify Eligibility
    
    ComplianceCheck --> Approved: ‚úÖ Compliant
    ComplianceCheck --> Rejected: ‚ùå Non-compliant
    
    Approved --> NAVCalculation: üìä Get Current NAV
    NAVCalculation --> ShareValuation: üí∞ Calculate Value
    
    ShareValuation --> LiquidityCheck: üíß Check Fund Liquidity
    LiquidityCheck --> SufficientLiquidity: ‚úÖ Liquid
    LiquidityCheck --> InsufficientLiquidity: ‚ùå Illiquid
    
    SufficientLiquidity --> ShareBurn: üî• Burn Shares
    ShareBurn --> AssetTransfer: üí∏ Transfer Assets
    AssetTransfer --> Complete: ‚úÖ Redemption Complete
    
    InsufficientLiquidity --> QueueRedemption: üìã Queue Request
    QueueRedemption --> WaitLiquidity: ‚è∞ Wait for Liquidity
    WaitLiquidity --> SufficientLiquidity: üíß Liquidity Available
    
    Rejected --> [*]: üö´ Request Denied
    Complete --> [*]: üèÅ Process Complete
```

## üó≥Ô∏è Fund Governance

### Shareholder Voting Rights

```mermaid
flowchart LR
    subgraph "üí∞ Investment Decisions"
        A[üéØ Asset Allocation]
        B[üìä Strategy Changes]
        C[üíº Manager Selection]
    end
    
    subgraph "üí∞ Fee Decisions"
        D[üìà Fee Rate Changes]
        E[üí∞ Performance Fees]
        F[üí∏ Expense Ratios]
    end
    
    subgraph "üèõÔ∏è Governance Actions"
        G[üìã Fund Dissolution]
        H[ü§ù Merger Approval]
        I[üìú Bylaw Changes]
    end
    
    A --> D
    B --> E
    C --> F
    D --> G
    E --> H
    F --> I
    
    style A fill:#c8e6c9,stroke:#388e3c
    style D fill:#bbdefb,stroke:#1976d2
    style G fill:#ffcdd2,stroke:#d32f2f
```

### Voting Implementation

```solidity
contract ATKFundImplementation {
    struct Proposal {
        uint256 id;
        string description;
        uint256 forVotes;
        uint256 againstVotes;
        uint256 startBlock;
        uint256 endBlock;
        bool executed;
        mapping(address => bool) hasVoted;
    }
    
    mapping(uint256 => Proposal) public proposals;
    uint256 public nextProposalId;
    
    function createProposal(
        string calldata description,
        uint256 votingPeriod
    ) external returns (uint256) {
        require(
            getVotes(_msgSender()) >= proposalThreshold(),
            "Insufficient voting power"
        );
        
        uint256 proposalId = nextProposalId++;
        Proposal storage proposal = proposals[proposalId];
        
        proposal.id = proposalId;
        proposal.description = description;
        proposal.startBlock = block.number;
        proposal.endBlock = block.number + votingPeriod;
        
        emit ProposalCreated(proposalId, _msgSender(), description);
        
        return proposalId;
    }
    
    function castVote(
        uint256 proposalId,
        bool support
    ) external {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.hasVoted[_msgSender()], "Already voted");
        require(block.number <= proposal.endBlock, "Voting ended");
        
        uint256 weight = getPastVotes(_msgSender(), proposal.startBlock);
        require(weight > 0, "No voting power");
        
        proposal.hasVoted[_msgSender()] = true;
        
        if (support) {
            proposal.forVotes += weight;
        } else {
            proposal.againstVotes += weight;
        }
        
        emit VoteCast(_msgSender(), proposalId, support, weight);
    }
}
```

## üìà Performance Tracking

### NAV Calculation

```mermaid
flowchart TD
    A[üíº Total Assets] -->|‚ûï Add| B[üßÆ Gross Asset Value]
    C[üí∏ Total Liabilities] -->|‚ûñ Subtract| B
    B --> D[üí∞ Net Asset Value]
    
    E[üìä Outstanding Shares] -->|‚ûó Divide| F[üí∞ NAV Per Share]
    D --> F
    
    subgraph "üíº Asset Components"
        G[üí∞ Cash Holdings]
        H[üìà Securities]
        I[üè¢ Real Estate]
        J[üíé Alternative Assets]
    end
    
    subgraph "üí∏ Liability Components"
        K[üí∞ Management Fees]
        L[üìã Operating Expenses]
        M[üí∏ Redemption Queue]
    end
    
    G --> A
    H --> A
    I --> A
    J --> A
    
    K --> C
    L --> C
    M --> C
    
    style D fill:#c8e6c9,stroke:#388e3c
    style F fill:#bbdefb,stroke:#1976d2
    style A fill:#fff9c4,stroke:#f57f17,color:#000000,color:#000000
    style C fill:#ffcdd2,stroke:#d32f2f
```

### Performance Metrics

```solidity
contract FundPerformanceTracker {
    struct PerformanceData {
        uint256 timestamp;
        uint256 navPerShare;
        uint256 totalAssets;
        uint256 totalShares;
    }
    
    PerformanceData[] public performanceHistory;
    
    function recordPerformance(
        uint256 navPerShare,
        uint256 totalAssets
    ) external onlyRole(FUNDS_MANAGER_ROLE) {
        performanceHistory.push(PerformanceData({
            timestamp: block.timestamp,
            navPerShare: navPerShare,
            totalAssets: totalAssets,
            totalShares: totalSupply()
        }));
        
        emit PerformanceRecorded(navPerShare, totalAssets, block.timestamp);
    }
    
    function getPerformanceReturn(
        uint256 fromTimestamp,
        uint256 toTimestamp
    ) external view returns (int256) {
        uint256 startNAV = _getNAVAtTimestamp(fromTimestamp);
        uint256 endNAV = _getNAVAtTimestamp(toTimestamp);
        
        if (startNAV == 0) return 0;
        
        return int256((endNAV - startNAV) * 10000 / startNAV); // BPS
    }
}
```

## üîß API Integration

### Frontend Integration Points

```typescript
// Fund management data
interface FundData {
  name: string;
  symbol: string;
  totalSupply: bigint;
  managementFeeBps: number;
  navPerShare: bigint;
  totalAssets: bigint;
  lastFeeCollection: Date;
  accruedFees: bigint;
}

// Investment actions
interface FundActions {
  invest: (amount: bigint) => Promise<Hash>;
  redeem: (shares: bigint) => Promise<Hash>;
  collectFees: () => Promise<Hash>;
  recordNAV: (navPerShare: bigint) => Promise<Hash>;
}

// Performance tracking
interface PerformanceMetrics {
  returns: {
    period: string;
    return: number;
  }[];
  volatility: number;
  sharpeRatio: number;
  maxDrawdown: number;
}
```

### GraphQL Queries

```graphql
query FundDetails($fundAddress: Bytes!) {
  token(id: $fundAddress) {
    name
    symbol
    totalSupply
    fund {
      managementFeeBps
    }
    balances(first: 100, orderBy: value, orderDirection: desc) {
      account {
        id
      }
      value
    }
    stats {
      totalValueInBaseCurrency
      balancesCount
    }
  }
  
  # Recent fee collections
  events(
    where: {
      emitter: $fundAddress,
      eventName: "ManagementFeeCollected"
    }
    orderBy: blockTimestamp
    orderDirection: desc
    first: 10
  ) {
    blockTimestamp
    values {
      name
      value
    }
  }
}

query FundPerformance($fundAddress: Bytes!, $fromDate: BigInt!) {
  performanceData: events(
    where: {
      emitter: $fundAddress,
      eventName: "PerformanceRecorded",
      blockTimestamp_gte: $fromDate
    }
    orderBy: blockTimestamp
  ) {
    blockTimestamp
    values {
      name
      value
    }
  }
}
```

## üéØ Use Cases & Applications

### Mutual Funds
- **üìä Diversified Portfolios**: Multi-asset investment strategies
- **üí∞ Professional Management**: Expert fund management
- **üìà Performance Tracking**: Transparent return reporting
- **üí∏ Easy Liquidity**: Daily redemption capabilities

### Hedge Funds
- **üéØ Alternative Strategies**: Complex investment approaches
- **üí∞ Performance Fees**: Incentive-based compensation
- **üîí Accredited Investors**: Sophisticated investor base
- **üìä Risk Management**: Advanced hedging techniques

### Index Funds
- **üìä Passive Management**: Market index tracking
- **üí∞ Low Fees**: Minimal management costs
- **üìà Broad Exposure**: Market-wide diversification
- **ü§ñ Automated Rebalancing**: Algorithm-driven allocation

### Private Equity
- **üè¢ Company Investments**: Direct business ownership
- **‚è∞ Long-term Holds**: Multi-year investment horizons
- **üí∞ Value Creation**: Active portfolio management
- **üìä Carried Interest**: Performance-based returns

### Real Estate Funds
- **üè¢ Property Portfolios**: Diversified real estate holdings
- **üí∞ Rental Income**: Regular distribution payments
- **üìä Property Management**: Professional asset management
- **üèóÔ∏è Development Projects**: New construction investments

## üîí Security & Compliance

### Regulatory Compliance
- **üìã Investment Company Act**: Mutual fund regulations
- **üèõÔ∏è SEC Registration**: Securities law compliance
- **üë• Investor Accreditation**: Qualified investor verification
- **üìä Reporting Requirements**: Regular disclosure obligations

### Operational Security
- **üí∞ Asset Custody**: Secure fund asset storage
- **üîê Multi-sig Controls**: Manager authorization requirements
- **üìä NAV Validation**: Independent price verification
- **üîç Audit Trail**: Complete transaction history

### Risk Management
- **üìä Concentration Limits**: Portfolio diversification rules
- **üíß Liquidity Management**: Redemption capacity monitoring
- **‚öñÔ∏è Compliance Monitoring**: Real-time rule enforcement
- **üö® Emergency Controls**: Circuit breaker mechanisms

This comprehensive fund workflow enables sophisticated investment vehicle management with automated fee collection, governance capabilities, and regulatory compliance for tokenized investment funds.
