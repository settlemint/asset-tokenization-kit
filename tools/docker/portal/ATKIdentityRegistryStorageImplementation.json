{
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "trustedForwarder",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "DEFAULT_ADMIN_ROLE",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "addIdentityToStorage",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_identity",
          "type": "address",
          "internalType": "contract IIdentity"
        },
        {
          "name": "_country",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "bindIdentityRegistry",
      "inputs": [
        {
          "name": "_identityRegistry",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "getIdentityWallets",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address[]",
          "internalType": "address[]"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getRecoveredWalletFromStorage",
      "inputs": [
        {
          "name": "lostWallet",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getRoleAdmin",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "grantRole",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "hasRole",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "initialize",
      "inputs": [
        {
          "name": "system",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "initialAdmin",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "isTrustedForwarder",
      "inputs": [
        {
          "name": "forwarder",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "isWalletMarkedAsLost",
      "inputs": [
        {
          "name": "userWallet",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "linkWalletRecovery",
      "inputs": [
        {
          "name": "lostWallet",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "newWallet",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "linkedIdentityRegistries",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address[]",
          "internalType": "address[]"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "markWalletAsLost",
      "inputs": [
        {
          "name": "identityContract",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "userWallet",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "modifyStoredIdentity",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_identity",
          "type": "address",
          "internalType": "contract IIdentity"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "modifyStoredInvestorCountry",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_country",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "removeIdentityFromStorage",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "renounceRole",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "callerConfirmation",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "revokeRole",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "storedIdentity",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IIdentity"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "storedInvestorCountry",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "supportsInterface",
      "inputs": [
        {
          "name": "interfaceId",
          "type": "bytes4",
          "internalType": "bytes4"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "trustedForwarder",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "unbindIdentityRegistry",
      "inputs": [
        {
          "name": "_identityRegistry",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "event",
      "name": "CountryModified",
      "inputs": [
        {
          "name": "_identityWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_country",
          "type": "uint16",
          "indexed": false,
          "internalType": "uint16"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "IdentityModified",
      "inputs": [
        {
          "name": "_oldIdentity",
          "type": "address",
          "indexed": true,
          "internalType": "contract IIdentity"
        },
        {
          "name": "_newIdentity",
          "type": "address",
          "indexed": true,
          "internalType": "contract IIdentity"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "IdentityRegistryBound",
      "inputs": [
        {
          "name": "_identityRegistry",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "IdentityRegistryUnbound",
      "inputs": [
        {
          "name": "_identityRegistry",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "IdentityStored",
      "inputs": [
        {
          "name": "_investorAddress",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_identity",
          "type": "address",
          "indexed": true,
          "internalType": "contract IIdentity"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "IdentityUnstored",
      "inputs": [
        {
          "name": "_investorAddress",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_identity",
          "type": "address",
          "indexed": true,
          "internalType": "contract IIdentity"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "IdentityWalletMarkedAsLost",
      "inputs": [
        {
          "name": "identityContract",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "userWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "markedBy",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Initialized",
      "inputs": [
        {
          "name": "version",
          "type": "uint64",
          "indexed": false,
          "internalType": "uint64"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "RoleAdminChanged",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "indexed": true,
          "internalType": "bytes32"
        },
        {
          "name": "previousAdminRole",
          "type": "bytes32",
          "indexed": true,
          "internalType": "bytes32"
        },
        {
          "name": "newAdminRole",
          "type": "bytes32",
          "indexed": true,
          "internalType": "bytes32"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "RoleGranted",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "indexed": true,
          "internalType": "bytes32"
        },
        {
          "name": "account",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "RoleRevoked",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "indexed": true,
          "internalType": "bytes32"
        },
        {
          "name": "account",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "WalletRecoveryLinked",
      "inputs": [
        {
          "name": "lostWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "newWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "establishedBy",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "AccessControlBadConfirmation",
      "inputs": []
    },
    {
      "type": "error",
      "name": "AccessControlUnauthorizedAccount",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "neededRole",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ]
    },
    {
      "type": "error",
      "name": "IdentityAlreadyExists",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "IdentityDoesNotExist",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "IdentityRegistryAlreadyBound",
      "inputs": [
        {
          "name": "registryAddress",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "IdentityRegistryNotBound",
      "inputs": [
        {
          "name": "registryAddress",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "InvalidIdentityAddress",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidIdentityRegistryAddress",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidIdentityWalletAddress",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidInitialization",
      "inputs": []
    },
    {
      "type": "error",
      "name": "NotInitializing",
      "inputs": []
    },
    {
      "type": "error",
      "name": "WalletNotAssociatedWithIdentity",
      "inputs": [
        {
          "name": "identityContract",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "userWallet",
          "type": "address",
          "internalType": "address"
        }
      ]
    }
  ],
  "bytecode": {
    "object": "0x60a03461011057601f6118f838819003918201601f19168301916001600160401b038311848410176101145780849260209460405283398101031261011057516001600160a01b0381168103610110576080525f5160206118d85f395f51905f525460ff8160401c16610101576002600160401b03196001600160401b038216016100ab575b6040516117af90816101298239608051818181610a3a01528181610c8e01526116810152f35b6001600160401b0319166001600160401b039081175f5160206118d85f395f51905f52556040519081527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f610085565b63f92ee8a960e01b5f5260045ffd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080806040526004361015610012575f80fd5b5f3560e01c90816301ffc9a714610fe35750806305510c8914610fa1578063248a9ca314610f625780632f2ff15d14610f1857806336568abe14610ec4578063485cc95514610cc2578063572b6c0514610c6e5780635d93544614610bf1578063690a49f914610b0d578063727e13bc14610ab35780637988d3a514610a695780637da0a87714610a2557806391d14854146109d057806397a012f71461089c5780639f3418d5146107de578063a217fddf146107c4578063a53410dd14610645578063bf9eb959146105b8578063cf191bcd1461041c578063d547741f146103cb578063da7b67f61461038e578063e805cf86146102ce578063e99cff521461022d5763f63304f614610124575f80fd5b346102295760403660031901126102295761013d611050565b610145611066565b61014d6111c7565b6001600160a01b031690811561021a576001600160a01b031690811561020b575f818152602081905260409020546001600160a01b03168290036101f557805f52600660205260ff60405f205416156101d9575b6001600160a01b036101b161167e565b16917f47228b5d6657d59b09119432c236ff948fc69db733803a883482ad00213e5d195f80a4005b805f52600660205260405f20600160ff198254161790556101a1565b90634bbad01960e11b5f5260045260245260445ffd5b63a28c79a960e01b5f5260045ffd5b63340d634b60e21b5f5260045ffd5b5f80fd5b3461022957604036600319011261022957610246611050565b61024e611066565b906102576111c7565b6001600160a01b031690811561021a576001600160a01b0316801561021a575f82815260208190526040902060010180546001600160a01b031916821790556001600160a01b036102a661167e565b16917f14ed39b24d4f44fed45669db1b96eb0f9f67cbf22f1b2336684b94c5a405624e5f80a4005b34610229576040366003190112610229576102e7611050565b6102ef611066565b906102f86111c7565b6001600160a01b039081165f81815260208190526040902054909291161561037b576001600160a01b031690811561020b575f90815260208190526040812080546001600160a01b038481166001600160a01b031983161790925516907f556ce885dfcea52155c773f1ed2e58781c51945c13030ab8f793c61f51d1b8089080a3005b5063572e88e360e11b5f5260045260245ffd5b34610229576020366003190112610229576001600160a01b036103af611050565b165f526006602052602060ff60405f2054166040519015158152f35b346102295760403660031901126102295761041a6004356103ea611066565b90610415610410825f525f5160206117235f395f51905f52602052600160405f20015490565b61122f565b6115d5565b005b3461022957602036600319011261022957610435611050565b61043d6111c7565b6001600160a01b039081165f81815260208190526040902054909116156105a657805f525f60205260018060a01b0360405f20541690805f52600260205260405f20545f198101818111610592576001545f198101908111610592576104a29061110c565b905460039190911b1c6001600160a01b03169081840361054d575b5050506001548015610539575f19016104ef6104da826001611124565b81549060018060a01b039060031b1b19169055565b600155805f5260026020525f6040812055805f525f6020525f60016040822082815501557fca6a4c3370b859312246e7f086284076e557997e10d856b716c23ab67067790b5f80a3005b634e487b7160e01b5f52603160045260245ffd5b8161055a61057e9261110c565b81546001600160a01b0393841660039290921b91821b9390911b1916919091179055565b5f52600260205260405f20558280806104bd565b634e487b7160e01b5f52601160045260245ffd5b63572e88e360e11b5f5260045260245ffd5b34610229575f3660031901126102295760405180602060045491828152019060045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b905f5b8181106106265761062285610616818703826110be565b6040519182918261107c565b0390f35b82546001600160a01b03168452602090930192600192830192016105ff565b346102295760603660031901126102295761065e611050565b610666611066565b6044359161ffff83168093036102295761067e6111c7565b6001600160a01b03811691821561021a576001600160a01b031692831561020b575f838152602081905260409020546001600160a01b03166107b15760405190606082019082821067ffffffffffffffff83111761079d57604091825285835260208084019182525f84840181815287825291819052929092209251835491516001600160b01b03199092166001600160a01b039182161760a09290921b61ffff60a01b16919091178355905160019283018054919092166001600160a01b03199091161790555490600160401b82101561079d5761055a82600161076894016001556001611124565b600154815f52600260205260405f20557e30dea7e9c9afaa2e3c9810f2fc9b5181f1bad74ca5a8db85f746a33585e7475f80a3005b634e487b7160e01b5f52604160045260245ffd5b82632ec44c6b60e01b5f5260045260245ffd5b34610229575f3660031901126102295760206040515f8152f35b34610229576040366003190112610229576107f7611050565b6024359061ffff821690818303610229576108106111c7565b6001600160a01b039081165f818152602081905260409020549093911615610889575f83815260208181526040909120805461ffff60a01b191660a09390931b61ffff60a01b16929092179091557f20965fcdc6eed7ae398065b40ece4e732ba667992ca819fc54e80e9f2047c4cf91604051908152a2005b8263572e88e360e11b5f5260045260245ffd5b34610229576020366003190112610229576108b5611050565b6108bd611139565b6001600160a01b0381165f8181526003602052604090205490919060ff16156109bd576108e990611533565b50805f52600560205260405f20545f198101818111610592576004545f19810190811161059257610919906110e0565b905460039190911b1c6001600160a01b03169081840361099c575b5050506004548015610539575f19016109516104da826004611124565b600455805f5260056020525f6040812055805f52600360205260405f2060ff1981541690557f51f353eb5801583fdf2706e43c045b62fdf6b1566820b349390616363ecf72c95f80a2005b8161055a6109a9926110e0565b5f52600560205260405f2055818080610934565b50630707cbe560e01b5f5260045260245ffd5b34610229576040366003190112610229576109e9611066565b6004355f525f5160206117235f395f51905f5260205260405f209060018060a01b03165f52602052602060ff60405f2054166040519015158152f35b34610229575f366003190112610229576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610229576020366003190112610229576001600160a01b03610a8a611050565b165f818152602081905260409020546001600160a01b0316801561037b57602090604051908152f35b34610229576020366003190112610229576001600160a01b03610ad4611050565b165f818152602081905260409020546001600160a01b0316156105a6575f525f602052602061ffff60405f205460a01c16604051908152f35b3461022957602036600319011261022957610b26611050565b610b2e611139565b6001600160a01b038116908115610be257815f52600360205260ff60405f205416610bcf57815f52600360205260405f20600160ff1982541617905560045490600160401b82101561079d57610b938161055a846001610ba896016004556004611124565b600454835f52600560205260405f205561133a565b507f500c250171aa20e861b680f93502547b9d436eda7d4c537fc360db6e0c6eedfb5f80a2005b50634308f35160e01b5f5260045260245ffd5b6328123ecf60e01b5f5260045ffd5b34610229575f3660031901126102295760405180602060015491828152019060015f527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6905f5b818110610c4f5761062285610616818703826110be565b82546001600160a01b0316845260209093019260019283019201610c38565b34610229576020366003190112610229576020610c89611050565b6040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b039081169216919091148152f35b3461022957604036600319011261022957610cdb611050565b610ce3611066565b5f5160206117835f395f51905f52549160ff8360401c16159267ffffffffffffffff811680159081610ebc575b6001149081610eb2575b159081610ea9575b50610e9a5767ffffffffffffffff1981166001175f5160206117835f395f51905f5255610d7992610d739185610e6e575b50610d5c6116d7565b610d646116d7565b610d6d8161128b565b5061133a565b506113cb565b505f5160206117635f395f51905f525f8181525f5160206117235f395f51905f526020527ff7b03a54cfc68aa23cbf24329c7578b5ceb6b46a5810c7579bd72f09cbc7660c80547f3878ec43b99c41b142f55c5c47e7aa371ea82865d891af952bc6234dbce14f1891829055604051949391929091907fbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff9080a4610e1957005b60207fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29168ff0000000000000000195f5160206117835f395f51905f5254165f5160206117835f395f51905f525560018152a1005b68ffffffffffffffffff191668010000000000000001175f5160206117835f395f51905f525585610d53565b63f92ee8a960e01b5f5260045ffd5b90501585610d22565b303b159150610d1a565b859150610d10565b3461022957604036600319011261022957610edd611066565b6001600160a01b03610eed61167e565b166001600160a01b03821603610f095761041a906004356115d5565b63334bd91960e11b5f5260045ffd5b346102295760403660031901126102295761041a600435610f37611066565b90610f5d610410825f525f5160206117235f395f51905f52602052600160405f20015490565b611495565b34610229576020366003190112610229576020610f996004355f525f5160206117235f395f51905f52602052600160405f20015490565b604051908152f35b34610229576020366003190112610229576001600160a01b03610fc2611050565b165f525f602052602060018060a01b03600160405f20015416604051908152f35b34610229576020366003190112610229576004359063ffffffff60e01b82168092036102295760209163c08590db60e01b8114908115611025575b5015158152f35b637965db0b60e01b81149150811561103f575b508361101e565b6301ffc9a760e01b14905083611038565b600435906001600160a01b038216820361022957565b602435906001600160a01b038216820361022957565b60206040818301928281528451809452019201905f5b81811061109f5750505090565b82516001600160a01b0316845260209384019390920191600101611092565b90601f8019910116810190811067ffffffffffffffff82111761079d57604052565b6004548110156110f85760045f5260205f2001905f90565b634e487b7160e01b5f52603260045260245ffd5b6001548110156110f85760015f5260205f2001905f90565b80548210156110f8575f5260205f2001905f90565b61114161167e565b6001600160a01b0381165f9081527f3f90e2dd3d252a7c29677a1e0ae0030274210eff4f89bbec9ada3b8e9a23c547602052604090205460ff16156111835750565b63e2517d3f60e01b5f9081526001600160a01b03919091166004527f3878ec43b99c41b142f55c5c47e7aa371ea82865d891af952bc6234dbce14f18602452604490fd5b6111cf61167e565b6001600160a01b0381165f9081525f5160206117435f395f51905f52602052604090205460ff16156111fe5750565b63e2517d3f60e01b5f9081526001600160a01b03919091166004525f5160206117635f395f51905f52602452604490fd5b61123761167e565b815f525f5160206117235f395f51905f5260205260405f2060018060a01b0382165f5260205260ff60405f2054161561126e575050565b63e2517d3f60e01b5f5260018060a01b031660045260245260445ffd5b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16611335576001600160a01b038181165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260409020805460ff1916600117905561131361167e565b16906001600160a01b03165f5f5160206117035f395f51905f528180a4600190565b505f90565b6001600160a01b0381165f9081525f5160206117435f395f51905f52602052604090205460ff16611335576001600160a01b038181165f9081525f5160206117435f395f51905f5260205260409020805460ff1916600117905561139c61167e565b16906001600160a01b03165f5160206117635f395f51905f525f5160206117035f395f51905f525f80a4600190565b6001600160a01b0381165f9081527f3f90e2dd3d252a7c29677a1e0ae0030274210eff4f89bbec9ada3b8e9a23c547602052604090205460ff16611335576001600160a01b038181165f9081527f3f90e2dd3d252a7c29677a1e0ae0030274210eff4f89bbec9ada3b8e9a23c54760205260409020805460ff1916600117905561145361167e565b16906001600160a01b03167f3878ec43b99c41b142f55c5c47e7aa371ea82865d891af952bc6234dbce14f185f5160206117035f395f51905f525f80a4600190565b5f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b038616845290915290205460ff1661152d575f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b0386811685529252909120805460ff1916600117905561150b61167e565b16916001600160a01b0316905f5160206117035f395f51905f525f80a4600190565b50505f90565b6001600160a01b0381165f9081525f5160206117435f395f51905f52602052604090205460ff1615611335576001600160a01b038181165f9081525f5160206117435f395f51905f5260205260409020805460ff1916905561159361167e565b16906001600160a01b03165f5160206117635f395f51905f527ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b5f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b038616845290915290205460ff161561152d575f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b0386811685529252909120805460ff1916905561164961167e565b16916001600160a01b0316907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031614806116cc575b156116c8576013193601368111610592573560601c90565b3390565b5060143610156116b0565b60ff5f5160206117835f395f51905f525460401c16156116f357565b631afcd79f60e31b5f5260045ffdfe2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800f7b03a54cfc68aa23cbf24329c7578b5ceb6b46a5810c7579bd72f09cbc7660bf926905b211c4fe59c7d68bb001aa504586558fd2888c1ea46e1b382450050cff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00a164736f6c634300081c000af0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00",
    "sourceMap": "3770:40037:122:-:0;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;1623:37:189;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;7894:76:190;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;7983:34:190;7979:146;;-1:-1:-1;3770:40037:122;;;;;;;;1623:37:189;3770:40037:122;;;;;;;;;;;;;;;;7979:146:190;-1:-1:-1;;;;;;3770:40037:122;-1:-1:-1;;;;;3770:40037:122;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;8085:29:190;;3770:40037:122;;8085:29:190;7979:146;;;7894:76;7936:23;;;-1:-1:-1;7936:23:190;;-1:-1:-1;7936:23:190;3770:40037:122;-1:-1:-1;3770:40037:122;;;;;;-1:-1:-1;3770:40037:122;;;;;-1:-1:-1;3770:40037:122",
    "linkReferences": {}
  },
  "deployedBytecode": {
    "object": "0x6080806040526004361015610012575f80fd5b5f3560e01c90816301ffc9a714610fe35750806305510c8914610fa1578063248a9ca314610f625780632f2ff15d14610f1857806336568abe14610ec4578063485cc95514610cc2578063572b6c0514610c6e5780635d93544614610bf1578063690a49f914610b0d578063727e13bc14610ab35780637988d3a514610a695780637da0a87714610a2557806391d14854146109d057806397a012f71461089c5780639f3418d5146107de578063a217fddf146107c4578063a53410dd14610645578063bf9eb959146105b8578063cf191bcd1461041c578063d547741f146103cb578063da7b67f61461038e578063e805cf86146102ce578063e99cff521461022d5763f63304f614610124575f80fd5b346102295760403660031901126102295761013d611050565b610145611066565b61014d6111c7565b6001600160a01b031690811561021a576001600160a01b031690811561020b575f818152602081905260409020546001600160a01b03168290036101f557805f52600660205260ff60405f205416156101d9575b6001600160a01b036101b161167e565b16917f47228b5d6657d59b09119432c236ff948fc69db733803a883482ad00213e5d195f80a4005b805f52600660205260405f20600160ff198254161790556101a1565b90634bbad01960e11b5f5260045260245260445ffd5b63a28c79a960e01b5f5260045ffd5b63340d634b60e21b5f5260045ffd5b5f80fd5b3461022957604036600319011261022957610246611050565b61024e611066565b906102576111c7565b6001600160a01b031690811561021a576001600160a01b0316801561021a575f82815260208190526040902060010180546001600160a01b031916821790556001600160a01b036102a661167e565b16917f14ed39b24d4f44fed45669db1b96eb0f9f67cbf22f1b2336684b94c5a405624e5f80a4005b34610229576040366003190112610229576102e7611050565b6102ef611066565b906102f86111c7565b6001600160a01b039081165f81815260208190526040902054909291161561037b576001600160a01b031690811561020b575f90815260208190526040812080546001600160a01b038481166001600160a01b031983161790925516907f556ce885dfcea52155c773f1ed2e58781c51945c13030ab8f793c61f51d1b8089080a3005b5063572e88e360e11b5f5260045260245ffd5b34610229576020366003190112610229576001600160a01b036103af611050565b165f526006602052602060ff60405f2054166040519015158152f35b346102295760403660031901126102295761041a6004356103ea611066565b90610415610410825f525f5160206117235f395f51905f52602052600160405f20015490565b61122f565b6115d5565b005b3461022957602036600319011261022957610435611050565b61043d6111c7565b6001600160a01b039081165f81815260208190526040902054909116156105a657805f525f60205260018060a01b0360405f20541690805f52600260205260405f20545f198101818111610592576001545f198101908111610592576104a29061110c565b905460039190911b1c6001600160a01b03169081840361054d575b5050506001548015610539575f19016104ef6104da826001611124565b81549060018060a01b039060031b1b19169055565b600155805f5260026020525f6040812055805f525f6020525f60016040822082815501557fca6a4c3370b859312246e7f086284076e557997e10d856b716c23ab67067790b5f80a3005b634e487b7160e01b5f52603160045260245ffd5b8161055a61057e9261110c565b81546001600160a01b0393841660039290921b91821b9390911b1916919091179055565b5f52600260205260405f20558280806104bd565b634e487b7160e01b5f52601160045260245ffd5b63572e88e360e11b5f5260045260245ffd5b34610229575f3660031901126102295760405180602060045491828152019060045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b905f5b8181106106265761062285610616818703826110be565b6040519182918261107c565b0390f35b82546001600160a01b03168452602090930192600192830192016105ff565b346102295760603660031901126102295761065e611050565b610666611066565b6044359161ffff83168093036102295761067e6111c7565b6001600160a01b03811691821561021a576001600160a01b031692831561020b575f838152602081905260409020546001600160a01b03166107b15760405190606082019082821067ffffffffffffffff83111761079d57604091825285835260208084019182525f84840181815287825291819052929092209251835491516001600160b01b03199092166001600160a01b039182161760a09290921b61ffff60a01b16919091178355905160019283018054919092166001600160a01b03199091161790555490600160401b82101561079d5761055a82600161076894016001556001611124565b600154815f52600260205260405f20557e30dea7e9c9afaa2e3c9810f2fc9b5181f1bad74ca5a8db85f746a33585e7475f80a3005b634e487b7160e01b5f52604160045260245ffd5b82632ec44c6b60e01b5f5260045260245ffd5b34610229575f3660031901126102295760206040515f8152f35b34610229576040366003190112610229576107f7611050565b6024359061ffff821690818303610229576108106111c7565b6001600160a01b039081165f818152602081905260409020549093911615610889575f83815260208181526040909120805461ffff60a01b191660a09390931b61ffff60a01b16929092179091557f20965fcdc6eed7ae398065b40ece4e732ba667992ca819fc54e80e9f2047c4cf91604051908152a2005b8263572e88e360e11b5f5260045260245ffd5b34610229576020366003190112610229576108b5611050565b6108bd611139565b6001600160a01b0381165f8181526003602052604090205490919060ff16156109bd576108e990611533565b50805f52600560205260405f20545f198101818111610592576004545f19810190811161059257610919906110e0565b905460039190911b1c6001600160a01b03169081840361099c575b5050506004548015610539575f19016109516104da826004611124565b600455805f5260056020525f6040812055805f52600360205260405f2060ff1981541690557f51f353eb5801583fdf2706e43c045b62fdf6b1566820b349390616363ecf72c95f80a2005b8161055a6109a9926110e0565b5f52600560205260405f2055818080610934565b50630707cbe560e01b5f5260045260245ffd5b34610229576040366003190112610229576109e9611066565b6004355f525f5160206117235f395f51905f5260205260405f209060018060a01b03165f52602052602060ff60405f2054166040519015158152f35b34610229575f366003190112610229576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610229576020366003190112610229576001600160a01b03610a8a611050565b165f818152602081905260409020546001600160a01b0316801561037b57602090604051908152f35b34610229576020366003190112610229576001600160a01b03610ad4611050565b165f818152602081905260409020546001600160a01b0316156105a6575f525f602052602061ffff60405f205460a01c16604051908152f35b3461022957602036600319011261022957610b26611050565b610b2e611139565b6001600160a01b038116908115610be257815f52600360205260ff60405f205416610bcf57815f52600360205260405f20600160ff1982541617905560045490600160401b82101561079d57610b938161055a846001610ba896016004556004611124565b600454835f52600560205260405f205561133a565b507f500c250171aa20e861b680f93502547b9d436eda7d4c537fc360db6e0c6eedfb5f80a2005b50634308f35160e01b5f5260045260245ffd5b6328123ecf60e01b5f5260045ffd5b34610229575f3660031901126102295760405180602060015491828152019060015f527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6905f5b818110610c4f5761062285610616818703826110be565b82546001600160a01b0316845260209093019260019283019201610c38565b34610229576020366003190112610229576020610c89611050565b6040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b039081169216919091148152f35b3461022957604036600319011261022957610cdb611050565b610ce3611066565b5f5160206117835f395f51905f52549160ff8360401c16159267ffffffffffffffff811680159081610ebc575b6001149081610eb2575b159081610ea9575b50610e9a5767ffffffffffffffff1981166001175f5160206117835f395f51905f5255610d7992610d739185610e6e575b50610d5c6116d7565b610d646116d7565b610d6d8161128b565b5061133a565b506113cb565b505f5160206117635f395f51905f525f8181525f5160206117235f395f51905f526020527ff7b03a54cfc68aa23cbf24329c7578b5ceb6b46a5810c7579bd72f09cbc7660c80547f3878ec43b99c41b142f55c5c47e7aa371ea82865d891af952bc6234dbce14f1891829055604051949391929091907fbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff9080a4610e1957005b60207fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29168ff0000000000000000195f5160206117835f395f51905f5254165f5160206117835f395f51905f525560018152a1005b68ffffffffffffffffff191668010000000000000001175f5160206117835f395f51905f525585610d53565b63f92ee8a960e01b5f5260045ffd5b90501585610d22565b303b159150610d1a565b859150610d10565b3461022957604036600319011261022957610edd611066565b6001600160a01b03610eed61167e565b166001600160a01b03821603610f095761041a906004356115d5565b63334bd91960e11b5f5260045ffd5b346102295760403660031901126102295761041a600435610f37611066565b90610f5d610410825f525f5160206117235f395f51905f52602052600160405f20015490565b611495565b34610229576020366003190112610229576020610f996004355f525f5160206117235f395f51905f52602052600160405f20015490565b604051908152f35b34610229576020366003190112610229576001600160a01b03610fc2611050565b165f525f602052602060018060a01b03600160405f20015416604051908152f35b34610229576020366003190112610229576004359063ffffffff60e01b82168092036102295760209163c08590db60e01b8114908115611025575b5015158152f35b637965db0b60e01b81149150811561103f575b508361101e565b6301ffc9a760e01b14905083611038565b600435906001600160a01b038216820361022957565b602435906001600160a01b038216820361022957565b60206040818301928281528451809452019201905f5b81811061109f5750505090565b82516001600160a01b0316845260209384019390920191600101611092565b90601f8019910116810190811067ffffffffffffffff82111761079d57604052565b6004548110156110f85760045f5260205f2001905f90565b634e487b7160e01b5f52603260045260245ffd5b6001548110156110f85760015f5260205f2001905f90565b80548210156110f8575f5260205f2001905f90565b61114161167e565b6001600160a01b0381165f9081527f3f90e2dd3d252a7c29677a1e0ae0030274210eff4f89bbec9ada3b8e9a23c547602052604090205460ff16156111835750565b63e2517d3f60e01b5f9081526001600160a01b03919091166004527f3878ec43b99c41b142f55c5c47e7aa371ea82865d891af952bc6234dbce14f18602452604490fd5b6111cf61167e565b6001600160a01b0381165f9081525f5160206117435f395f51905f52602052604090205460ff16156111fe5750565b63e2517d3f60e01b5f9081526001600160a01b03919091166004525f5160206117635f395f51905f52602452604490fd5b61123761167e565b815f525f5160206117235f395f51905f5260205260405f2060018060a01b0382165f5260205260ff60405f2054161561126e575050565b63e2517d3f60e01b5f5260018060a01b031660045260245260445ffd5b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16611335576001600160a01b038181165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260409020805460ff1916600117905561131361167e565b16906001600160a01b03165f5f5160206117035f395f51905f528180a4600190565b505f90565b6001600160a01b0381165f9081525f5160206117435f395f51905f52602052604090205460ff16611335576001600160a01b038181165f9081525f5160206117435f395f51905f5260205260409020805460ff1916600117905561139c61167e565b16906001600160a01b03165f5160206117635f395f51905f525f5160206117035f395f51905f525f80a4600190565b6001600160a01b0381165f9081527f3f90e2dd3d252a7c29677a1e0ae0030274210eff4f89bbec9ada3b8e9a23c547602052604090205460ff16611335576001600160a01b038181165f9081527f3f90e2dd3d252a7c29677a1e0ae0030274210eff4f89bbec9ada3b8e9a23c54760205260409020805460ff1916600117905561145361167e565b16906001600160a01b03167f3878ec43b99c41b142f55c5c47e7aa371ea82865d891af952bc6234dbce14f185f5160206117035f395f51905f525f80a4600190565b5f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b038616845290915290205460ff1661152d575f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b0386811685529252909120805460ff1916600117905561150b61167e565b16916001600160a01b0316905f5160206117035f395f51905f525f80a4600190565b50505f90565b6001600160a01b0381165f9081525f5160206117435f395f51905f52602052604090205460ff1615611335576001600160a01b038181165f9081525f5160206117435f395f51905f5260205260409020805460ff1916905561159361167e565b16906001600160a01b03165f5160206117635f395f51905f527ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b5f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b038616845290915290205460ff161561152d575f8181525f5160206117235f395f51905f52602090815260408083206001600160a01b0386811685529252909120805460ff1916905561164961167e565b16916001600160a01b0316907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031614806116cc575b156116c8576013193601368111610592573560601c90565b3390565b5060143610156116b0565b60ff5f5160206117835f395f51905f525460401c16156116f357565b631afcd79f60e31b5f5260045ffdfe2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800f7b03a54cfc68aa23cbf24329c7578b5ceb6b46a5810c7579bd72f09cbc7660bf926905b211c4fe59c7d68bb001aa504586558fd2888c1ea46e1b382450050cff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00a164736f6c634300081c000a",
    "sourceMap": "3770:40037:122:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;:::i;:::-;3202:4:186;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;37083:24;;37079:67;;-1:-1:-1;;;;;3770:40037:122;;37160:30;;37156:67;;3770:40037;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;37320:60;;;37316:159;;3770:40037;;;37559:12;3770:40037;;;;;;;;37558:25;37554:87;;3770:40037;-1:-1:-1;;;;;40118:38:122;;:::i;:::-;3770:40037;37745:70;;3770:40037;37745:70;;3770:40037;37554:87;3770:40037;;;37559:12;3770:40037;;;;;37626:4;3770:40037;;;;;;;;37554:87;;37316:159;37403:61;;;;3770:40037;37403:61;3770:40037;;;;;;37403:61;37156:67;20346:24;;;3770:40037;37199:24;3770:40037;;37199:24;37079:67;20261:30;;;3770:40037;37116:30;3770:40037;;37116:30;3770:40037;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;:::i;:::-;3202:4:186;;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;38074:24;;38070:67;;-1:-1:-1;;;;;3770:40037:122;38151:23;;38147:66;;3770:40037;;;;;;;;;;;38291:39;;3770:40037;;-1:-1:-1;;;;;;3770:40037:122;;;;;-1:-1:-1;;;;;40118:38:122;;:::i;:::-;3770:40037;38358:57;;3770:40037;38358:57;;3770:40037;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;:::i;:::-;3202:4:186;;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;;25980:56;25976:103;;-1:-1:-1;;;;;3770:40037:122;;26093:32;;26089:69;;3770:40037;;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;-1:-1:-1;;;;;;3770:40037:122;;;;;;;;26335:40;;3770:40037;26335:40;3770:40037;25976:103;36006:34;;;;3770:40037;26045:34;3770:40037;;;;26045:34;3770:40037;;;;;;-1:-1:-1;;3770:40037:122;;;;-1:-1:-1;;;;;3770:40037:122;;:::i;:::-;;;;38583:12;3770:40037;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;5767:26:186;3770:40037:122;;;;:::i;:::-;5737:18:186;3202:4;5737:18;;-1:-1:-1;3770:40037:122;-1:-1:-1;;;;;;;;;;;3770:40037:122;;4919:24:186;3770:40037:122;-1:-1:-1;3770:40037:122;4919:24:186;3770:40037:122;4759:191:186;;5737:18;3202:4;:::i;:::-;5767:26;:::i;:::-;3770:40037:122;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;3202:4:186;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;23038:56;23034:103;;3770:40037;;;;;;;;;;;;;;;;;;;;23465:21;3770:40037;;;;;;;;;;;;;;;23503:1;3770:40037;-1:-1:-1;;3770:40037:122;;;;;;;23603:45;;;:::i;:::-;3770:40037;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;23812:33;;;23808:317;;3770:40037;;;;23503:1;3770:40037;;;;;-1:-1:-1;;3770:40037:122;;;;23503:1;3770:40037;:::i;:::-;;;;;;;;;;;;;;;;;;;23503:1;3770:40037;;;;23465:21;3770:40037;;;;;;;;;;;;;;23503:1;3770:40037;;;;;;;;24558:43;3770:40037;24558:43;;3770:40037;;;;;;;;;;;;;23808:317;23861:31;;:51;:31;;:::i;:::-;3770:40037;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;;;;;;;23861:51;3770:40037;;23465:21;3770:40037;;;;;;23808:317;;;;;3770:40037;;;;;;;;;;;;23034:103;36006:34;;;3770:40037;23103:34;3770:40037;;;;23103:34;3770:40037;;;;;;-1:-1:-1;;3770:40037:122;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;:::i;:::-;;;;;;;;;;;;3202:4:186;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;;20226:26;;20222:69;;-1:-1:-1;;;;;3770:40037:122;;20305:32;;20301:69;;3770:40037;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;20555:104;;3770:40037;;;;;;;;;;;;;;;;;;;;;;;;20745:50;;;3770:40037;;;-1:-1:-1;20745:50:122;;;3770:40037;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;3770:40037:122;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;-1:-1:-1;;;3770:40037:122;;;;;;;;;-1:-1:-1;3770:40037:122;;;;;;;;;-1:-1:-1;;;;;;3770:40037:122;;;;;;;;-1:-1:-1;;;3770:40037:122;;;;;;;;;;;;;;;:::i;:::-;;;;;;21047:21;3770:40037;;;;;;21124:39;3770:40037;21124:39;;3770:40037;;;;;;;;;;;;;20555:104;20624:35;;;;3770:40037;20624:35;3770:40037;;;;20624:35;3770:40037;;;;;;-1:-1:-1;;3770:40037:122;;;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;;;;;;;;;;;3202:4:186;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;;27559:56;27555:103;;3770:40037;;;;;;;;;;;;;;-1:-1:-1;;;;3770:40037:122;;;;;;-1:-1:-1;;;3770:40037:122;;;;;;;;27729:39;;3770:40037;;;;;27729:39;3770:40037;27555:103;36006:34;;;;3770:40037;27624:34;3770:40037;;;;27624:34;3770:40037;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;3202:4:186;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;;;;;31305:24;3770:40037;;;;;;;;;;;31304:44;31300:100;;31411:68;;;:::i;:::-;;3770:40037;;;31668:29;3770:40037;;;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;;31781:75;;;:::i;:::-;3770:40037;;31305:24;3770:40037;;;;;-1:-1:-1;;;;;3770:40037:122;;31871:33;;;31867:270;;3770:40037;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;;;;31668:29;3770:40037;;;;;;;;;;31305:24;3770:40037;;;;;;;;;;;;32346:42;3770:40037;32346:42;;3770:40037;31867:270;31920:46;;:61;:46;;:::i;:61::-;3770:40037;;31668:29;3770:40037;;;;;;31867:270;;;;;31300:100;31357:43;;;;3770:40037;31357:43;3770:40037;;;;31357:43;3770:40037;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;3901:31:186;3770:40037:122;;;;;;-1:-1:-1;3770:40037:122;;;;;;-1:-1:-1;3770:40037:122;;;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;1830:17:189;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;-1:-1:-1;;;;;3770:40037:122;;:::i;:::-;;;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;34291:26;;34287:73;;3770:40037;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;-1:-1:-1;;;;;3770:40037:122;;:::i;:::-;;;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;35971:26;35967:73;;3770:40037;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;3202:4:186;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;;29370:31;;29366:76;;3770:40037;;;29456:24;3770:40037;;;;;;;;29452:103;;3770:40037;;;29456:24;3770:40037;;;;;29612:4;3770:40037;;;;;;;;;;;-1:-1:-1;;;3770:40037:122;;;;;;;;;29612:4;29830:67;3770:40037;;;;;;:::i;:::-;;;;;;29691:29;3770:40037;;;;;;29830:67;:::i;:::-;;29953:40;3770:40037;29953:40;;3770:40037;29452:103;29508:47;;;;3770:40037;29508:47;3770:40037;;;;29508:47;29366:76;29410:32;;;3770:40037;29410:32;3770:40037;;29410:32;3770:40037;;;;;;-1:-1:-1;;3770:40037:122;;;;;;;;36754:16;3770:40037;;;;;;;36754:16;3770:40037;;;;;;;;;;;;;;;;;;;:::i;:::-;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;36754:16;3770:40037;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;;:::i;:::-;;;1830:17:189;-1:-1:-1;;;;;3770:40037:122;;;;;2054:31:189;;;;3770:40037:122;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;;;:::i;:::-;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;4301:16:190;3770:40037:122;;;;4724:16:190;;:34;;;;3770:40037:122;4803:1:190;4788:16;:50;;;;3770:40037:122;4853:13:190;:30;;;;3770:40037:122;4849:91:190;;;-1:-1:-1;;3770:40037:122;;4803:1:190;3770:40037:122;-1:-1:-1;;;;;;;;;;;3770:40037:122;17558:57;;17415:62;;3770:40037;4977:67:190;;3770:40037:122;6891:76:190;;;:::i;:::-;;;:::i;:::-;17317:59:122;;;:::i;:::-;;17415:62;:::i;:::-;;17558:57;:::i;:::-;-1:-1:-1;;;;;;;;;;;;3770:40037:122;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;4919:24:186;3770:40037:122;;3292:35:103;3770:40037:122;;;;;;;;3292:35:103;;3770:40037:122;;2557:34:103;6977:52:186;;3770:40037:122;6977:52:186;5064:101:190;;3770:40037:122;5064:101:190;3770:40037:122;5140:14:190;3770:40037:122;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;-1:-1:-1;;;;;;;;;;;3770:40037:122;4803:1:190;3770:40037:122;;5140:14:190;3770:40037:122;4977:67:190;-1:-1:-1;;3770:40037:122;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;4977:67:190;;;4849:91;4906:23;;;3770:40037:122;4906:23:190;3770:40037:122;;4906:23:190;4853:30;4870:13;;;4853:30;;;4788:50;4816:4;4808:25;:30;;-1:-1:-1;4788:50:190;;4724:34;;;-1:-1:-1;4724:34:190;;3770:40037:122;;;;;;-1:-1:-1;;3770:40037:122;;;;;;:::i;:::-;-1:-1:-1;;;;;40118:38:122;;:::i;:::-;3770:40037;-1:-1:-1;;;;;3770:40037:122;;6441:34:186;6437:102;;6549:37;3770:40037:122;;;6549:37:186;:::i;6437:102::-;6498:30;;;3770:40037:122;6498:30:186;3770:40037:122;;6498:30:186;3770:40037:122;;;;;;-1:-1:-1;;3770:40037:122;;;;5350:25:186;3770:40037:122;;;;:::i;:::-;5320:18:186;3202:4;5320:18;;-1:-1:-1;3770:40037:122;-1:-1:-1;;;;;;;;;;;3770:40037:122;;4919:24:186;3770:40037:122;-1:-1:-1;3770:40037:122;4919:24:186;3770:40037:122;4759:191:186;;3202:4;5350:25;:::i;3770:40037:122:-;;;;;;-1:-1:-1;;3770:40037:122;;;;;;;;-1:-1:-1;3770:40037:122;-1:-1:-1;;;;;;;;;;;3770:40037:122;;4919:24:186;3770:40037:122;-1:-1:-1;3770:40037:122;4919:24:186;3770:40037:122;4759:191:186;;3770:40037:122;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;-1:-1:-1;;;;;3770:40037:122;;:::i;:::-;;;;;;;;;;;;;38787:39;3770:40037;;;38787:39;3770:40037;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;43696:62:122;;;:102;;;;3770:40037;;;;;;;43696:102;-1:-1:-1;;;3551:47:186;;;-1:-1:-1;3551:87:186;;;;43696:102:122;;;;;3551:87:186;-1:-1:-1;;;1134:40:198;;-1:-1:-1;3551:87:186;;;3770:40037:122;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;:::o;:::-;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;-1:-1:-1;3770:40037:122;;-1:-1:-1;3770:40037:122;;;-1:-1:-1;3770:40037:122;:::o;:::-;;;;;;;;;;;;;23503:1;3770:40037;;;;;;23503:1;-1:-1:-1;3770:40037:122;;-1:-1:-1;3770:40037:122;;;-1:-1:-1;3770:40037:122;:::o;:::-;;;;;;;;-1:-1:-1;3770:40037:122;;-1:-1:-1;3770:40037:122;;;-1:-1:-1;3770:40037:122;:::o;4148:103:186:-;40118:38:122;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;-1:-1:-1;3770:40037:122;;;;;;;;;;;;4468:23:186;4464:108;;4148:103;:::o;4464:108::-;-1:-1:-1;;;;4514:47:186;;;-1:-1:-1;;;;;3770:40037:122;;;;4514:47:186;3770:40037:122;3292:35:103;3770:40037:122;;;;4514:47:186;4148:103;40118:38:122;;:::i;:::-;-1:-1:-1;;;;;3770:40037:122;;-1:-1:-1;3770:40037:122;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;;4468:23:186;4464:108;;4148:103;:::o;4464:108::-;-1:-1:-1;;;;4514:47:186;;;-1:-1:-1;;;;;3770:40037:122;;;;4514:47:186;3770:40037:122;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;4514:47:186;4148:103;40118:38:122;;:::i;:::-;3770:40037;-1:-1:-1;3770:40037:122;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;-1:-1:-1;3770:40037:122;;;;;;;;-1:-1:-1;3770:40037:122;;;;;-1:-1:-1;3770:40037:122;;;4468:23:186;4464:108;;4148:103;;:::o;4464:108::-;4514:47;;;-1:-1:-1;4514:47:186;3770:40037:122;;;;;;4514:47:186;3770:40037:122;;;;-1:-1:-1;4514:47:186;7270:387;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;40118:38;;:::i;:::-;3770:40037;;-1:-1:-1;;;;;3770:40037:122;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;7532:40:186;7509:4;7586:11;:::o;7432:219::-;7628:12;3770:40037:122;7628:12:186;:::o;7270:387::-;-1:-1:-1;;;;;3770:40037:122;;;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;-1:-1:-1;;3770:40037:122;;;;;40118:38;;:::i;:::-;3770:40037;;-1:-1:-1;;;;;3770:40037:122;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;3770:40037:122;;7532:40:186;7509:4;7586:11;:::o;7270:387::-;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;40118:38;;:::i;:::-;3770:40037;;-1:-1:-1;;;;;3770:40037:122;3292:35:103;-1:-1:-1;;;;;;;;;;;3770:40037:122;;7532:40:186;7509:4;7586:11;:::o;7270:387::-;3770:40037:122;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;;;40118:38;;:::i;:::-;3770:40037;;-1:-1:-1;;;;;3770:40037:122;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;7532:40:186;7509:4;7586:11;:::o;7432:219::-;7628:12;;3770:40037:122;7628:12:186;:::o;7894:388::-;-1:-1:-1;;;;;3770:40037:122;;;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;-1:-1:-1;;3770:40037:122;;;40118:38;;:::i;:::-;3770:40037;;-1:-1:-1;;;;;3770:40037:122;-1:-1:-1;;;;;;;;;;;8157:40:186;3770:40037:122;;8157:40:186;3770:40037:122;8211:11:186;:::o;7894:388::-;3770:40037:122;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;;;;;-1:-1:-1;;;;;3770:40037:122;;;;;;;;;;;;-1:-1:-1;;3770:40037:122;;;40118:38;;:::i;:::-;3770:40037;;-1:-1:-1;;;;;3770:40037:122;;8157:40:186;3770:40037:122;;8157:40:186;3770:40037:122;8211:11:186;:::o;2329:429:189:-;2545:10;1830:17;-1:-1:-1;;;;;3770:40037:122;2054:31:189;;2526:71;;2329:429;2522:230;;;3770:40037:122;;2435:8:189;3770:40037:122;2435:8:189;3770:40037:122;;;;;;;;2613:72:189:o;2522:230::-;2545:10;2716:25;:::o;2526:71::-;2435:8;3606:2;2435:8;2560:37;;2526:71;;7082:141:190;3770:40037:122;-1:-1:-1;;;;;;;;;;;3770:40037:122;;;;7148:18:190;7144:73;;7082:141::o;7144:73::-;7189:17;;;-1:-1:-1;7189:17:190;;-1:-1:-1;7189:17:190",
    "linkReferences": {},
    "immutableReferences": {
      "45499": [
        {
          "start": 2618,
          "length": 32
        },
        {
          "start": 3214,
          "length": 32
        },
        {
          "start": 5761,
          "length": 32
        }
      ]
    }
  },
  "methodIdentifiers": {
    "DEFAULT_ADMIN_ROLE()": "a217fddf",
    "addIdentityToStorage(address,address,uint16)": "a53410dd",
    "bindIdentityRegistry(address)": "690a49f9",
    "getIdentityWallets()": "5d935446",
    "getRecoveredWalletFromStorage(address)": "05510c89",
    "getRoleAdmin(bytes32)": "248a9ca3",
    "grantRole(bytes32,address)": "2f2ff15d",
    "hasRole(bytes32,address)": "91d14854",
    "initialize(address,address)": "485cc955",
    "isTrustedForwarder(address)": "572b6c05",
    "isWalletMarkedAsLost(address)": "da7b67f6",
    "linkWalletRecovery(address,address)": "e99cff52",
    "linkedIdentityRegistries()": "bf9eb959",
    "markWalletAsLost(address,address)": "f63304f6",
    "modifyStoredIdentity(address,address)": "e805cf86",
    "modifyStoredInvestorCountry(address,uint16)": "9f3418d5",
    "removeIdentityFromStorage(address)": "cf191bcd",
    "renounceRole(bytes32,address)": "36568abe",
    "revokeRole(bytes32,address)": "d547741f",
    "storedIdentity(address)": "7988d3a5",
    "storedInvestorCountry(address)": "727e13bc",
    "supportsInterface(bytes4)": "01ffc9a7",
    "trustedForwarder()": "7da0a877",
    "unbindIdentityRegistry(address)": "97a012f7"
  },
  "rawMetadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"IdentityAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"IdentityDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"IdentityRegistryAlreadyBound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"IdentityRegistryNotBound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidIdentityAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidIdentityRegistryAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidIdentityWalletAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"identityContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userWallet\",\"type\":\"address\"}],\"name\":\"WalletNotAssociatedWithIdentity\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_identityWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"CountryModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"_oldIdentity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"_newIdentity\",\"type\":\"address\"}],\"name\":\"IdentityModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_identityRegistry\",\"type\":\"address\"}],\"name\":\"IdentityRegistryBound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_identityRegistry\",\"type\":\"address\"}],\"name\":\"IdentityRegistryUnbound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"}],\"name\":\"IdentityStored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"}],\"name\":\"IdentityUnstored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identityContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"markedBy\",\"type\":\"address\"}],\"name\":\"IdentityWalletMarkedAsLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"establishedBy\",\"type\":\"address\"}],\"name\":\"WalletRecoveryLinked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"addIdentityToStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identityRegistry\",\"type\":\"address\"}],\"name\":\"bindIdentityRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdentityWallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostWallet\",\"type\":\"address\"}],\"name\":\"getRecoveredWalletFromStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"system\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialAdmin\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userWallet\",\"type\":\"address\"}],\"name\":\"isWalletMarkedAsLost\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"linkWalletRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkedIdentityRegistries\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"identityContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userWallet\",\"type\":\"address\"}],\"name\":\"markWalletAsLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"}],\"name\":\"modifyStoredIdentity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"modifyStoredInvestorCountry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"removeIdentityFromStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"storedIdentity\",\"outputs\":[{\"internalType\":\"contract IIdentity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"storedInvestorCountry\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identityRegistry\",\"type\":\"address\"}],\"name\":\"unbindIdentityRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"SettleMint Tokenization Services\",\"details\":\"This contract implements `ISMARTIdentityRegistryStorage`, a standard interface for storing data related to ERC-3643 compliant identity registries. This includes mapping user wallet addresses to their `IIdentity` contracts (which hold identity claims like KYC/AML status) and their country codes (for compliance purposes). It uses `AccessControlUpgradeable` to manage permissions:    - `DEFAULT_ADMIN_ROLE`: This role has the highest level of control. It can grant or revoke any other role,      including `MANAGE_REGISTRIES_ROLE`. Typically held by a secure multi-signature wallet or a DAO.    - `MANAGE_REGISTRIES_ROLE`: This role is responsible for managing which `SMARTIdentityRegistry` contracts      are allowed to interact with this storage. It can bind new registry contracts (granting them      `STORAGE_MODIFIER_ROLE`) and unbind existing ones. This role is usually assigned to a system controller      contract like `SMARTSystem` or an identity factory.    - `STORAGE_MODIFIER_ROLE`: This role is granted to `SMARTIdentityRegistry` contracts that have been \\\"bound\\\"      to this storage. Contracts with this role are authorized to call functions that add, remove, or update      identity data within this storage contract (e.g., `addIdentityToStorage`, `modifyStoredInvestorCountry`). The contract supports meta-transactions through `ERC2771ContextUpgradeable`, allowing users to interact with it via a trusted forwarder, potentially paying gas fees in tokens other than Ether. It is designed to be upgradeable using the UUPS (Universal Upgradeable Proxy Standard) pattern, meaning the upgrade logic resides within this implementation contract itself. The contract also maintains lists of all registered identity wallets and all bound registry contracts, which can be useful for enumeration, auditing, or administrative purposes.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}],\"IdentityAlreadyExists(address)\":[{\"details\":\"This error prevents duplicate identity registrations for the same wallet address, maintaining data integrity.\",\"params\":{\"userAddress\":\"The wallet address for which an identity record already exists.\"}}],\"IdentityDoesNotExist(address)\":[{\"details\":\"This error ensures that operations like modification or removal are only performed on existing identity records.\",\"params\":{\"userAddress\":\"The wallet address for which no identity record was found in the storage.\"}}],\"IdentityRegistryAlreadyBound(address)\":[{\"details\":\"This error prevents a registry contract from being bound multiple times to this storage.\",\"params\":{\"registryAddress\":\"The address of the identity registry contract that is already bound.\"}}],\"IdentityRegistryNotBound(address)\":[{\"details\":\"This error ensures that unbinding operations are only performed on currently bound registry contracts.\",\"params\":{\"registryAddress\":\"The address of the identity registry contract that was not found in the list of bound registries.\"}}],\"InvalidIdentityAddress()\":[{\"details\":\"This error ensures that all registered identities point to a valid, non-zero `IIdentity` contract address. The `IIdentity` contract holds the claims and keys related to an identity.\"}],\"InvalidIdentityRegistryAddress()\":[{\"details\":\"This error ensures that only valid, non-zero registry contract addresses can be bound to this storage contract. Binding allows a registry contract to modify data in this storage.\"}],\"InvalidIdentityWalletAddress()\":[{\"details\":\"This error ensures that every identity record in the system is linked to a valid, non-zero wallet address. A zero address typically indicates an uninitialized or invalid address in Ethereum.\"}],\"InvalidInitialization()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}],\"WalletNotAssociatedWithIdentity(address,address)\":[{\"details\":\"This error ensures that wallets can only be marked as lost for identities they are actually associated with.\",\"params\":{\"identityContract\":\"The identity contract address.\",\"userWallet\":\"The wallet address that is not associated with the identity.\"}}]},\"events\":{\"CountryModified(address,uint16)\":{\"details\":\"This event is emitted when an Identity's country has been updated.\",\"params\":{\"_country\":\"is the numeric code (ISO 3166-1) of the new country.\",\"_identityWallet\":\"is the address on which the country has been updated.\"}},\"IdentityModified(address,address)\":{\"details\":\"This event is emitted when an Identity has been updated.\",\"params\":{\"_newIdentity\":\"is the new Identity contract's.\",\"_oldIdentity\":\"is the old Identity contract's address to update.\"}},\"IdentityRegistryBound(address)\":{\"details\":\"This event is emitted when an Identity Registry is bound to the storage contract.\",\"params\":{\"_identityRegistry\":\"is the address of the identity registry added.\"}},\"IdentityRegistryUnbound(address)\":{\"details\":\"This event is emitted when an Identity Registry is unbound from the storage contract.\",\"params\":{\"_identityRegistry\":\"is the address of the identity registry removed.\"}},\"IdentityStored(address,address)\":{\"details\":\"This event is emitted when an Identity is registered into the storage contract.\",\"params\":{\"_identity\":\"` is the address of the Identity smart contract (onchainID).\",\"_investorAddress\":\"` is the address of the investor's wallet.\"}},\"IdentityUnstored(address,address)\":{\"details\":\"This event is emitted when an Identity is removed from the storage contract.\",\"params\":{\"_identity\":\"is the address of the Identity smart contract (onchainID).\",\"_investorAddress\":\"is the address of the investor's wallet.\"}},\"IdentityWalletMarkedAsLost(address,address,address)\":{\"params\":{\"identityContract\":\"The IIdentity contract associated with the user wallet.\",\"markedBy\":\"The address (typically the Identity Registry contract) that initiated this action.\",\"userWallet\":\"The user wallet address that was marked as lost.\"}},\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted to signal this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call. This account bears the admin role (for the granted role). Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"},\"WalletRecoveryLinked(address,address,address)\":{\"params\":{\"establishedBy\":\"The address that established this recovery link.\",\"lostWallet\":\"The lost wallet address.\",\"newWallet\":\"The new replacement wallet address.\"}}},\"kind\":\"dev\",\"methods\":{\"addIdentityToStorage(address,address,uint16)\":{\"details\":\"This function can only be called by an address that holds the `STORAGE_MODIFIER_ROLE`. Typically, this role is granted to `SMARTIdentityRegistry` contracts that have been \\\"bound\\\" to this storage. It performs several critical validation checks before proceeding: -   The `_userAddress` (the user's external wallet) must not be the zero address (`address(0)`). -   The `_identity` (the address of the `IIdentity` contract for the user) must not be the zero address. -   An identity for the given `_userAddress` must not already exist in the storage to prevent duplicates. If all checks pass, the function: 1.  Stores the new identity information (identity contract address and country code) in the `_identities` mapping. 2.  Adds the `_userAddress` to the `_identityWallets` array for enumeration purposes. 3.  Updates the `_identityWalletsIndex` mapping to record the position of the new address in the array (for efficient removal later). 4.  Emits an `IdentityStored` event to notify off-chain listeners about the new registration.Reverts with:      - `InvalidIdentityWalletAddress()` if `_userAddress` is `address(0)`.      - `InvalidIdentityAddress()` if `_identity` is `address(0)`.      - `IdentityAlreadyExists(_userAddress)` if an identity is already registered for `_userAddress`.\",\"params\":{\"_country\":\"The numerical country code (uint16) representing the user's jurisdiction, used for compliance.\",\"_identity\":\"The address of the `IIdentity` contract representing the user's on-chain identity. This contract would hold claims and keys for the user.\",\"_userAddress\":\"The user's external wallet address (e.g., their EOA). This is the primary key for the identity record.\"}},\"bindIdentityRegistry(address)\":{\"details\":\"This function can only be called by an address holding the `MANAGE_REGISTRIES_ROLE` (e.g., a `SMARTSystem` contract or an identity factory). It performs several checks: -   The `_identityRegistry` address must not be the zero address. -   The `_identityRegistry` must not already be bound to this storage. If the checks pass, the function: 1.  Sets `_boundIdentityRegistries[_identityRegistry]` to `true`. 2.  Adds `_identityRegistry` to the `_boundIdentityRegistryAddresses` array. 3.  Updates `_boundIdentityRegistriesIndex` for the new registry. 4.  Grants the `STORAGE_MODIFIER_ROLE` to `_identityRegistry` using the access control mechanism. 5.  Emits an `IdentityRegistryBound` event.Reverts with:      - `InvalidIdentityRegistryAddress()` if `_identityRegistry` is `address(0)`.      - `IdentityRegistryAlreadyBound(_identityRegistry)` if the registry is already bound.\",\"params\":{\"_identityRegistry\":\"The address of the `SMARTIdentityRegistry` contract to bind. This registry will then be able to call functions like `addIdentityToStorage`.\"}},\"constructor\":{\"details\":\"This constructor is part of the UUPS (Universal Upgradeable Proxy Standard) pattern. In UUPS, the logic contract (this contract) is deployed, and then a proxy contract points to it. The constructor's main job here is to initialize the `ERC2771ContextUpgradeable` with the `trustedForwarder` address. This enables meta-transaction support, allowing users to interact with the contract without directly paying gas fees in Ether, if a trusted forwarder relays their transactions. `_disableInitializers()` is called to prevent the `initialize` function (which acts like a constructor for upgradeable contracts) from being called on this logic contract directly. The `initialize` function should only be called once, typically by the deployer through the proxy contract after deployment.\",\"params\":{\"trustedForwarder\":\"The address of the trusted forwarder contract for ERC2771 meta-transactions. If this is `address(0)`, meta-transactions via a forwarder are effectively disabled for this context, and `_msgSender()` will behave like the standard `msg.sender`.\"}},\"getIdentityWallets()\":{\"details\":\"This function provides a way to enumerate all users who currently have an active identity record stored. It's useful for administrative purposes, data analysis, or for front-ends that need to display a list of all registered users.\",\"returns\":{\"_0\":\"An array of `address` types, where each address is a wallet address that has a stored identity. The array will be empty if no identities are currently registered.\"}},\"getRecoveredWalletFromStorage(address)\":{\"details\":\"This is the key function for token recovery - allows checking if caller is authorized to recover from lostWallet.\",\"params\":{\"lostWallet\":\"The lost wallet address.\"},\"returns\":{\"_0\":\"The new wallet address that replaced the lost wallet, or address(0) if not found.\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"initialize(address,address)\":{\"details\":\"This function is typically called by the deployer immediately after the proxy contract pointing to this implementation is deployed. It sets up the initial state: 1.  `__ERC165_init_unchained()`: Initializes the ERC165 interface detection mechanism, allowing other contracts     to query what interfaces this contract supports (e.g., `IERC3643IdentityRegistryStorage`). 2.  `__AccessControlEnumerable_init_unchained()`: Initializes the role-based access control system. It sets up     the structures needed to grant, revoke, and check roles. 3.  `_grantRole(DEFAULT_ADMIN_ROLE, initialAdmin)`: Grants the `DEFAULT_ADMIN_ROLE` to the `initialAdmin`     address. The admin can manage all other roles and aspects of the access control. 4.  `_grantRole(STORAGE_MODIFIER_ROLE, initialAdmin)`: Grants the `STORAGE_MODIFIER_ROLE` to the `initialAdmin`.     This is often a temporary measure for bootstrapping; the `initialAdmin` (or the `DEFAULT_ADMIN_ROLE`     holder) would typically later grant this role to operational contracts like bound identity registries and     revoke it from themselves if direct modification by the admin is not intended long-term. 5.  `_grantRole(MANAGE_REGISTRIES_ROLE, system)`: Grants the `MANAGE_REGISTRIES_ROLE` to the `system` address.     The `system` address (e.g., a `SMARTSystem` contract or an identity factory contract) is then responsible     for binding and unbinding `SMARTIdentityRegistry` contracts, which in turn modify the storage. The `initializer` modifier from `Initializable` ensures this function can only be executed once, preventing re-initialization.\",\"params\":{\"initialAdmin\":\"The address that will receive the initial `DEFAULT_ADMIN_ROLE`. This address will also receive the `STORAGE_MODIFIER_ROLE` initially, though this might be delegated later.\",\"system\":\"The address of the system-level contract (e.g., `SMARTSystem` or a factory) that will be granted the `MANAGE_REGISTRIES_ROLE`. This role allows it to control which identity registry contracts can interact with and modify the data in this storage.\"}},\"isTrustedForwarder(address)\":{\"details\":\"Indicates whether any particular address is the trusted forwarder.\"},\"isWalletMarkedAsLost(address)\":{\"details\":\"A \\\"globally lost\\\" wallet means it has been declared lost in the context of at least one identity      it was associated with.\",\"params\":{\"userWallet\":\"The user wallet address to check.\"},\"returns\":{\"_0\":\"True if the wallet has been marked as lost at least once, false otherwise.\"}},\"linkWalletRecovery(address,address)\":{\"details\":\"This creates a bidirectional mapping for token recovery purposes.\",\"params\":{\"lostWallet\":\"The lost wallet address.\",\"newWallet\":\"The new replacement wallet address.\"}},\"linkedIdentityRegistries()\":{\"details\":\"\\\"Bound\\\" means these registry contracts have been granted the `STORAGE_MODIFIER_ROLE` and are authorized to write data to this storage contract. This function provides a way to discover which registry contracts are active and can modify identity data.\",\"returns\":{\"_0\":\"An array of `address` types, where each address is that of a bound identity registry contract. The array will be empty if no registries are currently bound.\"}},\"markWalletAsLost(address,address)\":{\"details\":\"Called by an authorized Identity Registry. This indicates the wallet should no longer be considered active      for verification or operations related to this specific identity, and potentially globally.\",\"params\":{\"identityContract\":\"The IIdentity contract address to which the userWallet was associated.\",\"userWallet\":\"The user wallet address to be marked as lost.\"}},\"modifyStoredIdentity(address,address)\":{\"details\":\"This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It performs checks to ensure: -   An identity record actually exists for the given `_userAddress`. -   The new `_identity` contract address is not the zero address. If both checks pass, it updates the `identityContract` field within the `Identity` struct stored for the `_userAddress` in the `_identities` mapping. Finally, it emits an `IdentityModified` event, providing both the old and new `IIdentity` contract addresses.Reverts with:      - `IdentityDoesNotExist(_userAddress)` if no identity record is found for `_userAddress`.      - `InvalidIdentityAddress()` if the new `_identity` address is `address(0)`.\",\"params\":{\"_identity\":\"The new `IIdentity` contract address to associate with the `_userAddress`.\",\"_userAddress\":\"The user's external wallet address whose associated `IIdentity` contract is to be updated.\"}},\"modifyStoredInvestorCountry(address,uint16)\":{\"details\":\"This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It first checks if an identity record exists for the given `_userAddress`. If not, it reverts. If the identity exists, it updates the `country` field within the `Identity` struct stored for the `_userAddress` in the `_identities` mapping with the new `_country` code. Finally, it emits a `CountryModified` event, providing the `_userAddress` and the new `_country` code.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for `_userAddress`.\",\"params\":{\"_country\":\"The new numerical country code (uint16) to associate with the `_userAddress`.\",\"_userAddress\":\"The user's external wallet address whose associated country code is to be updated.\"}},\"removeIdentityFromStorage(address)\":{\"details\":\"This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It first checks if an identity actually exists for the given `_userAddress`. If not, it reverts. If the identity exists, it performs the following actions: 1.  Retrieves the `IIdentity` contract address associated with the user to include in the event. 2.  Removes the `_userAddress` from the `_identityWallets` array using the \\\"swap-and-pop\\\" technique. This is an     O(1) operation:     a.  It finds the index of `_userAddress` using `_identityWalletsIndex`.     b.  It takes the last wallet address from the `_identityWallets` array.     c.  If the address to remove is not the last one, it moves the last address into the slot of the address being removed.     d.  It updates `_identityWalletsIndex` for the moved address.     e.  It then shortens the `_identityWallets` array by one (pop). 3.  Deletes the entry for `_userAddress` from the `_identityWalletsIndex` mapping. 4.  Deletes the entry for `_userAddress` from the main `_identities` mapping. 5.  Emits an `IdentityUnstored` event to notify off-chain listeners.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for the `_userAddress`.\",\"params\":{\"_userAddress\":\"The user's external wallet address whose identity record is to be removed.\"}},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"storedIdentity(address)\":{\"details\":\"This function performs a direct lookup in the `_identities` mapping. It first checks if an `identityContract` is stored for the `_userAddress` (i.e., it's not `address(0)`). If no identity contract is found (meaning the `_userAddress` is not registered or has been removed), the function reverts with the `IdentityDoesNotExist` error.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for the `_userAddress`.\",\"params\":{\"_userAddress\":\"The user's external wallet address for which to retrieve the associated `IIdentity` contract.\"},\"returns\":{\"_0\":\"The `IIdentity` contract address linked to the `_userAddress`. This is returned as an `IIdentity` type for type safety, but it's fundamentally an address.\"}},\"storedInvestorCountry(address)\":{\"details\":\"This function performs a direct lookup in the `_identities` mapping for the given `_userAddress`. It first checks if an `identityContract` is associated with the `_userAddress`. This is a crucial check because a country code should only be considered valid if there's an active identity registration. If no `identityContract` is found (i.e., the address is `address(0)`), it implies the user is not registered or their identity has been removed, so the function reverts with `IdentityDoesNotExist`. If an identity contract exists, the function returns the `country` field from the `Identity` struct.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record (specifically, no identity contract) is found for the `_userAddress`.\",\"params\":{\"_userAddress\":\"The user's external wallet address for which to retrieve the associated country code.\"},\"returns\":{\"_0\":\"The `uint16` country code associated with the `_userAddress`.\"}},\"supportsInterface(bytes4)\":{\"details\":\"This function allows other contracts or off-chain tools to query if this contract implements specific interfaces. It checks if the `interfaceId` matches: 1.  `type(ISMARTIdentityRegistryStorage).interfaceId`: This confirms that the contract adheres to the     standard interface for ERC-3643 compliant identity registry storage. 2.  Any interfaces supported by its parent contracts (e.g., `AccessControlUpgradeable`,     `ERC165Upgradeable` itself) by calling `super.supportsInterface(interfaceId)`. This is crucial for interoperability within the ecosystem, allowing, for example, a `SMARTIdentityRegistry` to verify that it's interacting with a compatible storage contract.\",\"params\":{\"interfaceId\":\"The EIP-165 interface identifier (a `bytes4` value) to check for support.\"},\"returns\":{\"_0\":\"`true` if the contract supports the specified `interfaceId`, `false` otherwise.\"}},\"trustedForwarder()\":{\"details\":\"Returns the address of the trusted forwarder.\"},\"unbindIdentityRegistry(address)\":{\"details\":\"This function can only be called by an address holding the `MANAGE_REGISTRIES_ROLE`. It first checks if the `_identityRegistry` is currently bound. If not, it reverts. If the registry is bound, the function: 1.  Revokes the `STORAGE_MODIFIER_ROLE` from `_identityRegistry`. 2.  Removes `_identityRegistry` from the `_boundIdentityRegistryAddresses` array using the \\\"swap-and-pop\\\" technique (O(1) complexity). 3.  Updates `_boundIdentityRegistriesIndex` accordingly. 4.  Sets `_boundIdentityRegistries[_identityRegistry]` to `false`. 5.  Emits an `IdentityRegistryUnbound` event.Reverts with `IdentityRegistryNotBound(_identityRegistry)` if the registry is not currently bound.\",\"params\":{\"_identityRegistry\":\"The address of the `SMARTIdentityRegistry` contract to unbind. This registry will no longer be able to modify storage data.\"}}},\"stateVariables\":{\"_boundIdentityRegistries\":{\"details\":\"If `_boundIdentityRegistries[registryAddress]` is `true`, it means the `registryAddress` has been granted the `STORAGE_MODIFIER_ROLE`. If `false`, it cannot. This provides a quick way to check the binding status of a registry without querying the access control system directly, though the access control system is the ultimate source of truth for permissions.\"},\"_boundIdentityRegistriesIndex\":{\"details\":\"This works the same way as `_identityWalletsIndex` but for the `_boundIdentityRegistryAddresses` array. It enables O(1) complexity for removing a registry address from `_boundIdentityRegistryAddresses` using the swap-and-pop technique. Storing `index + 1` helps distinguish non-existence (0) from an actual index of 0.\"},\"_boundIdentityRegistryAddresses\":{\"details\":\"\\\"Binding\\\" means that these registry contracts have been granted the `STORAGE_MODIFIER_ROLE` and are authorized to write data to this storage contract. This array allows for iterating over all such authorized registries, for example, to display a list of active identity providers. Similar to `_identityWallets`, this array is managed alongside `_boundIdentityRegistriesIndex` for efficient additions and removals.\"},\"_identities\":{\"details\":\"This is the primary data structure where identity information is stored. The key (`address wallet`) is the public wallet address of the user (e.g., their MetaMask address). The value (`Identity identity`) is the struct containing the address of their `IIdentity` contract, their country code, and recovery information. Example: `_identities[0xUserWalletAddress] = Identity(0xIdentityContractAddress, 840, address(0))` (840 for USA).\"},\"_identityWallets\":{\"details\":\"This array allows for iterating over all registered identities, which can be useful for administrative tasks, data export, or informational queries (e.g., \\\"how many users are registered?\\\"). It is managed in conjunction with `_identityWalletsIndex` to allow for efficient addition and removal (O(1) for removal using the swap-and-pop technique).\"},\"_identityWalletsIndex\":{\"details\":\"This mapping is a crucial optimization for removing an address from the `_identityWallets` array. Instead of iterating through the array to find the address to remove (which would be O(n) complexity), this mapping provides the index directly (O(1) lookup). We store `index + 1` because the default value for a mapping entry is 0. If we stored the actual 0-based index, we wouldn't be able to distinguish between an address at index 0 and an address that is not in the array. So, a value of `0` here means the address is not in `_identityWallets`. A value of `1` means it's at index `0`, etc.\"},\"_lostWallets\":{\"details\":\"This provides a clean boolean check for wallet lost status without overloading other fields\"}},\"title\":\"ATK Identity Registry Storage Implementation\",\"version\":1},\"userdoc\":{\"errors\":{\"IdentityAlreadyExists(address)\":[{\"notice\":\"Error triggered when attempting to add an identity to storage for a user address that already has an identity registered.\"}],\"IdentityDoesNotExist(address)\":[{\"notice\":\"Error triggered when attempting to operate on (e.g., modify, remove) an identity for a user address that is not registered.\"}],\"IdentityRegistryAlreadyBound(address)\":[{\"notice\":\"Error triggered when attempting to bind an identity registry contract that is already bound to this storage.\"}],\"IdentityRegistryNotBound(address)\":[{\"notice\":\"Error triggered when attempting to unbind an identity registry contract that is not currently bound to this storage.\"}],\"InvalidIdentityAddress()\":[{\"notice\":\"Error triggered if an attempt is made to register or associate an identity contract that has a zero address.\"}],\"InvalidIdentityRegistryAddress()\":[{\"notice\":\"Error triggered if an attempt is made to bind an identity registry contract that has a zero address.\"}],\"InvalidIdentityWalletAddress()\":[{\"notice\":\"Error triggered if an attempt is made to register or operate on an identity with a zero address for the user's wallet.\"}],\"WalletNotAssociatedWithIdentity(address,address)\":[{\"notice\":\"Error triggered when attempting to mark a wallet as lost for an identity that is not associated with that wallet.\"}]},\"events\":{\"IdentityWalletMarkedAsLost(address,address,address)\":{\"notice\":\"Emitted when a user wallet is marked as lost for a specific identity contract within the storage.\"},\"WalletRecoveryLinked(address,address,address)\":{\"notice\":\"Emitted when a wallet recovery link is established between a lost wallet and its replacement.\"}},\"kind\":\"user\",\"methods\":{\"addIdentityToStorage(address,address,uint16)\":{\"notice\":\"Adds a new identity record to the storage, linking a user's wallet address to their identity contract and country code.\"},\"bindIdentityRegistry(address)\":{\"notice\":\"Authorizes a `SMARTIdentityRegistry` contract to modify data in this storage contract. This is achieved by granting the `STORAGE_MODIFIER_ROLE` to the specified registry address.\"},\"constructor\":{\"notice\":\"Constructor for the `SMARTIdentityRegistryStorageImplementation`.\"},\"getIdentityWallets()\":{\"notice\":\"Returns an array of all wallet addresses that have a registered identity in this storage contract.\"},\"getRecoveredWalletFromStorage(address)\":{\"notice\":\"Gets the new wallet address that replaced a lost wallet during recovery.\"},\"initialize(address,address)\":{\"notice\":\"Initializes the `SMARTIdentityRegistryStorageImplementation` contract. This function acts as the constructor for an upgradeable contract and can only be called once.\"},\"isWalletMarkedAsLost(address)\":{\"notice\":\"Checks if a user wallet is globally marked as lost in the storage.\"},\"linkWalletRecovery(address,address)\":{\"notice\":\"Establishes a recovery link between a lost wallet and its replacement.\"},\"linkedIdentityRegistries()\":{\"notice\":\"Returns an array of addresses of all `SMARTIdentityRegistry` contracts currently bound to this storage.\"},\"markWalletAsLost(address,address)\":{\"notice\":\"Marks a user wallet as lost for a specific identity contract in the storage.\"},\"modifyStoredIdentity(address,address)\":{\"notice\":\"Modifies the `IIdentity` contract address associated with an existing identity record.\"},\"modifyStoredInvestorCountry(address,uint16)\":{\"notice\":\"Modifies the country code associated with an existing identity record.\"},\"removeIdentityFromStorage(address)\":{\"notice\":\"Removes an existing identity record from the storage based on the user's wallet address.\"},\"storedIdentity(address)\":{\"notice\":\"Retrieves the `IIdentity` contract address associated with a registered user's wallet address.\"},\"storedInvestorCountry(address)\":{\"notice\":\"Retrieves the numerical country code associated with a registered user's wallet address.\"},\"supportsInterface(bytes4)\":{\"notice\":\"Indicates whether this contract supports a given interface ID, as per the ERC165 standard.\"},\"unbindIdentityRegistry(address)\":{\"notice\":\"Revokes the authorization for a `SMARTIdentityRegistry` contract to modify data in this storage. This is achieved by revoking the `STORAGE_MODIFIER_ROLE` from the specified registry address.\"}},\"notice\":\"This contract is the core logic for storing and managing identity-related data for the ATK Protocol. It acts as a persistent data layer for `ATKIdentityRegistry` contracts, which handle the business logic of identity registration and verification. This separation allows the storage logic to be upgraded independently.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/system/identity-registry-storage/ATKIdentityRegistryStorageImplementation.sol\":\"ATKIdentityRegistryStorageImplementation\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@onchainid-v2.2.1/=dependencies/@onchainid-v2.2.1/contracts/\",\":@onchainid/contracts/=dependencies/@onchainid-v2.2.1/contracts/\",\":@openzeppelin-contracts-5.3.0/=dependencies/@openzeppelin-contracts-5.3.0/\",\":@openzeppelin-contracts-upgradeable-5.3.0/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/\",\":@openzeppelin/contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/\",\":@openzeppelin/contracts/=dependencies/@openzeppelin-contracts-5.3.0/\",\":forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/\",\":forge-std/=dependencies/forge-std-1.9.7/src/\"],\"viaIR\":true},\"sources\":{\"contracts/smart/interface/ERC-3643/IERC3643IdentityRegistryStorage.sol\":{\"keccak256\":\"0x3a8a72df8da5bf4d988bbfb00151b933ff17cdc8d4be47dc121cd9e2083ba86f\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://369250658bf8d3ebb583946820afa494271ce6bfde607d15c7060cdf7a303cf3\",\"dweb:/ipfs/QmSJjaK6vyv8K9RX1k3rwxsoKfVNyMoHEszxyxdTQfDKQG\"]},\"contracts/smart/interface/ISMARTIdentityRegistryStorage.sol\":{\"keccak256\":\"0x219b3d03958859e2f082aac5cbf3b40acf243e326ee6e74e6bb03be7724c2985\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://8cf8d30ec47cb2aed5b51d373837584fb6f08deab1d35142510271e733404f52\",\"dweb:/ipfs/Qmc9NnABx9ouhhCR8qgJC3RtU5oAyycSjZkY6nGtuWFwuz\"]},\"contracts/system/ATKSystemRoles.sol\":{\"keccak256\":\"0x7c5a50fcea7ee061d1bf5451217fbf83cfbc42cae638a0de4b8fc41fa5d7d980\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://8dc4128ddb017dfd71ff70bd4b292bcf5e60ae6f81a07b1ceb15439607bb93c0\",\"dweb:/ipfs/QmWJpzgR3YuLvRXZPdFzvyZ1mHAyV3fhSUMcdFG4QJ3xzx\"]},\"contracts/system/identity-registry-storage/ATKIdentityRegistryStorageImplementation.sol\":{\"keccak256\":\"0x793b1dc12562d43f7e465733845f90929ee53ba25c1e551fa28158ee1f786517\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://02f711d3fab46fa4f8c0e83fc7d6b4823f0f4972fad9e638232841713315713b\",\"dweb:/ipfs/QmP1ADN9xPHb9vnKXQJFL12TeXJWXiWK7mBGv6dgYWsYeK\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IERC734.sol\":{\"keccak256\":\"0x35a14a0d1a3ed51689f1a2cb12e26d30601afbcc1cc9b9b288a03cd11e6d049e\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://156aac402e73e6bd2fa8c0ccd85b2add8d1bb505d8a652218173dbc8e7b9a3cb\",\"dweb:/ipfs/QmPzPyc3kKxoNCGqKAooUju6YvMkDN4MCUH198TEXnA82o\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IERC735.sol\":{\"keccak256\":\"0xeac82c37b16c1c1c83df3e88be987332b1230ed13e1d017f9d2929f978ac0122\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://695a66b789ac417b7b2b78c578981779db374704382921ff499351cccab0323e\",\"dweb:/ipfs/QmeZoogvsEWf688Z849zZ2dLPDnor6YnnNQLMgedY9Tc9D\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IIdentity.sol\":{\"keccak256\":\"0x5ed42ab81b9b734c79e61d1f7e0734baab5479a356ab6bb469414d3c66269862\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://a0863999b1ed334179a43e699e6057815eea011a78ed51e61b6110fc392e26f8\",\"dweb:/ipfs/Qme6hdHZCAy1V4sLgAZ5NxdrEjEf5mYMabf5UDmUDjkuzW\"]},\"dependencies/@openzeppelin-contracts-5.3.0/access/IAccessControl.sol\":{\"keccak256\":\"0x4d9a2b261b56a1e4a37bb038151dec98b952fed16de2bdfdda27e38e2b12b530\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f724110f7aeb6151af800ab8c12e6060b29bda9e013f0ccb331eb754d6a7cbf0\",\"dweb:/ipfs/QmUcjzCZpxtUPdEThtAzE1f9LvuJiUGZxTdH9N6bHrb5Cf\"]},\"dependencies/@openzeppelin-contracts-5.3.0/utils/introspection/IERC165.sol\":{\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f6fda447a62815e8064f47eff0dd1cf58d9207ad69b5d32280f8d7ed1d1e4621\",\"dweb:/ipfs/QmfDRc7pxfaXB2Dh9np5Uf29Na3pQ7tafRS684wd3GLjVL\"]},\"dependencies/@openzeppelin-contracts-upgradeable-5.3.0/access/AccessControlUpgradeable.sol\":{\"keccak256\":\"0x0d4d7d19a052a2ef9d17b28450133631188b895e1755747fa8ad0280aadfb534\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://838551e10cc07e570b70aee1078e490658d3a0ab8f4adfd4f3f2a565200753da\",\"dweb:/ipfs/QmceT7R3Pqzywyxr3MSEA7VXU4axZAPS6BLy92iV97rGdG\"]},\"dependencies/@openzeppelin-contracts-upgradeable-5.3.0/metatx/ERC2771ContextUpgradeable.sol\":{\"keccak256\":\"0x290ba719fd784ff406a8de038c10dc2d0914794c8b016781712fcbb36ca7bffb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://8b5764ef1dab80c115c14e307c5cbd5845320a653a2d8a3658d20dfba6bc7758\",\"dweb:/ipfs/QmSPSasRTVtYyAEnEVCBPZwoQzgKU7gu7q8NeT9AMMpmmx\"]},\"dependencies/@openzeppelin-contracts-upgradeable-5.3.0/proxy/utils/Initializable.sol\":{\"keccak256\":\"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ab7b6d5b9e2b88176312967fe0f0e78f3d9a1422fa5e4b64e2440c35869b5d08\",\"dweb:/ipfs/QmXKYWWyzcLg1B2k7Sb1qkEXgLCYfXecR9wYW5obRzWP1Q\"]},\"dependencies/@openzeppelin-contracts-upgradeable-5.3.0/utils/ContextUpgradeable.sol\":{\"keccak256\":\"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://08e39f23d5b4692f9a40803e53a8156b72b4c1f9902a88cd65ba964db103dab9\",\"dweb:/ipfs/QmPKn6EYDgpga7KtpkA8wV2yJCYGMtc9K4LkJfhKX2RVSV\"]},\"dependencies/@openzeppelin-contracts-upgradeable-5.3.0/utils/introspection/ERC165Upgradeable.sol\":{\"keccak256\":\"0xc8ed8d2056934b7675b695dec032f2920c2f5c6cf33a17ca85650940675323ab\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3c8ccc75d1cd792d192aa09e54dd49ea35fe85baa9fcd17486f29227d9f29b89\",\"dweb:/ipfs/QmbboSbFUEiM9tdEgBwuTRb7bykFoJXZ7dsSr1PSREJXMr\"]}},\"version\":1}",
  "metadata": {
    "compiler": {
      "version": "0.8.28+commit.7893614a"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "trustedForwarder",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "AccessControlBadConfirmation"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "neededRole",
              "type": "bytes32"
            }
          ],
          "type": "error",
          "name": "AccessControlUnauthorizedAccount"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            }
          ],
          "type": "error",
          "name": "IdentityAlreadyExists"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            }
          ],
          "type": "error",
          "name": "IdentityDoesNotExist"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "registryAddress",
              "type": "address"
            }
          ],
          "type": "error",
          "name": "IdentityRegistryAlreadyBound"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "registryAddress",
              "type": "address"
            }
          ],
          "type": "error",
          "name": "IdentityRegistryNotBound"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "InvalidIdentityAddress"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "InvalidIdentityRegistryAddress"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "InvalidIdentityWalletAddress"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "InvalidInitialization"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "NotInitializing"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "identityContract",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "userWallet",
              "type": "address"
            }
          ],
          "type": "error",
          "name": "WalletNotAssociatedWithIdentity"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_identityWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint16",
              "name": "_country",
              "type": "uint16",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "CountryModified",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "contract IIdentity",
              "name": "_oldIdentity",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "contract IIdentity",
              "name": "_newIdentity",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "IdentityModified",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_identityRegistry",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "IdentityRegistryBound",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_identityRegistry",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "IdentityRegistryUnbound",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_investorAddress",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "contract IIdentity",
              "name": "_identity",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "IdentityStored",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_investorAddress",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "contract IIdentity",
              "name": "_identity",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "IdentityUnstored",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "identityContract",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "userWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "markedBy",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "IdentityWalletMarkedAsLost",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "uint64",
              "name": "version",
              "type": "uint64",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "Initialized",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32",
              "indexed": true
            },
            {
              "internalType": "bytes32",
              "name": "previousAdminRole",
              "type": "bytes32",
              "indexed": true
            },
            {
              "internalType": "bytes32",
              "name": "newAdminRole",
              "type": "bytes32",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "RoleAdminChanged",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "RoleGranted",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "RoleRevoked",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "lostWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "newWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "establishedBy",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "WalletRecoveryLinked",
          "anonymous": false
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "DEFAULT_ADMIN_ROLE",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            },
            {
              "internalType": "contract IIdentity",
              "name": "_identity",
              "type": "address"
            },
            {
              "internalType": "uint16",
              "name": "_country",
              "type": "uint16"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addIdentityToStorage"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_identityRegistry",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "bindIdentityRegistry"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "getIdentityWallets",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "lostWallet",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "getRecoveredWalletFromStorage",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "getRoleAdmin",
          "outputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "grantRole"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "hasRole",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "system",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "initialAdmin",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "forwarder",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "isTrustedForwarder",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userWallet",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "isWalletMarkedAsLost",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "lostWallet",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "newWallet",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "linkWalletRecovery"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "linkedIdentityRegistries",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "identityContract",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "userWallet",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "markWalletAsLost"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            },
            {
              "internalType": "contract IIdentity",
              "name": "_identity",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyStoredIdentity"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            },
            {
              "internalType": "uint16",
              "name": "_country",
              "type": "uint16"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "modifyStoredInvestorCountry"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeIdentityFromStorage"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "callerConfirmation",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "renounceRole"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "revokeRole"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "storedIdentity",
          "outputs": [
            {
              "internalType": "contract IIdentity",
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "storedInvestorCountry",
          "outputs": [
            {
              "internalType": "uint16",
              "name": "",
              "type": "uint16"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "bytes4",
              "name": "interfaceId",
              "type": "bytes4"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "supportsInterface",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "trustedForwarder",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_identityRegistry",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "unbindIdentityRegistry"
        }
      ],
      "devdoc": {
        "kind": "dev",
        "methods": {
          "addIdentityToStorage(address,address,uint16)": {
            "details": "This function can only be called by an address that holds the `STORAGE_MODIFIER_ROLE`. Typically, this role is granted to `SMARTIdentityRegistry` contracts that have been \"bound\" to this storage. It performs several critical validation checks before proceeding: -   The `_userAddress` (the user's external wallet) must not be the zero address (`address(0)`). -   The `_identity` (the address of the `IIdentity` contract for the user) must not be the zero address. -   An identity for the given `_userAddress` must not already exist in the storage to prevent duplicates. If all checks pass, the function: 1.  Stores the new identity information (identity contract address and country code) in the `_identities` mapping. 2.  Adds the `_userAddress` to the `_identityWallets` array for enumeration purposes. 3.  Updates the `_identityWalletsIndex` mapping to record the position of the new address in the array (for efficient removal later). 4.  Emits an `IdentityStored` event to notify off-chain listeners about the new registration.Reverts with:      - `InvalidIdentityWalletAddress()` if `_userAddress` is `address(0)`.      - `InvalidIdentityAddress()` if `_identity` is `address(0)`.      - `IdentityAlreadyExists(_userAddress)` if an identity is already registered for `_userAddress`.",
            "params": {
              "_country": "The numerical country code (uint16) representing the user's jurisdiction, used for compliance.",
              "_identity": "The address of the `IIdentity` contract representing the user's on-chain identity. This contract would hold claims and keys for the user.",
              "_userAddress": "The user's external wallet address (e.g., their EOA). This is the primary key for the identity record."
            }
          },
          "bindIdentityRegistry(address)": {
            "details": "This function can only be called by an address holding the `MANAGE_REGISTRIES_ROLE` (e.g., a `SMARTSystem` contract or an identity factory). It performs several checks: -   The `_identityRegistry` address must not be the zero address. -   The `_identityRegistry` must not already be bound to this storage. If the checks pass, the function: 1.  Sets `_boundIdentityRegistries[_identityRegistry]` to `true`. 2.  Adds `_identityRegistry` to the `_boundIdentityRegistryAddresses` array. 3.  Updates `_boundIdentityRegistriesIndex` for the new registry. 4.  Grants the `STORAGE_MODIFIER_ROLE` to `_identityRegistry` using the access control mechanism. 5.  Emits an `IdentityRegistryBound` event.Reverts with:      - `InvalidIdentityRegistryAddress()` if `_identityRegistry` is `address(0)`.      - `IdentityRegistryAlreadyBound(_identityRegistry)` if the registry is already bound.",
            "params": {
              "_identityRegistry": "The address of the `SMARTIdentityRegistry` contract to bind. This registry will then be able to call functions like `addIdentityToStorage`."
            }
          },
          "constructor": {
            "details": "This constructor is part of the UUPS (Universal Upgradeable Proxy Standard) pattern. In UUPS, the logic contract (this contract) is deployed, and then a proxy contract points to it. The constructor's main job here is to initialize the `ERC2771ContextUpgradeable` with the `trustedForwarder` address. This enables meta-transaction support, allowing users to interact with the contract without directly paying gas fees in Ether, if a trusted forwarder relays their transactions. `_disableInitializers()` is called to prevent the `initialize` function (which acts like a constructor for upgradeable contracts) from being called on this logic contract directly. The `initialize` function should only be called once, typically by the deployer through the proxy contract after deployment.",
            "params": {
              "trustedForwarder": "The address of the trusted forwarder contract for ERC2771 meta-transactions. If this is `address(0)`, meta-transactions via a forwarder are effectively disabled for this context, and `_msgSender()` will behave like the standard `msg.sender`."
            }
          },
          "getIdentityWallets()": {
            "details": "This function provides a way to enumerate all users who currently have an active identity record stored. It's useful for administrative purposes, data analysis, or for front-ends that need to display a list of all registered users.",
            "returns": {
              "_0": "An array of `address` types, where each address is a wallet address that has a stored identity. The array will be empty if no identities are currently registered."
            }
          },
          "getRecoveredWalletFromStorage(address)": {
            "details": "This is the key function for token recovery - allows checking if caller is authorized to recover from lostWallet.",
            "params": {
              "lostWallet": "The lost wallet address."
            },
            "returns": {
              "_0": "The new wallet address that replaced the lost wallet, or address(0) if not found."
            }
          },
          "getRoleAdmin(bytes32)": {
            "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
          },
          "grantRole(bytes32,address)": {
            "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."
          },
          "hasRole(bytes32,address)": {
            "details": "Returns `true` if `account` has been granted `role`."
          },
          "initialize(address,address)": {
            "details": "This function is typically called by the deployer immediately after the proxy contract pointing to this implementation is deployed. It sets up the initial state: 1.  `__ERC165_init_unchained()`: Initializes the ERC165 interface detection mechanism, allowing other contracts     to query what interfaces this contract supports (e.g., `IERC3643IdentityRegistryStorage`). 2.  `__AccessControlEnumerable_init_unchained()`: Initializes the role-based access control system. It sets up     the structures needed to grant, revoke, and check roles. 3.  `_grantRole(DEFAULT_ADMIN_ROLE, initialAdmin)`: Grants the `DEFAULT_ADMIN_ROLE` to the `initialAdmin`     address. The admin can manage all other roles and aspects of the access control. 4.  `_grantRole(STORAGE_MODIFIER_ROLE, initialAdmin)`: Grants the `STORAGE_MODIFIER_ROLE` to the `initialAdmin`.     This is often a temporary measure for bootstrapping; the `initialAdmin` (or the `DEFAULT_ADMIN_ROLE`     holder) would typically later grant this role to operational contracts like bound identity registries and     revoke it from themselves if direct modification by the admin is not intended long-term. 5.  `_grantRole(MANAGE_REGISTRIES_ROLE, system)`: Grants the `MANAGE_REGISTRIES_ROLE` to the `system` address.     The `system` address (e.g., a `SMARTSystem` contract or an identity factory contract) is then responsible     for binding and unbinding `SMARTIdentityRegistry` contracts, which in turn modify the storage. The `initializer` modifier from `Initializable` ensures this function can only be executed once, preventing re-initialization.",
            "params": {
              "initialAdmin": "The address that will receive the initial `DEFAULT_ADMIN_ROLE`. This address will also receive the `STORAGE_MODIFIER_ROLE` initially, though this might be delegated later.",
              "system": "The address of the system-level contract (e.g., `SMARTSystem` or a factory) that will be granted the `MANAGE_REGISTRIES_ROLE`. This role allows it to control which identity registry contracts can interact with and modify the data in this storage."
            }
          },
          "isTrustedForwarder(address)": {
            "details": "Indicates whether any particular address is the trusted forwarder."
          },
          "isWalletMarkedAsLost(address)": {
            "details": "A \"globally lost\" wallet means it has been declared lost in the context of at least one identity      it was associated with.",
            "params": {
              "userWallet": "The user wallet address to check."
            },
            "returns": {
              "_0": "True if the wallet has been marked as lost at least once, false otherwise."
            }
          },
          "linkWalletRecovery(address,address)": {
            "details": "This creates a bidirectional mapping for token recovery purposes.",
            "params": {
              "lostWallet": "The lost wallet address.",
              "newWallet": "The new replacement wallet address."
            }
          },
          "linkedIdentityRegistries()": {
            "details": "\"Bound\" means these registry contracts have been granted the `STORAGE_MODIFIER_ROLE` and are authorized to write data to this storage contract. This function provides a way to discover which registry contracts are active and can modify identity data.",
            "returns": {
              "_0": "An array of `address` types, where each address is that of a bound identity registry contract. The array will be empty if no registries are currently bound."
            }
          },
          "markWalletAsLost(address,address)": {
            "details": "Called by an authorized Identity Registry. This indicates the wallet should no longer be considered active      for verification or operations related to this specific identity, and potentially globally.",
            "params": {
              "identityContract": "The IIdentity contract address to which the userWallet was associated.",
              "userWallet": "The user wallet address to be marked as lost."
            }
          },
          "modifyStoredIdentity(address,address)": {
            "details": "This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It performs checks to ensure: -   An identity record actually exists for the given `_userAddress`. -   The new `_identity` contract address is not the zero address. If both checks pass, it updates the `identityContract` field within the `Identity` struct stored for the `_userAddress` in the `_identities` mapping. Finally, it emits an `IdentityModified` event, providing both the old and new `IIdentity` contract addresses.Reverts with:      - `IdentityDoesNotExist(_userAddress)` if no identity record is found for `_userAddress`.      - `InvalidIdentityAddress()` if the new `_identity` address is `address(0)`.",
            "params": {
              "_identity": "The new `IIdentity` contract address to associate with the `_userAddress`.",
              "_userAddress": "The user's external wallet address whose associated `IIdentity` contract is to be updated."
            }
          },
          "modifyStoredInvestorCountry(address,uint16)": {
            "details": "This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It first checks if an identity record exists for the given `_userAddress`. If not, it reverts. If the identity exists, it updates the `country` field within the `Identity` struct stored for the `_userAddress` in the `_identities` mapping with the new `_country` code. Finally, it emits a `CountryModified` event, providing the `_userAddress` and the new `_country` code.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for `_userAddress`.",
            "params": {
              "_country": "The new numerical country code (uint16) to associate with the `_userAddress`.",
              "_userAddress": "The user's external wallet address whose associated country code is to be updated."
            }
          },
          "removeIdentityFromStorage(address)": {
            "details": "This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It first checks if an identity actually exists for the given `_userAddress`. If not, it reverts. If the identity exists, it performs the following actions: 1.  Retrieves the `IIdentity` contract address associated with the user to include in the event. 2.  Removes the `_userAddress` from the `_identityWallets` array using the \"swap-and-pop\" technique. This is an     O(1) operation:     a.  It finds the index of `_userAddress` using `_identityWalletsIndex`.     b.  It takes the last wallet address from the `_identityWallets` array.     c.  If the address to remove is not the last one, it moves the last address into the slot of the address being removed.     d.  It updates `_identityWalletsIndex` for the moved address.     e.  It then shortens the `_identityWallets` array by one (pop). 3.  Deletes the entry for `_userAddress` from the `_identityWalletsIndex` mapping. 4.  Deletes the entry for `_userAddress` from the main `_identities` mapping. 5.  Emits an `IdentityUnstored` event to notify off-chain listeners.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for the `_userAddress`.",
            "params": {
              "_userAddress": "The user's external wallet address whose identity record is to be removed."
            }
          },
          "renounceRole(bytes32,address)": {
            "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."
          },
          "revokeRole(bytes32,address)": {
            "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."
          },
          "storedIdentity(address)": {
            "details": "This function performs a direct lookup in the `_identities` mapping. It first checks if an `identityContract` is stored for the `_userAddress` (i.e., it's not `address(0)`). If no identity contract is found (meaning the `_userAddress` is not registered or has been removed), the function reverts with the `IdentityDoesNotExist` error.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for the `_userAddress`.",
            "params": {
              "_userAddress": "The user's external wallet address for which to retrieve the associated `IIdentity` contract."
            },
            "returns": {
              "_0": "The `IIdentity` contract address linked to the `_userAddress`. This is returned as an `IIdentity` type for type safety, but it's fundamentally an address."
            }
          },
          "storedInvestorCountry(address)": {
            "details": "This function performs a direct lookup in the `_identities` mapping for the given `_userAddress`. It first checks if an `identityContract` is associated with the `_userAddress`. This is a crucial check because a country code should only be considered valid if there's an active identity registration. If no `identityContract` is found (i.e., the address is `address(0)`), it implies the user is not registered or their identity has been removed, so the function reverts with `IdentityDoesNotExist`. If an identity contract exists, the function returns the `country` field from the `Identity` struct.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record (specifically, no identity contract) is found for the `_userAddress`.",
            "params": {
              "_userAddress": "The user's external wallet address for which to retrieve the associated country code."
            },
            "returns": {
              "_0": "The `uint16` country code associated with the `_userAddress`."
            }
          },
          "supportsInterface(bytes4)": {
            "details": "This function allows other contracts or off-chain tools to query if this contract implements specific interfaces. It checks if the `interfaceId` matches: 1.  `type(ISMARTIdentityRegistryStorage).interfaceId`: This confirms that the contract adheres to the     standard interface for ERC-3643 compliant identity registry storage. 2.  Any interfaces supported by its parent contracts (e.g., `AccessControlUpgradeable`,     `ERC165Upgradeable` itself) by calling `super.supportsInterface(interfaceId)`. This is crucial for interoperability within the ecosystem, allowing, for example, a `SMARTIdentityRegistry` to verify that it's interacting with a compatible storage contract.",
            "params": {
              "interfaceId": "The EIP-165 interface identifier (a `bytes4` value) to check for support."
            },
            "returns": {
              "_0": "`true` if the contract supports the specified `interfaceId`, `false` otherwise."
            }
          },
          "trustedForwarder()": {
            "details": "Returns the address of the trusted forwarder."
          },
          "unbindIdentityRegistry(address)": {
            "details": "This function can only be called by an address holding the `MANAGE_REGISTRIES_ROLE`. It first checks if the `_identityRegistry` is currently bound. If not, it reverts. If the registry is bound, the function: 1.  Revokes the `STORAGE_MODIFIER_ROLE` from `_identityRegistry`. 2.  Removes `_identityRegistry` from the `_boundIdentityRegistryAddresses` array using the \"swap-and-pop\" technique (O(1) complexity). 3.  Updates `_boundIdentityRegistriesIndex` accordingly. 4.  Sets `_boundIdentityRegistries[_identityRegistry]` to `false`. 5.  Emits an `IdentityRegistryUnbound` event.Reverts with `IdentityRegistryNotBound(_identityRegistry)` if the registry is not currently bound.",
            "params": {
              "_identityRegistry": "The address of the `SMARTIdentityRegistry` contract to unbind. This registry will no longer be able to modify storage data."
            }
          }
        },
        "version": 1
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "addIdentityToStorage(address,address,uint16)": {
            "notice": "Adds a new identity record to the storage, linking a user's wallet address to their identity contract and country code."
          },
          "bindIdentityRegistry(address)": {
            "notice": "Authorizes a `SMARTIdentityRegistry` contract to modify data in this storage contract. This is achieved by granting the `STORAGE_MODIFIER_ROLE` to the specified registry address."
          },
          "constructor": {
            "notice": "Constructor for the `SMARTIdentityRegistryStorageImplementation`."
          },
          "getIdentityWallets()": {
            "notice": "Returns an array of all wallet addresses that have a registered identity in this storage contract."
          },
          "getRecoveredWalletFromStorage(address)": {
            "notice": "Gets the new wallet address that replaced a lost wallet during recovery."
          },
          "initialize(address,address)": {
            "notice": "Initializes the `SMARTIdentityRegistryStorageImplementation` contract. This function acts as the constructor for an upgradeable contract and can only be called once."
          },
          "isWalletMarkedAsLost(address)": {
            "notice": "Checks if a user wallet is globally marked as lost in the storage."
          },
          "linkWalletRecovery(address,address)": {
            "notice": "Establishes a recovery link between a lost wallet and its replacement."
          },
          "linkedIdentityRegistries()": {
            "notice": "Returns an array of addresses of all `SMARTIdentityRegistry` contracts currently bound to this storage."
          },
          "markWalletAsLost(address,address)": {
            "notice": "Marks a user wallet as lost for a specific identity contract in the storage."
          },
          "modifyStoredIdentity(address,address)": {
            "notice": "Modifies the `IIdentity` contract address associated with an existing identity record."
          },
          "modifyStoredInvestorCountry(address,uint16)": {
            "notice": "Modifies the country code associated with an existing identity record."
          },
          "removeIdentityFromStorage(address)": {
            "notice": "Removes an existing identity record from the storage based on the user's wallet address."
          },
          "storedIdentity(address)": {
            "notice": "Retrieves the `IIdentity` contract address associated with a registered user's wallet address."
          },
          "storedInvestorCountry(address)": {
            "notice": "Retrieves the numerical country code associated with a registered user's wallet address."
          },
          "supportsInterface(bytes4)": {
            "notice": "Indicates whether this contract supports a given interface ID, as per the ERC165 standard."
          },
          "unbindIdentityRegistry(address)": {
            "notice": "Revokes the authorization for a `SMARTIdentityRegistry` contract to modify data in this storage. This is achieved by revoking the `STORAGE_MODIFIER_ROLE` from the specified registry address."
          }
        },
        "version": 1
      }
    },
    "settings": {
      "remappings": [
        "@onchainid-v2.2.1/=dependencies/@onchainid-v2.2.1/contracts/",
        "@onchainid/contracts/=dependencies/@onchainid-v2.2.1/contracts/",
        "@openzeppelin-contracts-5.3.0/=dependencies/@openzeppelin-contracts-5.3.0/",
        "@openzeppelin-contracts-upgradeable-5.3.0/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/",
        "@openzeppelin/contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/",
        "@openzeppelin/contracts/=dependencies/@openzeppelin-contracts-5.3.0/",
        "forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/",
        "forge-std/=dependencies/forge-std-1.9.7/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "metadata": {
        "bytecodeHash": "none"
      },
      "compilationTarget": {
        "contracts/system/identity-registry-storage/ATKIdentityRegistryStorageImplementation.sol": "ATKIdentityRegistryStorageImplementation"
      },
      "evmVersion": "cancun",
      "libraries": {},
      "viaIR": true
    },
    "sources": {
      "contracts/smart/interface/ERC-3643/IERC3643IdentityRegistryStorage.sol": {
        "keccak256": "0x3a8a72df8da5bf4d988bbfb00151b933ff17cdc8d4be47dc121cd9e2083ba86f",
        "urls": [
          "bzz-raw://369250658bf8d3ebb583946820afa494271ce6bfde607d15c7060cdf7a303cf3",
          "dweb:/ipfs/QmSJjaK6vyv8K9RX1k3rwxsoKfVNyMoHEszxyxdTQfDKQG"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ISMARTIdentityRegistryStorage.sol": {
        "keccak256": "0x219b3d03958859e2f082aac5cbf3b40acf243e326ee6e74e6bb03be7724c2985",
        "urls": [
          "bzz-raw://8cf8d30ec47cb2aed5b51d373837584fb6f08deab1d35142510271e733404f52",
          "dweb:/ipfs/Qmc9NnABx9ouhhCR8qgJC3RtU5oAyycSjZkY6nGtuWFwuz"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/system/ATKSystemRoles.sol": {
        "keccak256": "0x7c5a50fcea7ee061d1bf5451217fbf83cfbc42cae638a0de4b8fc41fa5d7d980",
        "urls": [
          "bzz-raw://8dc4128ddb017dfd71ff70bd4b292bcf5e60ae6f81a07b1ceb15439607bb93c0",
          "dweb:/ipfs/QmWJpzgR3YuLvRXZPdFzvyZ1mHAyV3fhSUMcdFG4QJ3xzx"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/system/identity-registry-storage/ATKIdentityRegistryStorageImplementation.sol": {
        "keccak256": "0x793b1dc12562d43f7e465733845f90929ee53ba25c1e551fa28158ee1f786517",
        "urls": [
          "bzz-raw://02f711d3fab46fa4f8c0e83fc7d6b4823f0f4972fad9e638232841713315713b",
          "dweb:/ipfs/QmP1ADN9xPHb9vnKXQJFL12TeXJWXiWK7mBGv6dgYWsYeK"
        ],
        "license": "FSL-1.1-MIT"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IERC734.sol": {
        "keccak256": "0x35a14a0d1a3ed51689f1a2cb12e26d30601afbcc1cc9b9b288a03cd11e6d049e",
        "urls": [
          "bzz-raw://156aac402e73e6bd2fa8c0ccd85b2add8d1bb505d8a652218173dbc8e7b9a3cb",
          "dweb:/ipfs/QmPzPyc3kKxoNCGqKAooUju6YvMkDN4MCUH198TEXnA82o"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IERC735.sol": {
        "keccak256": "0xeac82c37b16c1c1c83df3e88be987332b1230ed13e1d017f9d2929f978ac0122",
        "urls": [
          "bzz-raw://695a66b789ac417b7b2b78c578981779db374704382921ff499351cccab0323e",
          "dweb:/ipfs/QmeZoogvsEWf688Z849zZ2dLPDnor6YnnNQLMgedY9Tc9D"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IIdentity.sol": {
        "keccak256": "0x5ed42ab81b9b734c79e61d1f7e0734baab5479a356ab6bb469414d3c66269862",
        "urls": [
          "bzz-raw://a0863999b1ed334179a43e699e6057815eea011a78ed51e61b6110fc392e26f8",
          "dweb:/ipfs/Qme6hdHZCAy1V4sLgAZ5NxdrEjEf5mYMabf5UDmUDjkuzW"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/access/IAccessControl.sol": {
        "keccak256": "0x4d9a2b261b56a1e4a37bb038151dec98b952fed16de2bdfdda27e38e2b12b530",
        "urls": [
          "bzz-raw://f724110f7aeb6151af800ab8c12e6060b29bda9e013f0ccb331eb754d6a7cbf0",
          "dweb:/ipfs/QmUcjzCZpxtUPdEThtAzE1f9LvuJiUGZxTdH9N6bHrb5Cf"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/utils/introspection/IERC165.sol": {
        "keccak256": "0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8",
        "urls": [
          "bzz-raw://f6fda447a62815e8064f47eff0dd1cf58d9207ad69b5d32280f8d7ed1d1e4621",
          "dweb:/ipfs/QmfDRc7pxfaXB2Dh9np5Uf29Na3pQ7tafRS684wd3GLjVL"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-upgradeable-5.3.0/access/AccessControlUpgradeable.sol": {
        "keccak256": "0x0d4d7d19a052a2ef9d17b28450133631188b895e1755747fa8ad0280aadfb534",
        "urls": [
          "bzz-raw://838551e10cc07e570b70aee1078e490658d3a0ab8f4adfd4f3f2a565200753da",
          "dweb:/ipfs/QmceT7R3Pqzywyxr3MSEA7VXU4axZAPS6BLy92iV97rGdG"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-upgradeable-5.3.0/metatx/ERC2771ContextUpgradeable.sol": {
        "keccak256": "0x290ba719fd784ff406a8de038c10dc2d0914794c8b016781712fcbb36ca7bffb",
        "urls": [
          "bzz-raw://8b5764ef1dab80c115c14e307c5cbd5845320a653a2d8a3658d20dfba6bc7758",
          "dweb:/ipfs/QmSPSasRTVtYyAEnEVCBPZwoQzgKU7gu7q8NeT9AMMpmmx"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-upgradeable-5.3.0/proxy/utils/Initializable.sol": {
        "keccak256": "0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05",
        "urls": [
          "bzz-raw://ab7b6d5b9e2b88176312967fe0f0e78f3d9a1422fa5e4b64e2440c35869b5d08",
          "dweb:/ipfs/QmXKYWWyzcLg1B2k7Sb1qkEXgLCYfXecR9wYW5obRzWP1Q"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-upgradeable-5.3.0/utils/ContextUpgradeable.sol": {
        "keccak256": "0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397",
        "urls": [
          "bzz-raw://08e39f23d5b4692f9a40803e53a8156b72b4c1f9902a88cd65ba964db103dab9",
          "dweb:/ipfs/QmPKn6EYDgpga7KtpkA8wV2yJCYGMtc9K4LkJfhKX2RVSV"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-upgradeable-5.3.0/utils/introspection/ERC165Upgradeable.sol": {
        "keccak256": "0xc8ed8d2056934b7675b695dec032f2920c2f5c6cf33a17ca85650940675323ab",
        "urls": [
          "bzz-raw://3c8ccc75d1cd792d192aa09e54dd49ea35fe85baa9fcd17486f29227d9f29b89",
          "dweb:/ipfs/QmbboSbFUEiM9tdEgBwuTRb7bykFoJXZ7dsSr1PSREJXMr"
        ],
        "license": "MIT"
      }
    },
    "version": 1
  },
  "userdoc": {
    "version": 1,
    "kind": "user",
    "methods": {
      "addIdentityToStorage(address,address,uint16)": {
        "notice": "Adds a new identity record to the storage, linking a user's wallet address to their identity contract and country code."
      },
      "bindIdentityRegistry(address)": {
        "notice": "Authorizes a `SMARTIdentityRegistry` contract to modify data in this storage contract. This is achieved by granting the `STORAGE_MODIFIER_ROLE` to the specified registry address."
      },
      "constructor": {
        "notice": "Constructor for the `SMARTIdentityRegistryStorageImplementation`."
      },
      "getIdentityWallets()": {
        "notice": "Returns an array of all wallet addresses that have a registered identity in this storage contract."
      },
      "getRecoveredWalletFromStorage(address)": {
        "notice": "Gets the new wallet address that replaced a lost wallet during recovery."
      },
      "initialize(address,address)": {
        "notice": "Initializes the `SMARTIdentityRegistryStorageImplementation` contract. This function acts as the constructor for an upgradeable contract and can only be called once."
      },
      "isWalletMarkedAsLost(address)": {
        "notice": "Checks if a user wallet is globally marked as lost in the storage."
      },
      "linkWalletRecovery(address,address)": {
        "notice": "Establishes a recovery link between a lost wallet and its replacement."
      },
      "linkedIdentityRegistries()": {
        "notice": "Returns an array of addresses of all `SMARTIdentityRegistry` contracts currently bound to this storage."
      },
      "markWalletAsLost(address,address)": {
        "notice": "Marks a user wallet as lost for a specific identity contract in the storage."
      },
      "modifyStoredIdentity(address,address)": {
        "notice": "Modifies the `IIdentity` contract address associated with an existing identity record."
      },
      "modifyStoredInvestorCountry(address,uint16)": {
        "notice": "Modifies the country code associated with an existing identity record."
      },
      "removeIdentityFromStorage(address)": {
        "notice": "Removes an existing identity record from the storage based on the user's wallet address."
      },
      "storedIdentity(address)": {
        "notice": "Retrieves the `IIdentity` contract address associated with a registered user's wallet address."
      },
      "storedInvestorCountry(address)": {
        "notice": "Retrieves the numerical country code associated with a registered user's wallet address."
      },
      "supportsInterface(bytes4)": {
        "notice": "Indicates whether this contract supports a given interface ID, as per the ERC165 standard."
      },
      "unbindIdentityRegistry(address)": {
        "notice": "Revokes the authorization for a `SMARTIdentityRegistry` contract to modify data in this storage. This is achieved by revoking the `STORAGE_MODIFIER_ROLE` from the specified registry address."
      }
    },
    "events": {
      "IdentityWalletMarkedAsLost(address,address,address)": {
        "notice": "Emitted when a user wallet is marked as lost for a specific identity contract within the storage."
      },
      "WalletRecoveryLinked(address,address,address)": {
        "notice": "Emitted when a wallet recovery link is established between a lost wallet and its replacement."
      }
    },
    "errors": {
      "IdentityAlreadyExists(address)": [
        {
          "notice": "Error triggered when attempting to add an identity to storage for a user address that already has an identity registered."
        }
      ],
      "IdentityDoesNotExist(address)": [
        {
          "notice": "Error triggered when attempting to operate on (e.g., modify, remove) an identity for a user address that is not registered."
        }
      ],
      "IdentityRegistryAlreadyBound(address)": [
        {
          "notice": "Error triggered when attempting to bind an identity registry contract that is already bound to this storage."
        }
      ],
      "IdentityRegistryNotBound(address)": [
        {
          "notice": "Error triggered when attempting to unbind an identity registry contract that is not currently bound to this storage."
        }
      ],
      "InvalidIdentityAddress()": [
        {
          "notice": "Error triggered if an attempt is made to register or associate an identity contract that has a zero address."
        }
      ],
      "InvalidIdentityRegistryAddress()": [
        {
          "notice": "Error triggered if an attempt is made to bind an identity registry contract that has a zero address."
        }
      ],
      "InvalidIdentityWalletAddress()": [
        {
          "notice": "Error triggered if an attempt is made to register or operate on an identity with a zero address for the user's wallet."
        }
      ],
      "WalletNotAssociatedWithIdentity(address,address)": [
        {
          "notice": "Error triggered when attempting to mark a wallet as lost for an identity that is not associated with that wallet."
        }
      ]
    },
    "notice": "This contract is the core logic for storing and managing identity-related data for the ATK Protocol. It acts as a persistent data layer for `ATKIdentityRegistry` contracts, which handle the business logic of identity registration and verification. This separation allows the storage logic to be upgraded independently."
  },
  "devdoc": {
    "version": 1,
    "kind": "dev",
    "author": "SettleMint Tokenization Services",
    "details": "This contract implements `ISMARTIdentityRegistryStorage`, a standard interface for storing data related to ERC-3643 compliant identity registries. This includes mapping user wallet addresses to their `IIdentity` contracts (which hold identity claims like KYC/AML status) and their country codes (for compliance purposes). It uses `AccessControlUpgradeable` to manage permissions:    - `DEFAULT_ADMIN_ROLE`: This role has the highest level of control. It can grant or revoke any other role,      including `MANAGE_REGISTRIES_ROLE`. Typically held by a secure multi-signature wallet or a DAO.    - `MANAGE_REGISTRIES_ROLE`: This role is responsible for managing which `SMARTIdentityRegistry` contracts      are allowed to interact with this storage. It can bind new registry contracts (granting them      `STORAGE_MODIFIER_ROLE`) and unbind existing ones. This role is usually assigned to a system controller      contract like `SMARTSystem` or an identity factory.    - `STORAGE_MODIFIER_ROLE`: This role is granted to `SMARTIdentityRegistry` contracts that have been \"bound\"      to this storage. Contracts with this role are authorized to call functions that add, remove, or update      identity data within this storage contract (e.g., `addIdentityToStorage`, `modifyStoredInvestorCountry`). The contract supports meta-transactions through `ERC2771ContextUpgradeable`, allowing users to interact with it via a trusted forwarder, potentially paying gas fees in tokens other than Ether. It is designed to be upgradeable using the UUPS (Universal Upgradeable Proxy Standard) pattern, meaning the upgrade logic resides within this implementation contract itself. The contract also maintains lists of all registered identity wallets and all bound registry contracts, which can be useful for enumeration, auditing, or administrative purposes.",
    "methods": {
      "addIdentityToStorage(address,address,uint16)": {
        "details": "This function can only be called by an address that holds the `STORAGE_MODIFIER_ROLE`. Typically, this role is granted to `SMARTIdentityRegistry` contracts that have been \"bound\" to this storage. It performs several critical validation checks before proceeding: -   The `_userAddress` (the user's external wallet) must not be the zero address (`address(0)`). -   The `_identity` (the address of the `IIdentity` contract for the user) must not be the zero address. -   An identity for the given `_userAddress` must not already exist in the storage to prevent duplicates. If all checks pass, the function: 1.  Stores the new identity information (identity contract address and country code) in the `_identities` mapping. 2.  Adds the `_userAddress` to the `_identityWallets` array for enumeration purposes. 3.  Updates the `_identityWalletsIndex` mapping to record the position of the new address in the array (for efficient removal later). 4.  Emits an `IdentityStored` event to notify off-chain listeners about the new registration.Reverts with:      - `InvalidIdentityWalletAddress()` if `_userAddress` is `address(0)`.      - `InvalidIdentityAddress()` if `_identity` is `address(0)`.      - `IdentityAlreadyExists(_userAddress)` if an identity is already registered for `_userAddress`.",
        "params": {
          "_country": "The numerical country code (uint16) representing the user's jurisdiction, used for compliance.",
          "_identity": "The address of the `IIdentity` contract representing the user's on-chain identity. This contract would hold claims and keys for the user.",
          "_userAddress": "The user's external wallet address (e.g., their EOA). This is the primary key for the identity record."
        }
      },
      "bindIdentityRegistry(address)": {
        "details": "This function can only be called by an address holding the `MANAGE_REGISTRIES_ROLE` (e.g., a `SMARTSystem` contract or an identity factory). It performs several checks: -   The `_identityRegistry` address must not be the zero address. -   The `_identityRegistry` must not already be bound to this storage. If the checks pass, the function: 1.  Sets `_boundIdentityRegistries[_identityRegistry]` to `true`. 2.  Adds `_identityRegistry` to the `_boundIdentityRegistryAddresses` array. 3.  Updates `_boundIdentityRegistriesIndex` for the new registry. 4.  Grants the `STORAGE_MODIFIER_ROLE` to `_identityRegistry` using the access control mechanism. 5.  Emits an `IdentityRegistryBound` event.Reverts with:      - `InvalidIdentityRegistryAddress()` if `_identityRegistry` is `address(0)`.      - `IdentityRegistryAlreadyBound(_identityRegistry)` if the registry is already bound.",
        "params": {
          "_identityRegistry": "The address of the `SMARTIdentityRegistry` contract to bind. This registry will then be able to call functions like `addIdentityToStorage`."
        }
      },
      "constructor": {
        "details": "This constructor is part of the UUPS (Universal Upgradeable Proxy Standard) pattern. In UUPS, the logic contract (this contract) is deployed, and then a proxy contract points to it. The constructor's main job here is to initialize the `ERC2771ContextUpgradeable` with the `trustedForwarder` address. This enables meta-transaction support, allowing users to interact with the contract without directly paying gas fees in Ether, if a trusted forwarder relays their transactions. `_disableInitializers()` is called to prevent the `initialize` function (which acts like a constructor for upgradeable contracts) from being called on this logic contract directly. The `initialize` function should only be called once, typically by the deployer through the proxy contract after deployment.",
        "params": {
          "trustedForwarder": "The address of the trusted forwarder contract for ERC2771 meta-transactions. If this is `address(0)`, meta-transactions via a forwarder are effectively disabled for this context, and `_msgSender()` will behave like the standard `msg.sender`."
        }
      },
      "getIdentityWallets()": {
        "details": "This function provides a way to enumerate all users who currently have an active identity record stored. It's useful for administrative purposes, data analysis, or for front-ends that need to display a list of all registered users.",
        "returns": {
          "_0": "An array of `address` types, where each address is a wallet address that has a stored identity. The array will be empty if no identities are currently registered."
        }
      },
      "getRecoveredWalletFromStorage(address)": {
        "details": "This is the key function for token recovery - allows checking if caller is authorized to recover from lostWallet.",
        "params": {
          "lostWallet": "The lost wallet address."
        },
        "returns": {
          "_0": "The new wallet address that replaced the lost wallet, or address(0) if not found."
        }
      },
      "getRoleAdmin(bytes32)": {
        "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
      },
      "grantRole(bytes32,address)": {
        "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."
      },
      "hasRole(bytes32,address)": {
        "details": "Returns `true` if `account` has been granted `role`."
      },
      "initialize(address,address)": {
        "details": "This function is typically called by the deployer immediately after the proxy contract pointing to this implementation is deployed. It sets up the initial state: 1.  `__ERC165_init_unchained()`: Initializes the ERC165 interface detection mechanism, allowing other contracts     to query what interfaces this contract supports (e.g., `IERC3643IdentityRegistryStorage`). 2.  `__AccessControlEnumerable_init_unchained()`: Initializes the role-based access control system. It sets up     the structures needed to grant, revoke, and check roles. 3.  `_grantRole(DEFAULT_ADMIN_ROLE, initialAdmin)`: Grants the `DEFAULT_ADMIN_ROLE` to the `initialAdmin`     address. The admin can manage all other roles and aspects of the access control. 4.  `_grantRole(STORAGE_MODIFIER_ROLE, initialAdmin)`: Grants the `STORAGE_MODIFIER_ROLE` to the `initialAdmin`.     This is often a temporary measure for bootstrapping; the `initialAdmin` (or the `DEFAULT_ADMIN_ROLE`     holder) would typically later grant this role to operational contracts like bound identity registries and     revoke it from themselves if direct modification by the admin is not intended long-term. 5.  `_grantRole(MANAGE_REGISTRIES_ROLE, system)`: Grants the `MANAGE_REGISTRIES_ROLE` to the `system` address.     The `system` address (e.g., a `SMARTSystem` contract or an identity factory contract) is then responsible     for binding and unbinding `SMARTIdentityRegistry` contracts, which in turn modify the storage. The `initializer` modifier from `Initializable` ensures this function can only be executed once, preventing re-initialization.",
        "params": {
          "initialAdmin": "The address that will receive the initial `DEFAULT_ADMIN_ROLE`. This address will also receive the `STORAGE_MODIFIER_ROLE` initially, though this might be delegated later.",
          "system": "The address of the system-level contract (e.g., `SMARTSystem` or a factory) that will be granted the `MANAGE_REGISTRIES_ROLE`. This role allows it to control which identity registry contracts can interact with and modify the data in this storage."
        }
      },
      "isTrustedForwarder(address)": {
        "details": "Indicates whether any particular address is the trusted forwarder."
      },
      "isWalletMarkedAsLost(address)": {
        "details": "A \"globally lost\" wallet means it has been declared lost in the context of at least one identity      it was associated with.",
        "params": {
          "userWallet": "The user wallet address to check."
        },
        "returns": {
          "_0": "True if the wallet has been marked as lost at least once, false otherwise."
        }
      },
      "linkWalletRecovery(address,address)": {
        "details": "This creates a bidirectional mapping for token recovery purposes.",
        "params": {
          "lostWallet": "The lost wallet address.",
          "newWallet": "The new replacement wallet address."
        }
      },
      "linkedIdentityRegistries()": {
        "details": "\"Bound\" means these registry contracts have been granted the `STORAGE_MODIFIER_ROLE` and are authorized to write data to this storage contract. This function provides a way to discover which registry contracts are active and can modify identity data.",
        "returns": {
          "_0": "An array of `address` types, where each address is that of a bound identity registry contract. The array will be empty if no registries are currently bound."
        }
      },
      "markWalletAsLost(address,address)": {
        "details": "Called by an authorized Identity Registry. This indicates the wallet should no longer be considered active      for verification or operations related to this specific identity, and potentially globally.",
        "params": {
          "identityContract": "The IIdentity contract address to which the userWallet was associated.",
          "userWallet": "The user wallet address to be marked as lost."
        }
      },
      "modifyStoredIdentity(address,address)": {
        "details": "This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It performs checks to ensure: -   An identity record actually exists for the given `_userAddress`. -   The new `_identity` contract address is not the zero address. If both checks pass, it updates the `identityContract` field within the `Identity` struct stored for the `_userAddress` in the `_identities` mapping. Finally, it emits an `IdentityModified` event, providing both the old and new `IIdentity` contract addresses.Reverts with:      - `IdentityDoesNotExist(_userAddress)` if no identity record is found for `_userAddress`.      - `InvalidIdentityAddress()` if the new `_identity` address is `address(0)`.",
        "params": {
          "_identity": "The new `IIdentity` contract address to associate with the `_userAddress`.",
          "_userAddress": "The user's external wallet address whose associated `IIdentity` contract is to be updated."
        }
      },
      "modifyStoredInvestorCountry(address,uint16)": {
        "details": "This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It first checks if an identity record exists for the given `_userAddress`. If not, it reverts. If the identity exists, it updates the `country` field within the `Identity` struct stored for the `_userAddress` in the `_identities` mapping with the new `_country` code. Finally, it emits a `CountryModified` event, providing the `_userAddress` and the new `_country` code.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for `_userAddress`.",
        "params": {
          "_country": "The new numerical country code (uint16) to associate with the `_userAddress`.",
          "_userAddress": "The user's external wallet address whose associated country code is to be updated."
        }
      },
      "removeIdentityFromStorage(address)": {
        "details": "This function can only be called by an address holding the `STORAGE_MODIFIER_ROLE`. It first checks if an identity actually exists for the given `_userAddress`. If not, it reverts. If the identity exists, it performs the following actions: 1.  Retrieves the `IIdentity` contract address associated with the user to include in the event. 2.  Removes the `_userAddress` from the `_identityWallets` array using the \"swap-and-pop\" technique. This is an     O(1) operation:     a.  It finds the index of `_userAddress` using `_identityWalletsIndex`.     b.  It takes the last wallet address from the `_identityWallets` array.     c.  If the address to remove is not the last one, it moves the last address into the slot of the address being removed.     d.  It updates `_identityWalletsIndex` for the moved address.     e.  It then shortens the `_identityWallets` array by one (pop). 3.  Deletes the entry for `_userAddress` from the `_identityWalletsIndex` mapping. 4.  Deletes the entry for `_userAddress` from the main `_identities` mapping. 5.  Emits an `IdentityUnstored` event to notify off-chain listeners.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for the `_userAddress`.",
        "params": {
          "_userAddress": "The user's external wallet address whose identity record is to be removed."
        }
      },
      "renounceRole(bytes32,address)": {
        "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."
      },
      "revokeRole(bytes32,address)": {
        "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."
      },
      "storedIdentity(address)": {
        "details": "This function performs a direct lookup in the `_identities` mapping. It first checks if an `identityContract` is stored for the `_userAddress` (i.e., it's not `address(0)`). If no identity contract is found (meaning the `_userAddress` is not registered or has been removed), the function reverts with the `IdentityDoesNotExist` error.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record is found for the `_userAddress`.",
        "params": {
          "_userAddress": "The user's external wallet address for which to retrieve the associated `IIdentity` contract."
        },
        "returns": {
          "_0": "The `IIdentity` contract address linked to the `_userAddress`. This is returned as an `IIdentity` type for type safety, but it's fundamentally an address."
        }
      },
      "storedInvestorCountry(address)": {
        "details": "This function performs a direct lookup in the `_identities` mapping for the given `_userAddress`. It first checks if an `identityContract` is associated with the `_userAddress`. This is a crucial check because a country code should only be considered valid if there's an active identity registration. If no `identityContract` is found (i.e., the address is `address(0)`), it implies the user is not registered or their identity has been removed, so the function reverts with `IdentityDoesNotExist`. If an identity contract exists, the function returns the `country` field from the `Identity` struct.Reverts with `IdentityDoesNotExist(_userAddress)` if no identity record (specifically, no identity contract) is found for the `_userAddress`.",
        "params": {
          "_userAddress": "The user's external wallet address for which to retrieve the associated country code."
        },
        "returns": {
          "_0": "The `uint16` country code associated with the `_userAddress`."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "This function allows other contracts or off-chain tools to query if this contract implements specific interfaces. It checks if the `interfaceId` matches: 1.  `type(ISMARTIdentityRegistryStorage).interfaceId`: This confirms that the contract adheres to the     standard interface for ERC-3643 compliant identity registry storage. 2.  Any interfaces supported by its parent contracts (e.g., `AccessControlUpgradeable`,     `ERC165Upgradeable` itself) by calling `super.supportsInterface(interfaceId)`. This is crucial for interoperability within the ecosystem, allowing, for example, a `SMARTIdentityRegistry` to verify that it's interacting with a compatible storage contract.",
        "params": {
          "interfaceId": "The EIP-165 interface identifier (a `bytes4` value) to check for support."
        },
        "returns": {
          "_0": "`true` if the contract supports the specified `interfaceId`, `false` otherwise."
        }
      },
      "trustedForwarder()": {
        "details": "Returns the address of the trusted forwarder."
      },
      "unbindIdentityRegistry(address)": {
        "details": "This function can only be called by an address holding the `MANAGE_REGISTRIES_ROLE`. It first checks if the `_identityRegistry` is currently bound. If not, it reverts. If the registry is bound, the function: 1.  Revokes the `STORAGE_MODIFIER_ROLE` from `_identityRegistry`. 2.  Removes `_identityRegistry` from the `_boundIdentityRegistryAddresses` array using the \"swap-and-pop\" technique (O(1) complexity). 3.  Updates `_boundIdentityRegistriesIndex` accordingly. 4.  Sets `_boundIdentityRegistries[_identityRegistry]` to `false`. 5.  Emits an `IdentityRegistryUnbound` event.Reverts with `IdentityRegistryNotBound(_identityRegistry)` if the registry is not currently bound.",
        "params": {
          "_identityRegistry": "The address of the `SMARTIdentityRegistry` contract to unbind. This registry will no longer be able to modify storage data."
        }
      }
    },
    "events": {
      "CountryModified(address,uint16)": {
        "details": "This event is emitted when an Identity's country has been updated.",
        "params": {
          "_country": "is the numeric code (ISO 3166-1) of the new country.",
          "_identityWallet": "is the address on which the country has been updated."
        }
      },
      "IdentityModified(address,address)": {
        "details": "This event is emitted when an Identity has been updated.",
        "params": {
          "_newIdentity": "is the new Identity contract's.",
          "_oldIdentity": "is the old Identity contract's address to update."
        }
      },
      "IdentityRegistryBound(address)": {
        "details": "This event is emitted when an Identity Registry is bound to the storage contract.",
        "params": {
          "_identityRegistry": "is the address of the identity registry added."
        }
      },
      "IdentityRegistryUnbound(address)": {
        "details": "This event is emitted when an Identity Registry is unbound from the storage contract.",
        "params": {
          "_identityRegistry": "is the address of the identity registry removed."
        }
      },
      "IdentityStored(address,address)": {
        "details": "This event is emitted when an Identity is registered into the storage contract.",
        "params": {
          "_identity": "` is the address of the Identity smart contract (onchainID).",
          "_investorAddress": "` is the address of the investor's wallet."
        }
      },
      "IdentityUnstored(address,address)": {
        "details": "This event is emitted when an Identity is removed from the storage contract.",
        "params": {
          "_identity": "is the address of the Identity smart contract (onchainID).",
          "_investorAddress": "is the address of the investor's wallet."
        }
      },
      "IdentityWalletMarkedAsLost(address,address,address)": {
        "params": {
          "identityContract": "The IIdentity contract associated with the user wallet.",
          "markedBy": "The address (typically the Identity Registry contract) that initiated this action.",
          "userWallet": "The user wallet address that was marked as lost."
        }
      },
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "RoleAdminChanged(bytes32,bytes32,bytes32)": {
        "details": "Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted to signal this."
      },
      "RoleGranted(bytes32,address,address)": {
        "details": "Emitted when `account` is granted `role`. `sender` is the account that originated the contract call. This account bears the admin role (for the granted role). Expected in cases where the role was granted using the internal {AccessControl-_grantRole}."
      },
      "RoleRevoked(bytes32,address,address)": {
        "details": "Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"
      },
      "WalletRecoveryLinked(address,address,address)": {
        "params": {
          "establishedBy": "The address that established this recovery link.",
          "lostWallet": "The lost wallet address.",
          "newWallet": "The new replacement wallet address."
        }
      }
    },
    "errors": {
      "AccessControlBadConfirmation()": [
        {
          "details": "The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."
        }
      ],
      "AccessControlUnauthorizedAccount(address,bytes32)": [
        {
          "details": "The `account` is missing a role."
        }
      ],
      "IdentityAlreadyExists(address)": [
        {
          "details": "This error prevents duplicate identity registrations for the same wallet address, maintaining data integrity.",
          "params": {
            "userAddress": "The wallet address for which an identity record already exists."
          }
        }
      ],
      "IdentityDoesNotExist(address)": [
        {
          "details": "This error ensures that operations like modification or removal are only performed on existing identity records.",
          "params": {
            "userAddress": "The wallet address for which no identity record was found in the storage."
          }
        }
      ],
      "IdentityRegistryAlreadyBound(address)": [
        {
          "details": "This error prevents a registry contract from being bound multiple times to this storage.",
          "params": {
            "registryAddress": "The address of the identity registry contract that is already bound."
          }
        }
      ],
      "IdentityRegistryNotBound(address)": [
        {
          "details": "This error ensures that unbinding operations are only performed on currently bound registry contracts.",
          "params": {
            "registryAddress": "The address of the identity registry contract that was not found in the list of bound registries."
          }
        }
      ],
      "InvalidIdentityAddress()": [
        {
          "details": "This error ensures that all registered identities point to a valid, non-zero `IIdentity` contract address. The `IIdentity` contract holds the claims and keys related to an identity."
        }
      ],
      "InvalidIdentityRegistryAddress()": [
        {
          "details": "This error ensures that only valid, non-zero registry contract addresses can be bound to this storage contract. Binding allows a registry contract to modify data in this storage."
        }
      ],
      "InvalidIdentityWalletAddress()": [
        {
          "details": "This error ensures that every identity record in the system is linked to a valid, non-zero wallet address. A zero address typically indicates an uninitialized or invalid address in Ethereum."
        }
      ],
      "InvalidInitialization()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ],
      "WalletNotAssociatedWithIdentity(address,address)": [
        {
          "details": "This error ensures that wallets can only be marked as lost for identities they are actually associated with.",
          "params": {
            "identityContract": "The identity contract address.",
            "userWallet": "The wallet address that is not associated with the identity."
          }
        }
      ]
    },
    "title": "ATK Identity Registry Storage Implementation"
  },
  "id": 122
}