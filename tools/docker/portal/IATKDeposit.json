{
  "abi": [
    {
      "type": "function",
      "name": "accessManager",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "addComplianceModule",
      "inputs": [
        {
          "name": "_module",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_params",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "allowance",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "spender",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "approve",
      "inputs": [
        {
          "name": "spender",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "balanceOf",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "batchBurn",
      "inputs": [
        {
          "name": "userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchForcedTransfer",
      "inputs": [
        {
          "name": "fromList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "toList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchFreezePartialTokens",
      "inputs": [
        {
          "name": "userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchMint",
      "inputs": [
        {
          "name": "_toList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchSetAddressFrozen",
      "inputs": [
        {
          "name": "userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "freeze",
          "type": "bool[]",
          "internalType": "bool[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchTransfer",
      "inputs": [
        {
          "name": "_toList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchUnfreezePartialTokens",
      "inputs": [
        {
          "name": "userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "burn",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "compliance",
      "inputs": [],
      "outputs": [
        {
          "name": "complianceContract",
          "type": "address",
          "internalType": "contract ISMARTCompliance"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "complianceModules",
      "inputs": [],
      "outputs": [
        {
          "name": "modulesList",
          "type": "tuple[]",
          "internalType": "struct SMARTComplianceModuleParamPair[]",
          "components": [
            {
              "name": "module",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "params",
              "type": "bytes",
              "internalType": "bytes"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "findValidCollateralClaim",
      "inputs": [],
      "outputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "issuer",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "expiryTimestamp",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "forcedRecoverTokens",
      "inputs": [
        {
          "name": "lostWallet",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "newWallet",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "forcedTransfer",
      "inputs": [
        {
          "name": "from",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "freezePartialTokens",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "getFrozenTokens",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "hasRole",
      "inputs": [
        {
          "name": "role",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "identityRegistry",
      "inputs": [],
      "outputs": [
        {
          "name": "registryContract",
          "type": "address",
          "internalType": "contract ISMARTIdentityRegistry"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "initialize",
      "inputs": [
        {
          "name": "name_",
          "type": "string",
          "internalType": "string"
        },
        {
          "name": "symbol_",
          "type": "string",
          "internalType": "string"
        },
        {
          "name": "decimals_",
          "type": "uint8",
          "internalType": "uint8"
        },
        {
          "name": "onchainID_",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "collateralTopicId_",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "initialModulePairs_",
          "type": "tuple[]",
          "internalType": "struct SMARTComplianceModuleParamPair[]",
          "components": [
            {
              "name": "module",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "params",
              "type": "bytes",
              "internalType": "bytes"
            }
          ]
        },
        {
          "name": "identityRegistry_",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "compliance_",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "accessManager_",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "isFrozen",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "mint",
      "inputs": [
        {
          "name": "_to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "name",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "onchainID",
      "inputs": [],
      "outputs": [
        {
          "name": "idAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "pause",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "paused",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "recoverERC20",
      "inputs": [
        {
          "name": "token",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "recoverTokens",
      "inputs": [
        {
          "name": "_lostWallet",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "registeredInterfaces",
      "inputs": [],
      "outputs": [
        {
          "name": "interfacesList",
          "type": "bytes4[]",
          "internalType": "bytes4[]"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "removeComplianceModule",
      "inputs": [
        {
          "name": "_module",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setAddressFrozen",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "freeze",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setCompliance",
      "inputs": [
        {
          "name": "_compliance",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setIdentityRegistry",
      "inputs": [
        {
          "name": "_identityRegistry",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setOnchainID",
      "inputs": [
        {
          "name": "_onchainID",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setParametersForComplianceModule",
      "inputs": [
        {
          "name": "_module",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_params",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "supportsInterface",
      "inputs": [
        {
          "name": "interfaceId",
          "type": "bytes4",
          "internalType": "bytes4"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "symbol",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "totalSupply",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "transfer",
      "inputs": [
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "transferFrom",
      "inputs": [
        {
          "name": "from",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unfreezePartialTokens",
      "inputs": [
        {
          "name": "userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unpause",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "event",
      "name": "AccessManagerSet",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "manager",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "AddressFrozen",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "userAddress",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "isFrozen",
          "type": "bool",
          "indexed": true,
          "internalType": "bool"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Approval",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "spender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "BurnCompleted",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "from",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "ComplianceAdded",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_compliance",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "ComplianceModuleAdded",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_module",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_params",
          "type": "bytes",
          "indexed": false,
          "internalType": "bytes"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "ComplianceModuleRemoved",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_module",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "ERC20TokenRecovered",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "token",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "ForcedTransfer",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "from",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "IdentityRegistryAdded",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_identityRegistry",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "MintCompleted",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "ModuleParametersUpdated",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_module",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_params",
          "type": "bytes",
          "indexed": false,
          "internalType": "bytes"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Paused",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "RecoverySuccess",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "lostWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "newWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "investorOnchainID",
          "type": "address",
          "indexed": false,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "TokensFrozen",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "TokensRecovered",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "lostWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "newWallet",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "TokensUnfrozen",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "user",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Transfer",
      "inputs": [
        {
          "name": "from",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "TransferCompleted",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "from",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Unpaused",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "UpdatedTokenInformation",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "_newDecimals",
          "type": "uint8",
          "indexed": false,
          "internalType": "uint8"
        },
        {
          "name": "_newOnchainID",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "AccessControlUnauthorizedAccount",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "neededRole",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ]
    },
    {
      "type": "error",
      "name": "CannotRecoverSelf",
      "inputs": []
    },
    {
      "type": "error",
      "name": "DuplicateModule",
      "inputs": [
        {
          "name": "module",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "ExpectedPause",
      "inputs": []
    },
    {
      "type": "error",
      "name": "FreezeAmountExceedsAvailableBalance",
      "inputs": [
        {
          "name": "available",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "requested",
          "type": "uint256",
          "internalType": "uint256"
        }
      ]
    },
    {
      "type": "error",
      "name": "InsufficientCollateral",
      "inputs": [
        {
          "name": "required",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "available",
          "type": "uint256",
          "internalType": "uint256"
        }
      ]
    },
    {
      "type": "error",
      "name": "InsufficientFrozenTokens",
      "inputs": [
        {
          "name": "frozenBalance",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "requested",
          "type": "uint256",
          "internalType": "uint256"
        }
      ]
    },
    {
      "type": "error",
      "name": "InsufficientTokenBalance",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidCollateralTopic",
      "inputs": [
        {
          "name": "topicId",
          "type": "uint256",
          "internalType": "uint256"
        }
      ]
    },
    {
      "type": "error",
      "name": "InvalidDecimals",
      "inputs": [
        {
          "name": "decimals",
          "type": "uint8",
          "internalType": "uint8"
        }
      ]
    },
    {
      "type": "error",
      "name": "InvalidLostWallet",
      "inputs": []
    },
    {
      "type": "error",
      "name": "LengthMismatch",
      "inputs": []
    },
    {
      "type": "error",
      "name": "MintNotCompliant",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ModuleAlreadyAdded",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ModuleNotFound",
      "inputs": []
    },
    {
      "type": "error",
      "name": "NoTokensToRecover",
      "inputs": []
    },
    {
      "type": "error",
      "name": "RecipientAddressFrozen",
      "inputs": []
    },
    {
      "type": "error",
      "name": "SenderAddressFrozen",
      "inputs": []
    },
    {
      "type": "error",
      "name": "TokenPaused",
      "inputs": []
    },
    {
      "type": "error",
      "name": "TransferNotCompliant",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ZeroAddressNotAllowed",
      "inputs": []
    }
  ],
  "bytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "deployedBytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "methodIdentifiers": {
    "accessManager()": "fdcb6068",
    "addComplianceModule(address,bytes)": "77d2f8d9",
    "allowance(address,address)": "dd62ed3e",
    "approve(address,uint256)": "095ea7b3",
    "balanceOf(address)": "70a08231",
    "batchBurn(address[],uint256[])": "4a6cc677",
    "batchForcedTransfer(address[],address[],uint256[])": "42a47abc",
    "batchFreezePartialTokens(address[],uint256[])": "fc7e5fa8",
    "batchMint(address[],uint256[])": "68573107",
    "batchSetAddressFrozen(address[],bool[])": "1a7af379",
    "batchTransfer(address[],uint256[])": "88d695b2",
    "batchUnfreezePartialTokens(address[],uint256[])": "4710362d",
    "burn(address,uint256)": "9dc29fac",
    "compliance()": "6290865d",
    "complianceModules()": "a98ac17a",
    "decimals()": "313ce567",
    "findValidCollateralClaim()": "b5cb9db3",
    "forcedRecoverTokens(address,address)": "62b9333e",
    "forcedTransfer(address,address,uint256)": "9fc1d0e7",
    "freezePartialTokens(address,uint256)": "125c4a33",
    "getFrozenTokens(address)": "158b1a57",
    "hasRole(bytes32,address)": "91d14854",
    "identityRegistry()": "134e18f4",
    "initialize(string,string,uint8,address,uint256,(address,bytes)[],address,address,address)": "81418ae4",
    "isFrozen(address)": "e5839836",
    "mint(address,uint256)": "40c10f19",
    "name()": "06fdde03",
    "onchainID()": "aba63705",
    "pause()": "8456cb59",
    "paused()": "5c975abb",
    "recoverERC20(address,address,uint256)": "1171bda9",
    "recoverTokens(address)": "16114acd",
    "registeredInterfaces()": "1fd522a8",
    "removeComplianceModule(address)": "c76f3d9b",
    "setAddressFrozen(address,bool)": "c69c09cf",
    "setCompliance(address)": "f8981789",
    "setIdentityRegistry(address)": "cbf3f861",
    "setOnchainID(address)": "3d1ddc5b",
    "setParametersForComplianceModule(address,bytes)": "1ef5205f",
    "supportsInterface(bytes4)": "01ffc9a7",
    "symbol()": "95d89b41",
    "totalSupply()": "18160ddd",
    "transfer(address,uint256)": "a9059cbb",
    "transferFrom(address,address,uint256)": "23b872dd",
    "unfreezePartialTokens(address,uint256)": "1fe56f7d",
    "unpause()": "3f4ba83a"
  },
  "rawMetadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotRecoverSelf\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"DuplicateModule\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"}],\"name\":\"FreezeAmountExceedsAvailableBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"InsufficientCollateral\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"frozenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"}],\"name\":\"InsufficientFrozenTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTokenBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"topicId\",\"type\":\"uint256\"}],\"name\":\"InvalidCollateralTopic\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"InvalidDecimals\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLostWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotCompliant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModuleAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModuleNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokensToRecover\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecipientAddressFrozen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderAddressFrozen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotCompliant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"AccessManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"}],\"name\":\"AddressFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BurnCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_compliance\",\"type\":\"address\"}],\"name\":\"ComplianceAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"ComplianceModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"ComplianceModuleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20TokenRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ForcedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_identityRegistry\",\"type\":\"address\"}],\"name\":\"IdentityRegistryAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"ModuleParametersUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"investorOnchainID\",\"type\":\"address\"}],\"name\":\"RecoverySuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_newDecimals\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOnchainID\",\"type\":\"address\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accessManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"addComplianceModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"fromList\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"toList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchForcedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchFreezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_toList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"freeze\",\"type\":\"bool[]\"}],\"name\":\"batchSetAddressFrozen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_toList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchUnfreezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compliance\",\"outputs\":[{\"internalType\":\"contract ISMARTCompliance\",\"name\":\"complianceContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"complianceModules\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct SMARTComplianceModuleParamPair[]\",\"name\":\"modulesList\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"findValidCollateralClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"forcedRecoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"forcedTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"freezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getFrozenTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityRegistry\",\"outputs\":[{\"internalType\":\"contract ISMARTIdentityRegistry\",\"name\":\"registryContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"onchainID_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralTopicId_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct SMARTComplianceModuleParamPair[]\",\"name\":\"initialModulePairs_\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"identityRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"compliance_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accessManager_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onchainID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"idAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lostWallet\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registeredInterfaces\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"interfacesList\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"removeComplianceModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"setAddressFrozen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_compliance\",\"type\":\"address\"}],\"name\":\"setCompliance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identityRegistry\",\"type\":\"address\"}],\"name\":\"setIdentityRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_onchainID\",\"type\":\"address\"}],\"name\":\"setOnchainID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"setParametersForComplianceModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unfreezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"Error: Account Lacks Required Role.      This error is emitted when an action is attempted by an account (`account`)      that does not possess the necessary authorization role (`neededRole`).      For example, if an account tries to mint new tokens but doesn't have the 'MINTER_ROLE'.\",\"params\":{\"account\":\"The address of the account that attempted the unauthorized action.\",\"neededRole\":\"The `bytes32` identifier of the role that the `account` was missing.\"}}],\"CannotRecoverSelf()\":[{\"details\":\"The `recoverERC20` function is designed to recover other ERC20 tokens mistakenly sent to this contract,      not the token this contract itself represents.\"}],\"DuplicateModule(address)\":[{\"params\":{\"module\":\"The address of the duplicate compliance module.\"}}],\"ExpectedPause()\":[{\"details\":\"For example, this might be used if an `unpause()` function is called when the contract is already unpaused,      or if a specific admin action is only allowed during a maintenance (paused) period.\"}],\"FreezeAmountExceedsAvailableBalance(uint256,uint256)\":[{\"params\":{\"available\":\"The available, unfrozen balance of the user.\",\"requested\":\"The amount of tokens requested to be frozen.\"}}],\"InsufficientCollateral(uint256,uint256)\":[{\"details\":\"This error is thrown by the `__collateral_beforeMintLogic` function if a valid collateral claim      is found on the token contract's identity, but the `amount` specified in that claim is less than      what the token's total supply would become *after* the current mint operation.      For example, if the collateral claim specifies a collateral amount (effectively a supply cap) of 1,000,000 tokens,      the current total supply is 900,000, and an attempt is made to mint 200,000 more tokens,      the `required` total supply would be 1,100,000. Since 1,100,000 (required) > 1,000,000 (available), this error occurs.      It also occurs if no valid collateral claim is found (in which case `available` would be 0), unless the      `required` supply is also 0.\",\"params\":{\"available\":\"The collateral amount found in the valid, non-expired claim on the token's identity. This acts as the effective cap.\",\"required\":\"The total supply that would be reached if the mint operation were to proceed (current supply + mint amount).\"}}],\"InsufficientFrozenTokens(uint256,uint256)\":[{\"params\":{\"frozenBalance\":\"The current amount of tokens specifically frozen for the address.\",\"requested\":\"The amount requested to be unfrozen or used from the frozen portion.\"}}],\"InsufficientTokenBalance()\":[{\"details\":\"This typically occurs during token recovery if the contract holds less of the target token than the amount requested for recovery.\"}],\"InvalidCollateralTopic(uint256)\":[{\"details\":\"This error is thrown by the initializer or constructor of the collateral extension      if the provided `collateralProofTopic_` (the ERC-735 claim topic ID) is invalid.      Typically, an invalid topic ID would be `0`, as topic ID 0 is often reserved or considered null.      A valid topic ID is crucial for correctly identifying and verifying the specific collateral claims.\",\"params\":{\"topicId\":\"The invalid topic ID (e.g., 0) that was provided during the contract's initialization.\"}}],\"InvalidDecimals(uint8)\":[{\"details\":\"This error is typically reverted if `decimals` is greater than 18, which is a common upper limit.\",\"params\":{\"decimals\":\"The invalid decimals value that was provided.\"}}],\"InvalidLostWallet()\":[{\"details\":\"This can occur if the wallet is not associated with any lost identity.\"}],\"LengthMismatch()\":[{\"details\":\"This error is typically triggered in functions that process multiple items in batches,      such as `batchBurn` or `batchTransfer`, when the input arrays (e.g., an array of addresses      and an array of corresponding amounts) do not have the same number of elements.      For example, if 3 addresses are provided but only 2 amounts, this error would be raised      because it's unclear how to map the amounts to the addresses.\"}],\"MintNotCompliant()\":[{\"details\":\"This means the conditions required by the active compliance modules for minting were not met.\"}],\"ModuleNotFound()\":[{\"details\":\"This can occur when trying to remove or update parameters for a non-existent module.\"}],\"NoTokensToRecover()\":[{\"details\":\"This can occur if the contract holds no tokens to recover.\"}],\"TokenPaused()\":[{\"details\":\"For example, this error is typically used in a `whenNotPaused` modifier if a function like `transfer`      is called while the token operations are halted.\"}],\"TransferNotCompliant()\":[{\"details\":\"This means the conditions required by the active compliance modules for transferring tokens were not met.\"}],\"ZeroAddressNotAllowed()\":[{\"details\":\"This error is used to indicate that an operation or initialization was attempted with the      zero address (`address(0)`), which is often an invalid or disallowed address in many contexts.      For example, setting a critical administrative role to the zero address, or transferring tokens      to the zero address (which can effectively burn them, but should be explicit if intended).\"}]},\"events\":{\"AccessManagerSet(address,address)\":{\"details\":\"This event is crucial for transparency and monitoring. It allows external observers      to know when the authority managing roles and permissions for a token has been updated.      The `indexed` keyword for `sender` and `manager` allows these addresses to be efficiently      searched for in event logs.\",\"params\":{\"manager\":\"The new address of the `SMARTTokenAccessManager` contract that will now                oversee access control for the token.\",\"sender\":\"The address of the account that initiated the change of the access manager.               This is typically an administrator or an account with special privileges.\"}},\"AddressFrozen(address,address,bool)\":{\"params\":{\"isFrozen\":\"The new frozen status: `true` if the address is now frozen, `false` if unfrozen.                 `indexed` to quickly find all freeze or unfreeze events.\",\"sender\":\"The address (e.g., custodian, admin) that initiated the freeze/unfreeze operation.               `indexed` for easier filtering of operations by a specific admin.\",\"userAddress\":\"The address whose frozen status was changed. `indexed` for tracking a specific user.\"}},\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"BurnCompleted(address,address,uint256)\":{\"details\":\"This event signifies that a specified `amount` of tokens has been destroyed from the `from` address,      triggered by the `sender`.      The `indexed` keyword for `sender` and `from` parameters is a special feature in Solidity events.      It allows these parameters to be efficiently searched and filtered by off-chain applications.      Think of them as creating a searchable index for these specific fields in the event logs.\",\"params\":{\"amount\":\"The quantity of tokens that were burned (destroyed).\",\"from\":\"The address from which the tokens were actually burned. This is the account whose token balance was reduced.\",\"sender\":\"The address of the account that initiated or authorized the burn operation.               This could be an administrator, an operator, or under certain rules, the token holder themselves.\"}},\"ComplianceAdded(address,address)\":{\"details\":\"This event indicates a change in the primary contract responsible for enforcing compliance rules on token transfers.\",\"params\":{\"_compliance\":\"The address of the newly configured `ISMARTCompliance` contract.\",\"sender\":\"The address of the account (e.g., admin) that initiated this configuration change.\"}},\"ComplianceModuleAdded(address,address,bytes)\":{\"details\":\"Compliance modules implement specific rules (e.g., geographic restrictions, holding limits).\",\"params\":{\"_module\":\"The address of the newly added compliance module contract (which should implement `ISMARTComplianceModule`).\",\"_params\":\"The ABI-encoded configuration parameters initially set for this module instance on this token.\",\"sender\":\"The address of the account (e.g., admin) that added the module.\"}},\"ComplianceModuleRemoved(address,address)\":{\"details\":\"Removing a module means its rules will no longer be applied to token operations.\",\"params\":{\"_module\":\"The address of the compliance module contract that was removed.\",\"sender\":\"The address of the account (e.g., admin) that removed the module.\"}},\"ERC20TokenRecovered(address,address,address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens recovered.\",\"sender\":\"The address that initiated the recovery operation.\",\"to\":\"The address to which the tokens were recovered.\",\"token\":\"The address of the ERC20 token recovered.\"}},\"ForcedTransfer(address,address,address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens transferred.\",\"from\":\"The source address of the tokens. `indexed`.\",\"sender\":\"The address of the custodian who initiated the forced transfer. `indexed`.\",\"to\":\"The destination address of the tokens. `indexed`.\"}},\"IdentityRegistryAdded(address,address)\":{\"details\":\"This event signals a change in the system component responsible for managing and verifying user identities.\",\"params\":{\"_identityRegistry\":\"The address of the newly configured `ISMARTIdentityRegistry` contract.\",\"sender\":\"The address of the account (e.g., admin) that initiated this configuration change.\"}},\"MintCompleted(address,address,uint256)\":{\"params\":{\"amount\":\"The quantity of tokens minted.\",\"sender\":\"The address of the account (e.g., minter role) that initiated the minting.\",\"to\":\"The address that received the newly minted tokens.\"}},\"ModuleParametersUpdated(address,address,bytes)\":{\"details\":\"This allows tweaking the behavior of a module without removing and re-adding it.\",\"params\":{\"_module\":\"The address of the compliance module whose parameters were updated.\",\"_params\":\"The new ABI-encoded configuration parameters for the module.\",\"sender\":\"The address of the account (e.g., admin) that updated the parameters.\"}},\"Paused(address)\":{\"details\":\"This event signals that standard operations (like transfers) are likely now blocked.\",\"params\":{\"sender\":\"The address that initiated the `pause` operation. This is typically an authorized               account with a PAUSER_ROLE. `indexed` for easier filtering of events initiated               by a specific admin or pauser address.\"}},\"RecoverySuccess(address,address,address,address)\":{\"params\":{\"investorOnchainID\":\"The on-chain ID contract address that links the `lostWallet` and `newWallet`,                          confirming they belong to the same beneficial owner.                          Not typically indexed as it might be a shared contract for many users.\",\"lostWallet\":\"The address from which assets were recovered. `indexed`.\",\"newWallet\":\"The address to which assets were transferred and identity re-associated. `indexed`.\",\"sender\":\"The address (e.g., custodian) that initiated the recovery operation. `indexed`.\"}},\"TokensFrozen(address,address,uint256)\":{\"details\":\"This refers to freezing a portion of an address's tokens, distinct from freezing the entire address.\",\"params\":{\"amount\":\"The quantity of tokens that were specifically frozen.\",\"sender\":\"The address that initiated the partial freeze operation. `indexed`.\",\"user\":\"The address for which a specific amount of tokens was frozen. `indexed`.\"}},\"TokensRecovered(address,address,address,uint256)\":{\"params\":{\"amount\":\"The amount of tokens recovered.\",\"lostWallet\":\"The address of the lost wallet containing tokens to recover.\",\"newWallet\":\"The address to which the tokens were recovered.\",\"sender\":\"The address that initiated the recovery operation.\"}},\"TokensUnfrozen(address,address,uint256)\":{\"params\":{\"amount\":\"The quantity of tokens that were unfrozen from the partial freeze.\",\"sender\":\"The address that initiated the partial unfreeze operation. `indexed`.\",\"user\":\"The address for which a specific amount of tokens was unfrozen. `indexed`.\"}},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"},\"TransferCompleted(address,address,address,uint256)\":{\"params\":{\"amount\":\"The quantity of tokens transferred.\",\"from\":\"The address from which tokens were sent.\",\"sender\":\"The address that initiated the transfer action (could be the `from` address or an operator).\",\"to\":\"The address to which tokens were received.\"}},\"Unpaused(address)\":{\"details\":\"This event signals that standard operations are likely resumed.\",\"params\":{\"sender\":\"The address that initiated the `unpause` operation. Similar to `Paused` event, this is               typically an authorized account. `indexed` for filtering.\"}},\"UpdatedTokenInformation(address,uint8,address)\":{\"details\":\"Note: While `name` and `symbol` are part of `IERC20Metadata`, their update mechanism isn't explicitly defined here,      but if updatable, would likely also trigger such an event. This event specifically calls out decimals and onchainID.\",\"params\":{\"_newDecimals\":\"The new number of decimal places the token uses. (Note: Changing decimals post-deployment is highly unusual and complex for ERC20 tokens).\",\"_newOnchainID\":\"The address of the new on-chain Identity contract representing the token itself (if applicable).\",\"sender\":\"The address of the account (e.g., admin) that initiated the update.\"}}},\"kind\":\"dev\",\"methods\":{\"accessManager()\":{\"returns\":{\"_0\":\"The address of the access manager.\"}},\"addComplianceModule(address,bytes)\":{\"details\":\"Before adding, the implementation (or the main `ISMARTCompliance` contract) MUST validate:      1. That `_module` is a valid contract address.      2. That `_module` correctly implements the `ISMARTComplianceModule` interface (e.g., via ERC165 `supportsInterface`).      3. That the provided `_params` are valid for the `_module` (by calling `_module.validateParameters(_params)`).      Typically restricted to an administrative role. Emits `ComplianceModuleAdded`.\",\"params\":{\"_module\":\"The address of the compliance module contract to add.\",\"_params\":\"The initial ABI-encoded configuration parameters for this module specific to this token.\"}},\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the value of tokens owned by `account`.\"},\"batchBurn(address[],uint256[])\":{\"details\":\"This function allows for efficient batch processing of token burns, which can save on      transaction fees (gas) compared to calling `burn` multiple times individually.      It requires that the `userAddresses` array and the `amounts` array have the same number of elements,      with each `amounts[i]` corresponding to `userAddresses[i]`.      Similar to the single `burn` function, authorization for each individual burn within the batch      is expected to be handled by the implementing contract (e.g., via an `_authorizeBurn` hook).      If the lengths of the input arrays do not match, the transaction should revert to prevent errors.\",\"params\":{\"amounts\":\"An array of token quantities to be burned. `amounts[i]` tokens will be burned                from `userAddresses[i]`.\",\"userAddresses\":\"An array of blockchain addresses from which tokens will be burned.\"}},\"batchForcedTransfer(address[],address[],uint256[])\":{\"details\":\"A gas-efficient version of `forcedTransfer` for multiple operations.      Requires strong authorization for the entire batch.      Arrays `fromList`, `toList`, and `amounts` must be of the same length.\",\"params\":{\"amounts\":\"A list of corresponding token amounts to transfer.\",\"fromList\":\"A list of sender addresses.\",\"toList\":\"A list of recipient addresses.\"}},\"batchFreezePartialTokens(address[],uint256[])\":{\"details\":\"Allows freezing different amounts for different users simultaneously.      Requires authorization for each partial freeze operation.      Arrays must be of the same length.\",\"params\":{\"amounts\":\"A list of corresponding token amounts to freeze.\",\"userAddresses\":\"A list of target addresses.\"}},\"batchMint(address[],uint256[])\":{\"details\":\"This is an efficiency function to reduce transaction costs when minting to many users.      Typically restricted to accounts with a specific minter role.      Implementations MUST perform identity verification and compliance checks for *each* recipient in `_toList`.      If any recipient fails checks, the entire batch operation should revert to maintain atomicity.      Emits multiple `MintCompleted` and ERC20 `Transfer` events.\",\"params\":{\"_amounts\":\"An array of corresponding token quantities to mint for each address in `_toList`. The lengths of `_toList` and `_amounts` MUST be equal.\",\"_toList\":\"An array of addresses to receive the newly minted tokens.\"}},\"batchSetAddressFrozen(address[],bool[])\":{\"details\":\"A gas-efficient way to update the frozen status for several addresses at once.      Requires authorization for each underlying freeze/unfreeze operation.      The `userAddresses` and `freeze` arrays must be of the same length.\",\"params\":{\"freeze\":\"A list of corresponding boolean freeze statuses (`true` for freeze, `false` for unfreeze).\",\"userAddresses\":\"A list of target addresses.\"}},\"batchTransfer(address[],uint256[])\":{\"details\":\"This is an efficiency function, useful for distributions or airdrops (if compliant).      The caller (`msg.sender`) must have a sufficient balance to cover the sum of all `_amounts`.      Implementations MUST perform identity verification and compliance checks for *each* recipient in `_toList`      and also check the sender (`msg.sender`) if sender-side compliance rules apply.      If any part of the batch fails checks, the entire operation should revert.      Emits multiple `TransferCompleted` and ERC20 `Transfer` events.\",\"params\":{\"_amounts\":\"An array of corresponding token quantities to transfer. The lengths of `_toList` and `_amounts` MUST be equal.\",\"_toList\":\"An array of addresses to receive the tokens.\"}},\"batchUnfreezePartialTokens(address[],uint256[])\":{\"details\":\"Allows unfreezing different amounts for different users simultaneously.      Requires authorization for each partial unfreeze operation.      Arrays must be of the same length.\",\"params\":{\"amounts\":\"A list of corresponding token amounts to unfreeze.\",\"userAddresses\":\"A list of target addresses.\"}},\"burn(address,uint256)\":{\"details\":\"This function is intended for an authorized operator (like an admin or a special role)      to burn tokens on behalf of a user, or from a specific account as part of token management.      The actual authorization logic (who can call this) is typically handled by the contract      implementing this interface, often through a mechanism like an `_authorizeBurn` hook.      The function signature and intent are similar to `operatorBurn` as suggested by standards      like ERC3643, where an operator can manage token holdings.\",\"params\":{\"amount\":\"The quantity of tokens to burn. This should be a non-negative integer.\",\"userAddress\":\"The blockchain address of the account from which tokens will be burned.                    This is the account whose token balance will decrease.\"}},\"compliance()\":{\"details\":\"The Compliance contract is responsible for orchestrating compliance checks for token operations.\",\"returns\":{\"complianceContract\":\"The `ISMARTCompliance` contract instance currently in use.\"}},\"complianceModules()\":{\"details\":\"Each element in the returned array is a `SMARTComplianceModuleParamPair` struct, containing the module's address      and its current ABI-encoded parameters specific to this token.\",\"returns\":{\"modulesList\":\"An array of `SMARTComplianceModuleParamPair` structs.\"}},\"decimals()\":{\"details\":\"Returns the decimals places of the token.\"},\"findValidCollateralClaim()\":{\"details\":\"This function is expected to perform several checks:      1. Retrieve claim IDs from the token's identity contract (`this.onchainID()`) for the configured `collateralProofTopic`.      2. For each claim, verify its issuer is trusted for that topic via the `identityRegistry`'s `issuersRegistry`.      3. Confirm the trusted issuer contract itself deems the claim valid (e.g., via `IClaimIssuer.isClaimValid`).      4. Decode the claim data, which is expected to contain a collateral `amount` and an `expiryTimestamp`.      5. Ensure the claim has not expired (i.e., `decodedExpiry > block.timestamp`).      The function should return the details of the *first* claim that successfully passes all these validations.      If no such claim is found, it should return zero values.      This is a `view` function, meaning it reads blockchain state but does not modify it, and thus      does not consume gas when called as a read-only operation from off-chain.\",\"returns\":{\"amount\":\"The collateral amount (e.g., maximum permissible total supply) decoded from the valid claim data.                Returns 0 if no valid collateral claim is found.\",\"expiryTimestamp\":\"The expiry timestamp (Unix time) decoded from the valid claim data.                         Returns 0 if no valid claim is found or if the found claim has already expired.\",\"issuer\":\"The address of the trusted `IClaimIssuer` contract that issued the valid collateral claim.                Returns `address(0)` if no valid claim is found.\"}},\"forcedRecoverTokens(address,address)\":{\"details\":\"This is a powerful administrative function. It can recover tokens even if addresses are frozen or      if other transfer conditions (like compliance checks) would normally fail.      Requires strong authorization (e.g., a FORCED_TRANSFER_ROLE).\",\"params\":{\"lostWallet\":\"The address from which tokens will be recovered.\",\"newWallet\":\"The address to which tokens will be recovered.\"}},\"forcedTransfer(address,address,uint256)\":{\"details\":\"This is a powerful administrative function. It can move tokens even if addresses are frozen or      if other transfer conditions (like compliance checks) would normally fail.      If the `from` address has partially frozen tokens, this function may automatically unfreeze      the necessary amount to cover the transfer.      The implementation typically uses an internal flag (like `__isForcedUpdate`) to bypass standard hooks      (e.g., `_beforeTransfer`) during the actual token movement.      Requires strong authorization (e.g., a FORCED_TRANSFER_ROLE).\",\"params\":{\"amount\":\"The quantity of tokens to transfer.\",\"from\":\"The address from which tokens will be transferred.\",\"to\":\"The address to which tokens will be transferred.\"},\"returns\":{\"_0\":\"bool Returns `true` upon successful execution (should revert on failure).\"}},\"freezePartialTokens(address,uint256)\":{\"details\":\"This prevents the specified `amount` of tokens from being used in standard operations by `userAddress`.      The user can still transact with their unfrozen balance.      Reverts if the `amount` to freeze exceeds the user's available (currently unfrozen) balance.      Requires authorization.\",\"params\":{\"amount\":\"The quantity of tokens to freeze.\",\"userAddress\":\"The address for which to freeze tokens.\"}},\"getFrozenTokens(address)\":{\"details\":\"This does not include tokens that are implicitly frozen because the entire address is frozen.\",\"params\":{\"userAddress\":\"The address to check.\"},\"returns\":{\"_0\":\"uint256 The amount of tokens partially frozen for the address.\"}},\"hasRole(bytes32,address)\":{\"details\":\"This function is crucial for permissioned systems, where certain actions      can only be performed by accounts holding specific roles (e.g., an admin role,      a minter role, etc.).\",\"params\":{\"account\":\"The address of the account whose roles are being checked.\",\"role\":\"The identifier of the role to check. Roles are typically represented             as a `bytes32` value, which is a fixed-size byte array often derived             from a descriptive string (e.g., keccak256(\\\"MINTER_ROLE\\\")).\"},\"returns\":{\"_0\":\"A boolean value: `true` if the account has the specified role,         `false` otherwise.\"}},\"identityRegistry()\":{\"details\":\"The Identity Registry is used for verifying token holders against required claims and linking wallets to identities.\",\"returns\":{\"registryContract\":\"The `ISMARTIdentityRegistry` contract instance currently in use.\"}},\"initialize(string,string,uint8,address,uint256,(address,bytes)[],address,address,address)\":{\"params\":{\"accessManager_\":\"The address of the access manager contract for this token.\",\"collateralTopicId_\":\"The topic ID of the collateral claim.\",\"compliance_\":\"The address of the compliance contract.\",\"decimals_\":\"The number of decimals for the deposit token.\",\"identityRegistry_\":\"The address of the identity registry contract.\",\"initialModulePairs_\":\"An array of initial compliance module and parameter pairs.\",\"name_\":\"The name of the deposit token.\",\"onchainID_\":\"Optional address of an existing onchain identity contract. Pass address(0) to create a new one.\",\"symbol_\":\"The symbol of the deposit token.\"}},\"isFrozen(address)\":{\"details\":\"A `view` function does not modify blockchain state and does not cost gas when called externally.\",\"params\":{\"userAddress\":\"The address to check.\"},\"returns\":{\"_0\":\"bool `true` if the address is frozen, `false` otherwise.\"}},\"mint(address,uint256)\":{\"details\":\"This function is typically restricted to accounts with a specific minter role.      Implementations MUST perform identity verification and compliance checks on the `_to` address before minting.      Failure to meet these checks should result in a revert (e.g., with `RecipientNotVerified` or a compliance error).      Emits `MintCompleted` and the standard ERC20 `Transfer` event (from `address(0)` to `_to`).\",\"params\":{\"_amount\":\"The quantity of tokens to mint.\",\"_to\":\"The address that will receive the newly minted tokens.\"}},\"name()\":{\"details\":\"Returns the name of the token.\"},\"onchainID()\":{\"details\":\"This can represent the token issuer or the token entity.\",\"returns\":{\"idAddress\":\"The address of the on-chain ID contract, or `address(0)` if no on-chain ID is set for the token.\"}},\"pause()\":{\"details\":\"Implementations should ensure this function can only be called by an authorized address      (e.g., through a modifier like `onlyPauser`). It should revert if the contract is already paused      to prevent redundant operations or event emissions.\"},\"paused()\":{\"details\":\"This is a `view` function, meaning it does not modify the blockchain state and does not      cost gas when called externally (e.g., from an off-chain script or another contract's view function).\",\"returns\":{\"_0\":\"bool The current paused state of the contract.\"}},\"recoverERC20(address,address,uint256)\":{\"details\":\"This function is crucial for retrieving assets that are not the SMART token itself but are held by the contract.      Access to this function MUST be strictly controlled (e.g., via an `_authorizeRecoverERC20` internal hook or role).      It is critical that this function CANNOT be used to recover the SMART token itself, as that could drain the contract or interfere with its logic.      It should use a safe transfer mechanism (like OpenZeppelin's `SafeERC20.safeTransfer`) to prevent issues with non-standard ERC20 tokens.\",\"params\":{\"amount\":\"The quantity of the `token` to recover and send to `to`.\",\"to\":\"The address where the recovered tokens will be sent.\",\"token\":\"The contract address of the ERC20 token to be recovered. This MUST NOT be `address(this)`.\"}},\"recoverTokens(address)\":{\"details\":\"This will make it possible to recover SMART tokens from the lostWallet to msgSender, if it was correctly marked as lost in the identity registry.\",\"params\":{\"_lostWallet\":\"The address of the lost wallet containing tokens to recover.\"}},\"registeredInterfaces()\":{\"details\":\"This function returns an array of bytes4 interface IDs that the token supports.\",\"returns\":{\"interfacesList\":\"An array of bytes4 interface IDs.\"}},\"removeComplianceModule(address)\":{\"details\":\"Once removed, the rules enforced by this `_module` will no longer apply to token operations.      Typically restricted to an administrative role. Emits `ComplianceModuleRemoved`.\",\"params\":{\"_module\":\"The address of the compliance module contract to remove.\"}},\"setAddressFrozen(address,bool)\":{\"details\":\"When an address is frozen, typically all standard transfers, mints (to it), and burns (from it)      are blocked. Unfreezing reverses this.      Implementations should ensure this function requires proper authorization (e.g., a FREEZER_ROLE).\",\"params\":{\"freeze\":\"`true` to freeze the address, `false` to unfreeze it.\",\"userAddress\":\"The target address whose frozen status is to be changed.\"}},\"setCompliance(address)\":{\"details\":\"The Compliance contract orchestrates checks across various compliance modules to determine transfer legality.      Typically restricted to an administrative role. Emits `ComplianceAdded`.\",\"params\":{\"_compliance\":\"The address of the new `ISMARTCompliance` contract. Must not be `address(0)`.\"}},\"setIdentityRegistry(address)\":{\"details\":\"The Identity Registry is responsible for managing associations between investor wallet addresses and their on-chain Identity contracts,      and for verifying identities against required claims.      Typically restricted to an administrative role. Emits `IdentityRegistryAdded`.\",\"params\":{\"_identityRegistry\":\"The address of the new `ISMARTIdentityRegistry` contract. Must not be `address(0)`.\"}},\"setOnchainID(address)\":{\"details\":\"This can be used to represent the token issuer or the token itself as an on-chain entity.      Typically, this function is restricted to an administrative role.\",\"params\":{\"_onchainID\":\"The address of the on-chain ID contract. Pass `address(0)` to remove an existing ID.\"}},\"setParametersForComplianceModule(address,bytes)\":{\"details\":\"This allows an administrator to change how a particular compliance rule behaves for this token.      The implementing contract (or the `ISMARTCompliance` contract) MUST validate these `_params` by calling      the module's `validateParameters(_params)` function before applying them.      Typically restricted to an administrative role. Emits `ModuleParametersUpdated`.\",\"params\":{\"_module\":\"The address of the compliance module (must be an active module for this token).\",\"_params\":\"The new ABI-encoded configuration parameters for the module.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"},\"symbol()\":{\"details\":\"Returns the symbol of the token.\"},\"totalSupply()\":{\"details\":\"Returns the value of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"unfreezePartialTokens(address,uint256)\":{\"details\":\"Reduces the partially frozen amount for `userAddress` by the specified `amount`.      Reverts if `amount` exceeds the currently frozen token amount for that address.      Requires authorization.\",\"params\":{\"amount\":\"The quantity of tokens to unfreeze.\",\"userAddress\":\"The address for which to unfreeze tokens.\"}},\"unpause()\":{\"details\":\"Similar to `pause()`, this function should be restricted to authorized addresses and should      revert if the contract is not currently paused.\"}},\"title\":\"Interface for a ATK Deposit token\",\"version\":1},\"userdoc\":{\"errors\":{\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"notice\":\"This error is functionally identical to `AccessControlUnauthorizedAccount`         defined in OpenZeppelin's `access/AccessControl.sol` contract.         Re-defining it here ensures consistency within the SMART framework and can         help in scenarios where specific error catching is needed for this module.\"}],\"CannotRecoverSelf()\":[{\"notice\":\"Error indicating an attempt to recover the token contract's own tokens.\"}],\"DuplicateModule(address)\":[{\"notice\":\"Error indicating that a compliance module is being added but already exists.\"}],\"ExpectedPause()\":[{\"notice\":\"Error reverted when an action is attempted that requires the contract to be in a paused state,         but the contract is currently not paused (i.e., it is unpaused).\"}],\"FreezeAmountExceedsAvailableBalance(uint256,uint256)\":[{\"notice\":\"Error indicating that the amount requested to be frozen exceeds the user's available (unfrozen) balance.\"}],\"InsufficientCollateral(uint256,uint256)\":[{\"notice\":\"Error: Insufficient collateral to cover the proposed total supply after minting.\"}],\"InsufficientFrozenTokens(uint256,uint256)\":[{\"notice\":\"Error indicating that an attempt to unfreeze or use frozen tokens failed because the         amount requested exceeds the currently frozen token balance for the address.\"}],\"InsufficientTokenBalance()\":[{\"notice\":\"Error indicating that the token balance is insufficient for an operation.\"}],\"InvalidCollateralTopic(uint256)\":[{\"notice\":\"Error: An invalid collateral proof topic ID was provided during initialization.\"}],\"InvalidDecimals(uint8)\":[{\"notice\":\"Error indicating that the provided decimals value is invalid.\"}],\"InvalidLostWallet()\":[{\"notice\":\"Error indicating that the provided lost wallet is not marked as lost.\"}],\"LengthMismatch()\":[{\"notice\":\"Error: Array Length Mismatch in Batch Operation.\"}],\"MintNotCompliant()\":[{\"notice\":\"Error indicating that a mint operation failed compliance checks.\"}],\"ModuleAlreadyAdded()\":[{\"notice\":\"Error indicating that an attempt was made to add a compliance module that is already registered.\"}],\"ModuleNotFound()\":[{\"notice\":\"Error indicating that a specified compliance module was not found.\"}],\"NoTokensToRecover()\":[{\"notice\":\"Error indicating that there are no tokens to recover.\"}],\"RecipientAddressFrozen()\":[{\"notice\":\"Error indicating that an operation (e.g., mint, transfer) cannot proceed because the recipient address is frozen.\"}],\"SenderAddressFrozen()\":[{\"notice\":\"Error indicating that an operation (e.g., transfer, burn, redeem) cannot proceed because the sender address is frozen.\"}],\"TokenPaused()\":[{\"notice\":\"Error reverted when an action is attempted that requires the contract to be unpaused (not paused),         but the contract is currently paused.\"}],\"TransferNotCompliant()\":[{\"notice\":\"Error indicating that a transfer operation failed compliance checks.\"}],\"ZeroAddressNotAllowed()\":[{\"notice\":\"Error: Zero Address Not Allowed.\"}]},\"events\":{\"AccessManagerSet(address,address)\":{\"notice\":\"Emitted when the address of the access manager contract is successfully changed or set.\"},\"AddressFrozen(address,address,bool)\":{\"notice\":\"Emitted when an address's full frozen status (i.e., the entire address is frozen or unfrozen)         is changed by an authorized custodian.\"},\"BurnCompleted(address,address,uint256)\":{\"notice\":\"Emitted when a token burn operation has been successfully completed.\"},\"ComplianceAdded(address,address)\":{\"notice\":\"Emitted when the address of the main `ISMARTCompliance` contract, used by this token, is successfully updated.\"},\"ComplianceModuleAdded(address,address,bytes)\":{\"notice\":\"Emitted when a new compliance module is successfully added to the token's compliance framework.\"},\"ComplianceModuleRemoved(address,address)\":{\"notice\":\"Emitted when an existing compliance module is successfully removed from the token's compliance framework.\"},\"ERC20TokenRecovered(address,address,address,uint256)\":{\"notice\":\"Emitted when mistakenly sent ERC20 tokens are recovered from the contract.\"},\"ForcedTransfer(address,address,address,uint256)\":{\"notice\":\"Emitted when a forced transfer of tokens is executed by a custodian.\"},\"IdentityRegistryAdded(address,address)\":{\"notice\":\"Emitted when the address of the `ISMARTIdentityRegistry` contract, used by this token, is successfully updated.\"},\"MintCompleted(address,address,uint256)\":{\"notice\":\"Emitted after a token minting operation has successfully completed, passing all relevant checks.\"},\"ModuleParametersUpdated(address,address,bytes)\":{\"notice\":\"Emitted when the configuration parameters for an existing, active compliance module are successfully updated.\"},\"Paused(address)\":{\"notice\":\"Emitted when the contract transitions to a paused state.\"},\"RecoverySuccess(address,address,address,address)\":{\"notice\":\"Emitted when assets are successfully recovered from a lost or compromised wallet to a new wallet         belonging to the same verified identity.\"},\"TokensFrozen(address,address,uint256)\":{\"notice\":\"Emitted when a specific amount of tokens is partially frozen for an address.\"},\"TokensRecovered(address,address,address,uint256)\":{\"notice\":\"Emitted when tokens are recovered from a lost wallet to the caller's address.\"},\"TokensUnfrozen(address,address,uint256)\":{\"notice\":\"Emitted when a specific amount of previously partially frozen tokens is unfrozen for an address.\"},\"TransferCompleted(address,address,address,uint256)\":{\"notice\":\"Emitted after a token transfer operation (e.g., via `transfer` or `transferFrom`) has successfully completed,         passing all identity and compliance checks.\"},\"Unpaused(address)\":{\"notice\":\"Emitted when the contract transitions out of a paused state (i.e., is unpaused).\"},\"UpdatedTokenInformation(address,uint8,address)\":{\"notice\":\"Emitted when fundamental information about the token, such as its decimals or on-chain ID, is updated.\"}},\"kind\":\"user\",\"methods\":{\"accessManager()\":{\"notice\":\"Returns the address of the access manager for the token.\"},\"addComplianceModule(address,bytes)\":{\"notice\":\"Adds a new compliance module contract to this token's compliance framework and sets its initial configuration parameters.\"},\"batchBurn(address[],uint256[])\":{\"notice\":\"Burns (destroys) tokens from multiple user addresses in a single transaction.\"},\"batchForcedTransfer(address[],address[],uint256[])\":{\"notice\":\"Forcefully transfers tokens for multiple address pairs in a batch.\"},\"batchFreezePartialTokens(address[],uint256[])\":{\"notice\":\"Freezes specific amounts of tokens for multiple addresses in a batch.\"},\"batchMint(address[],uint256[])\":{\"notice\":\"Mints tokens to multiple recipient addresses in a single batch transaction.\"},\"batchSetAddressFrozen(address[],bool[])\":{\"notice\":\"Freezes or unfreezes multiple addresses in a batch operation.\"},\"batchTransfer(address[],uint256[])\":{\"notice\":\"Transfers tokens from the caller to multiple recipient addresses in a single batch transaction.\"},\"batchUnfreezePartialTokens(address[],uint256[])\":{\"notice\":\"Unfreezes specific amounts of tokens for multiple addresses in a batch.\"},\"burn(address,uint256)\":{\"notice\":\"Burns (destroys) a specific amount of tokens from a given user's address.\"},\"compliance()\":{\"notice\":\"Retrieves the address of the main `ISMARTCompliance` contract currently configured for this token.\"},\"complianceModules()\":{\"notice\":\"Retrieves a list of all currently active compliance modules for this token, along with their configuration parameters.\"},\"findValidCollateralClaim()\":{\"notice\":\"Attempts to find the first valid collateral claim associated with the token contract's         own OnchainID identity, based on a pre-configured claim topic.\"},\"forcedRecoverTokens(address,address)\":{\"notice\":\"Forcefully recovers tokens from a lost or compromised wallet to a new wallet belonging to the same         verified identity.\"},\"forcedTransfer(address,address,uint256)\":{\"notice\":\"Forcefully transfers tokens from one address to another, bypassing standard transfer restrictions.\"},\"freezePartialTokens(address,uint256)\":{\"notice\":\"Freezes a specific amount of tokens for a given address.\"},\"getFrozenTokens(address)\":{\"notice\":\"Gets the amount of tokens that are specifically (partially) frozen for an address.\"},\"hasRole(bytes32,address)\":{\"notice\":\"Checks if a given account has a specific role.\"},\"identityRegistry()\":{\"notice\":\"Retrieves the address of the `ISMARTIdentityRegistry` contract currently configured for this token.\"},\"initialize(string,string,uint8,address,uint256,(address,bytes)[],address,address,address)\":{\"notice\":\"Initializes the ATK Deposit token contract.\"},\"isFrozen(address)\":{\"notice\":\"Checks if an address is currently fully frozen.\"},\"mint(address,uint256)\":{\"notice\":\"Creates (mints) a specified `_amount` of new tokens and assigns them to the `_to` address.\"},\"onchainID()\":{\"notice\":\"Retrieves the optional on-chain identifier (e.g., an `IIdentity` contract) associated with the token contract itself.\"},\"pause()\":{\"notice\":\"Pauses the contract, which typically prevents certain actions like token transfers.\"},\"paused()\":{\"notice\":\"Returns `true` if the contract is currently paused, and `false` otherwise.\"},\"recoverERC20(address,address,uint256)\":{\"notice\":\"Allows an authorized account to recover ERC20 tokens that were mistakenly sent to this SMART token contract's address.\"},\"recoverTokens(address)\":{\"notice\":\"Recovers SMART tokens from a lost wallet to the caller's address.\"},\"registeredInterfaces()\":{\"notice\":\"Retrieves a list of all currently active interfaces for this token.\"},\"removeComplianceModule(address)\":{\"notice\":\"Removes an active compliance module from this token's compliance framework.\"},\"setAddressFrozen(address,bool)\":{\"notice\":\"Freezes or unfreezes an entire address, preventing or allowing standard token operations.\"},\"setCompliance(address)\":{\"notice\":\"Sets or updates the address of the main `ISMARTCompliance` contract used by this token.\"},\"setIdentityRegistry(address)\":{\"notice\":\"Sets or updates the address of the `ISMARTIdentityRegistry` contract used by this token.\"},\"setOnchainID(address)\":{\"notice\":\"Sets or updates the optional on-chain identifier (e.g., an `IIdentity` contract) associated with the token contract itself.\"},\"setParametersForComplianceModule(address,bytes)\":{\"notice\":\"Sets or updates the configuration parameters for a specific, already added compliance module.\"},\"unfreezePartialTokens(address,uint256)\":{\"notice\":\"Unfreezes a specific amount of previously partially frozen tokens for an address.\"},\"unpause()\":{\"notice\":\"Unpauses the contract, resuming normal operations (e.g., allowing token transfers again).\"}},\"notice\":\"Defines the core functionality and extensions for a ATK Deposit token.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/assets/deposit/IATKDeposit.sol\":\"IATKDeposit\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@axelar-network/axelar-gmp-sdk-solidity/=dependencies/openzeppelin-community-contracts-0.0.1/node_modules/@axelar-network/axelar-gmp-sdk-solidity/\",\":@onchainid-v2.2.1/=dependencies/@onchainid-v2.2.1/contracts/\",\":@onchainid/contracts/=dependencies/@onchainid-v2.2.1/contracts/\",\":@openzeppelin-contracts-5.2.0/=dependencies/@openzeppelin-contracts-5.2.0/\",\":@openzeppelin-contracts-5.3.0/=dependencies/@openzeppelin-contracts-5.3.0/\",\":@openzeppelin-contracts-upgradeable-5.2.0/=dependencies/@openzeppelin-contracts-upgradeable-5.2.0/\",\":@openzeppelin-contracts-upgradeable-5.3.0/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/\",\":@openzeppelin/community-contracts/=dependencies/openzeppelin-community-contracts-0.0.1/contracts/\",\":@openzeppelin/contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/\",\":@openzeppelin/contracts/=dependencies/@openzeppelin-contracts-5.3.0/\",\":@smartprotocol-v0.0.1/=dependencies/@smartprotocol-v0.0.1/contracts/\",\":eas-contracts-1.4.0/=dependencies/eas-contracts-1.4.0/contracts/\",\":forge-std-1.9.5/=dependencies/forge-std-1.9.5/src/\",\":forge-std-1.9.6/=dependencies/forge-std-1.9.6/src/\",\":forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/\",\":forge-std/=dependencies/forge-std-1.9.7/src/\",\":hardhat/=dependencies/smart-protocol-8.0.8/node_modules/hardhat/\",\":openzeppelin-community-contracts-0.0.1/=dependencies/openzeppelin-community-contracts-0.0.1/contracts/\",\":smart-protocol-8.0.10/=dependencies/smart-protocol-8.0.10/contracts/\",\":smart-protocol-8.0.5/=dependencies/smart-protocol-8.0.5/contracts/\",\":smart-protocol-8.0.7/=dependencies/smart-protocol-8.0.7/contracts/\",\":smart-protocol-8.0.8/=dependencies/smart-protocol-8.0.8/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/assets/deposit/IATKDeposit.sol\":{\"keccak256\":\"0xb75d03a0a529589437c42f57cf1e12b3b9303ea976117cb3b05edd76dfea1f08\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://7d39b1facf0d305e727eb9d276aa0eea69506e5185b0ad080d29b425aa641209\",\"dweb:/ipfs/QmcAEwoGz5uxRX66zR7DDaf1ovqiqB6K2a1RR2kc717bwy\"]},\"contracts/smart/extensions/access-managed/ISMARTTokenAccessManaged.sol\":{\"keccak256\":\"0xb05c08191398db750d9fd974e8df1bace09434c27fd81a9db7d36ff429affd97\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://5155ee4da616fb8e3365c933952b07b93d603c6a4eb6542433b08c651a0e0c25\",\"dweb:/ipfs/QmW4C4YbYuDLX32oEFrp11t9TK44B5otKCXQemXs1jMgCD\"]},\"contracts/smart/extensions/burnable/ISMARTBurnable.sol\":{\"keccak256\":\"0x4b3408d79782202ec6b6f01f615b13ca00ad9c5974208acfa3d2ae8be3d28f1d\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://df0fe9c4bb881f299c985f917761f16b7a2118d840cf36060f99e54fcc9f7f68\",\"dweb:/ipfs/QmPQrXG8UPPzK2Wt1aYNgPC2F17Yq5Bs2TW4Bt9fDjXo42\"]},\"contracts/smart/extensions/collateral/ISMARTCollateral.sol\":{\"keccak256\":\"0x822bf674043d5c717d66f1b9b21fdafd260db4ab9ec7fe3d59561d90ee72bcdb\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://3ca1244fdd5e5f9737c7d36ce509fa041c41bff32744bb4a46835e49d9d4f0c0\",\"dweb:/ipfs/QmYhtFGkBqL4ZVDErazggigrsd3dYX33D1utbVp3JHB2Ft\"]},\"contracts/smart/extensions/custodian/ISMARTCustodian.sol\":{\"keccak256\":\"0xf7f74718eeb2d259be46ff82c7232c11b125127feb844d8140f3cff47c0c1663\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://97465ae7ef179d5abeedcf57c7fb7cd3f933268da501ae2694a82731f046f119\",\"dweb:/ipfs/QmQivprpP7h75X57xioAnrNtGkGjZaqkSndwY3CUcAXb5V\"]},\"contracts/smart/extensions/pausable/ISMARTPausable.sol\":{\"keccak256\":\"0xab4d6f4bae5e7e8166d3c6206ea8ecd9742c02fb3a82f1420266b4a5872a0497\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://a437838b9641a1c59910296decade4a5c397e12127160983eadafb6ab8514582\",\"dweb:/ipfs/QmNMndn4dMgkjGABjuYHdaHEaL6XwdsJwmsaT2WQugrxR1\"]},\"contracts/smart/interface/ERC-3643/IERC3643IdentityRegistryStorage.sol\":{\"keccak256\":\"0x3a8a72df8da5bf4d988bbfb00151b933ff17cdc8d4be47dc121cd9e2083ba86f\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://369250658bf8d3ebb583946820afa494271ce6bfde607d15c7060cdf7a303cf3\",\"dweb:/ipfs/QmSJjaK6vyv8K9RX1k3rwxsoKfVNyMoHEszxyxdTQfDKQG\"]},\"contracts/smart/interface/ERC-3643/IERC3643TrustedIssuersRegistry.sol\":{\"keccak256\":\"0x15b72940814cd959b57bf75623f16c51fc6c50eab51fd2420a8b653519ebd76c\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://479f5e24a1b608776d9d5d7da9c76dd3c9b1dd300d8b4eee7a15dcfba4817bee\",\"dweb:/ipfs/QmPhMBfQAqt5NeRcSu3jDTwhoQXnB7nXNEcmoJ7KoWVt7V\"]},\"contracts/smart/interface/ISMART.sol\":{\"keccak256\":\"0xfce323160dd5cd8c9db34de0ea872bec41fd2ea8d8496e1e3c17865d374994da\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://1a1fafbdec0c59e078798438d2a3cd05bd70b864d7dfa67faf135d5634c5ae51\",\"dweb:/ipfs/QmehZwexgZN2BZKA6eFrG3DHUMRUZnzYTen6j5Ry5Znbf2\"]},\"contracts/smart/interface/ISMARTCompliance.sol\":{\"keccak256\":\"0x948341e4ad374e1dded6d1b30c395ad0f01e6ea2099fb6b96c5476e8b28c1d77\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://d261e9a0c8682f11ac86048f13e367caee6d5f512d51b8752186b8c01b6ba618\",\"dweb:/ipfs/Qmdp14emh3NFSAphyuAgsTE7qZt1g1UYcNLS3tNNM8T6Hv\"]},\"contracts/smart/interface/ISMARTIdentityRegistry.sol\":{\"keccak256\":\"0x62a95a9db2ac97ceaf59f7585d7bbaf3acb65ed9b5e57597b9d1fe1b4d7c4eda\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://bd870710359396db48e70ef7e40449125ff744c6c8ce15ad7e1894df430c87ea\",\"dweb:/ipfs/QmZ6khf5Vm6hBkkUgYC1b161jSQaZeegJVRY6ndjRW1EcG\"]},\"contracts/smart/interface/ISMARTIdentityRegistryStorage.sol\":{\"keccak256\":\"0x219b3d03958859e2f082aac5cbf3b40acf243e326ee6e74e6bb03be7724c2985\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://8cf8d30ec47cb2aed5b51d373837584fb6f08deab1d35142510271e733404f52\",\"dweb:/ipfs/Qmc9NnABx9ouhhCR8qgJC3RtU5oAyycSjZkY6nGtuWFwuz\"]},\"contracts/smart/interface/ISMARTTopicSchemeRegistry.sol\":{\"keccak256\":\"0xec5e42dcf7d929f8a0db42c9c8a0fa81d089a9f7177b7da10df029f94334ca8a\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://e346e3241e3110b3f17d2b244a49d68a1d79c6928bef7d372ea3458c1029cea0\",\"dweb:/ipfs/QmeSyCYN9qYXRjn799fRFP7X9apf7bubVhnFEUGQatx3xd\"]},\"contracts/smart/interface/structs/SMARTComplianceModuleParamPair.sol\":{\"keccak256\":\"0x489a55538b554a0c935bee7efc28f7e821e161638c5726c9d367a644a0b7c62a\",\"license\":\"FSL-1.1-MIT\",\"urls\":[\"bzz-raw://04bb06aed3ee3c5c6f3df9a59721c08ddd57b5521da1c9c6fd96b7c8b57db813\",\"dweb:/ipfs/QmRuzqKDr2sBHNuQhCzWGa8euNiMyvP7LTjSFjvAj5uFqh\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IClaimIssuer.sol\":{\"keccak256\":\"0xae785f63b3cb3a94bcb454ef4ad6376aa4848fa29cff1cc8db3bef4a2994a779\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://d8223d2710c51ee39cdfd2cb2f1858b3d64a3222c78ea8ed5eb3e11a93e1222e\",\"dweb:/ipfs/QmYRXPCww7BorScTC6QNMbrRm2zprUmSYFpWomwarJH7Df\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IERC734.sol\":{\"keccak256\":\"0x35a14a0d1a3ed51689f1a2cb12e26d30601afbcc1cc9b9b288a03cd11e6d049e\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://156aac402e73e6bd2fa8c0ccd85b2add8d1bb505d8a652218173dbc8e7b9a3cb\",\"dweb:/ipfs/QmPzPyc3kKxoNCGqKAooUju6YvMkDN4MCUH198TEXnA82o\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IERC735.sol\":{\"keccak256\":\"0xeac82c37b16c1c1c83df3e88be987332b1230ed13e1d017f9d2929f978ac0122\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://695a66b789ac417b7b2b78c578981779db374704382921ff499351cccab0323e\",\"dweb:/ipfs/QmeZoogvsEWf688Z849zZ2dLPDnor6YnnNQLMgedY9Tc9D\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IIdentity.sol\":{\"keccak256\":\"0x5ed42ab81b9b734c79e61d1f7e0734baab5479a356ab6bb469414d3c66269862\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://a0863999b1ed334179a43e699e6057815eea011a78ed51e61b6110fc392e26f8\",\"dweb:/ipfs/Qme6hdHZCAy1V4sLgAZ5NxdrEjEf5mYMabf5UDmUDjkuzW\"]},\"dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db\",\"dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9\"]},\"dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x70f2f713b13b7ce4610bcd0ac9fec0f3cc43693b043abcb8dc40a42a726eb330\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c13d13304ac79a83ab1c30168967d19e2203342ebbd6a9bbce4db7550522dcbf\",\"dweb:/ipfs/QmeN5jKMN2vw5bhacr6tkg78afbTTZUeaacNHqjWt4Ew1r\"]},\"dependencies/@openzeppelin-contracts-5.3.0/utils/introspection/IERC165.sol\":{\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f6fda447a62815e8064f47eff0dd1cf58d9207ad69b5d32280f8d7ed1d1e4621\",\"dweb:/ipfs/QmfDRc7pxfaXB2Dh9np5Uf29Na3pQ7tafRS684wd3GLjVL\"]}},\"version\":1}",
  "metadata": {
    "compiler": {
      "version": "0.8.28+commit.7893614a"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "neededRole",
              "type": "bytes32"
            }
          ],
          "type": "error",
          "name": "AccessControlUnauthorizedAccount"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "CannotRecoverSelf"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            }
          ],
          "type": "error",
          "name": "DuplicateModule"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "ExpectedPause"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "available",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "requested",
              "type": "uint256"
            }
          ],
          "type": "error",
          "name": "FreezeAmountExceedsAvailableBalance"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "required",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "available",
              "type": "uint256"
            }
          ],
          "type": "error",
          "name": "InsufficientCollateral"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "frozenBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "requested",
              "type": "uint256"
            }
          ],
          "type": "error",
          "name": "InsufficientFrozenTokens"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "InsufficientTokenBalance"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "topicId",
              "type": "uint256"
            }
          ],
          "type": "error",
          "name": "InvalidCollateralTopic"
        },
        {
          "inputs": [
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "type": "error",
          "name": "InvalidDecimals"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "InvalidLostWallet"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "LengthMismatch"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "MintNotCompliant"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "ModuleAlreadyAdded"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "ModuleNotFound"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "NoTokensToRecover"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "RecipientAddressFrozen"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "SenderAddressFrozen"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "TokenPaused"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "TransferNotCompliant"
        },
        {
          "inputs": [],
          "type": "error",
          "name": "ZeroAddressNotAllowed"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "manager",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "AccessManagerSet",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "bool",
              "name": "isFrozen",
              "type": "bool",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "AddressFrozen",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "Approval",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "BurnCompleted",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "_compliance",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "ComplianceAdded",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "_module",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "bytes",
              "name": "_params",
              "type": "bytes",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "ComplianceModuleAdded",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "_module",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "ComplianceModuleRemoved",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "ERC20TokenRecovered",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "ForcedTransfer",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "_identityRegistry",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "IdentityRegistryAdded",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "MintCompleted",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "_module",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "bytes",
              "name": "_params",
              "type": "bytes",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "ModuleParametersUpdated",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "Paused",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "lostWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "newWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "investorOnchainID",
              "type": "address",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "RecoverySuccess",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "TokensFrozen",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "lostWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "newWallet",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "TokensRecovered",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "TokensUnfrozen",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "Transfer",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "from",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "TransferCompleted",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "Unpaused",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint8",
              "name": "_newDecimals",
              "type": "uint8",
              "indexed": false
            },
            {
              "internalType": "address",
              "name": "_newOnchainID",
              "type": "address",
              "indexed": true
            }
          ],
          "type": "event",
          "name": "UpdatedTokenInformation",
          "anonymous": false
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "accessManager",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_module",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "_params",
              "type": "bytes"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addComplianceModule"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "spender",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "spender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchBurn"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "fromList",
              "type": "address[]"
            },
            {
              "internalType": "address[]",
              "name": "toList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchForcedTransfer"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchFreezePartialTokens"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_toList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchMint"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "bool[]",
              "name": "freeze",
              "type": "bool[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchSetAddressFrozen"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_toList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchTransfer"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchUnfreezePartialTokens"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "compliance",
          "outputs": [
            {
              "internalType": "contract ISMARTCompliance",
              "name": "complianceContract",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "complianceModules",
          "outputs": [
            {
              "internalType": "struct SMARTComplianceModuleParamPair[]",
              "name": "modulesList",
              "type": "tuple[]",
              "components": [
                {
                  "internalType": "address",
                  "name": "module",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "params",
                  "type": "bytes"
                }
              ]
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "outputs": [
            {
              "internalType": "uint8",
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "findValidCollateralClaim",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "issuer",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "expiryTimestamp",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "lostWallet",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "newWallet",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "forcedRecoverTokens"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "forcedTransfer",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "freezePartialTokens"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "getFrozenTokens",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "role",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "hasRole",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "identityRegistry",
          "outputs": [
            {
              "internalType": "contract ISMARTIdentityRegistry",
              "name": "registryContract",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "name_",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol_",
              "type": "string"
            },
            {
              "internalType": "uint8",
              "name": "decimals_",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "onchainID_",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "collateralTopicId_",
              "type": "uint256"
            },
            {
              "internalType": "struct SMARTComplianceModuleParamPair[]",
              "name": "initialModulePairs_",
              "type": "tuple[]",
              "components": [
                {
                  "internalType": "address",
                  "name": "module",
                  "type": "address"
                },
                {
                  "internalType": "bytes",
                  "name": "params",
                  "type": "bytes"
                }
              ]
            },
            {
              "internalType": "address",
              "name": "identityRegistry_",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "compliance_",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "accessManager_",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initialize"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "isFrozen",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "onchainID",
          "outputs": [
            {
              "internalType": "address",
              "name": "idAddress",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "paused",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverERC20"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_lostWallet",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverTokens"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "registeredInterfaces",
          "outputs": [
            {
              "internalType": "bytes4[]",
              "name": "interfacesList",
              "type": "bytes4[]"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_module",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeComplianceModule"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "freeze",
              "type": "bool"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddressFrozen"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_compliance",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompliance"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_identityRegistry",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIdentityRegistry"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_onchainID",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOnchainID"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_module",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "_params",
              "type": "bytes"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setParametersForComplianceModule"
        },
        {
          "inputs": [
            {
              "internalType": "bytes4",
              "name": "interfaceId",
              "type": "bytes4"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "supportsInterface",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "userAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "unfreezePartialTokens"
        },
        {
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "unpause"
        }
      ],
      "devdoc": {
        "kind": "dev",
        "methods": {
          "accessManager()": {
            "returns": {
              "_0": "The address of the access manager."
            }
          },
          "addComplianceModule(address,bytes)": {
            "details": "Before adding, the implementation (or the main `ISMARTCompliance` contract) MUST validate:      1. That `_module` is a valid contract address.      2. That `_module` correctly implements the `ISMARTComplianceModule` interface (e.g., via ERC165 `supportsInterface`).      3. That the provided `_params` are valid for the `_module` (by calling `_module.validateParameters(_params)`).      Typically restricted to an administrative role. Emits `ComplianceModuleAdded`.",
            "params": {
              "_module": "The address of the compliance module contract to add.",
              "_params": "The initial ABI-encoded configuration parameters for this module specific to this token."
            }
          },
          "allowance(address,address)": {
            "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
          },
          "approve(address,uint256)": {
            "details": "Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
          },
          "balanceOf(address)": {
            "details": "Returns the value of tokens owned by `account`."
          },
          "batchBurn(address[],uint256[])": {
            "details": "This function allows for efficient batch processing of token burns, which can save on      transaction fees (gas) compared to calling `burn` multiple times individually.      It requires that the `userAddresses` array and the `amounts` array have the same number of elements,      with each `amounts[i]` corresponding to `userAddresses[i]`.      Similar to the single `burn` function, authorization for each individual burn within the batch      is expected to be handled by the implementing contract (e.g., via an `_authorizeBurn` hook).      If the lengths of the input arrays do not match, the transaction should revert to prevent errors.",
            "params": {
              "amounts": "An array of token quantities to be burned. `amounts[i]` tokens will be burned                from `userAddresses[i]`.",
              "userAddresses": "An array of blockchain addresses from which tokens will be burned."
            }
          },
          "batchForcedTransfer(address[],address[],uint256[])": {
            "details": "A gas-efficient version of `forcedTransfer` for multiple operations.      Requires strong authorization for the entire batch.      Arrays `fromList`, `toList`, and `amounts` must be of the same length.",
            "params": {
              "amounts": "A list of corresponding token amounts to transfer.",
              "fromList": "A list of sender addresses.",
              "toList": "A list of recipient addresses."
            }
          },
          "batchFreezePartialTokens(address[],uint256[])": {
            "details": "Allows freezing different amounts for different users simultaneously.      Requires authorization for each partial freeze operation.      Arrays must be of the same length.",
            "params": {
              "amounts": "A list of corresponding token amounts to freeze.",
              "userAddresses": "A list of target addresses."
            }
          },
          "batchMint(address[],uint256[])": {
            "details": "This is an efficiency function to reduce transaction costs when minting to many users.      Typically restricted to accounts with a specific minter role.      Implementations MUST perform identity verification and compliance checks for *each* recipient in `_toList`.      If any recipient fails checks, the entire batch operation should revert to maintain atomicity.      Emits multiple `MintCompleted` and ERC20 `Transfer` events.",
            "params": {
              "_amounts": "An array of corresponding token quantities to mint for each address in `_toList`. The lengths of `_toList` and `_amounts` MUST be equal.",
              "_toList": "An array of addresses to receive the newly minted tokens."
            }
          },
          "batchSetAddressFrozen(address[],bool[])": {
            "details": "A gas-efficient way to update the frozen status for several addresses at once.      Requires authorization for each underlying freeze/unfreeze operation.      The `userAddresses` and `freeze` arrays must be of the same length.",
            "params": {
              "freeze": "A list of corresponding boolean freeze statuses (`true` for freeze, `false` for unfreeze).",
              "userAddresses": "A list of target addresses."
            }
          },
          "batchTransfer(address[],uint256[])": {
            "details": "This is an efficiency function, useful for distributions or airdrops (if compliant).      The caller (`msg.sender`) must have a sufficient balance to cover the sum of all `_amounts`.      Implementations MUST perform identity verification and compliance checks for *each* recipient in `_toList`      and also check the sender (`msg.sender`) if sender-side compliance rules apply.      If any part of the batch fails checks, the entire operation should revert.      Emits multiple `TransferCompleted` and ERC20 `Transfer` events.",
            "params": {
              "_amounts": "An array of corresponding token quantities to transfer. The lengths of `_toList` and `_amounts` MUST be equal.",
              "_toList": "An array of addresses to receive the tokens."
            }
          },
          "batchUnfreezePartialTokens(address[],uint256[])": {
            "details": "Allows unfreezing different amounts for different users simultaneously.      Requires authorization for each partial unfreeze operation.      Arrays must be of the same length.",
            "params": {
              "amounts": "A list of corresponding token amounts to unfreeze.",
              "userAddresses": "A list of target addresses."
            }
          },
          "burn(address,uint256)": {
            "details": "This function is intended for an authorized operator (like an admin or a special role)      to burn tokens on behalf of a user, or from a specific account as part of token management.      The actual authorization logic (who can call this) is typically handled by the contract      implementing this interface, often through a mechanism like an `_authorizeBurn` hook.      The function signature and intent are similar to `operatorBurn` as suggested by standards      like ERC3643, where an operator can manage token holdings.",
            "params": {
              "amount": "The quantity of tokens to burn. This should be a non-negative integer.",
              "userAddress": "The blockchain address of the account from which tokens will be burned.                    This is the account whose token balance will decrease."
            }
          },
          "compliance()": {
            "details": "The Compliance contract is responsible for orchestrating compliance checks for token operations.",
            "returns": {
              "complianceContract": "The `ISMARTCompliance` contract instance currently in use."
            }
          },
          "complianceModules()": {
            "details": "Each element in the returned array is a `SMARTComplianceModuleParamPair` struct, containing the module's address      and its current ABI-encoded parameters specific to this token.",
            "returns": {
              "modulesList": "An array of `SMARTComplianceModuleParamPair` structs."
            }
          },
          "decimals()": {
            "details": "Returns the decimals places of the token."
          },
          "findValidCollateralClaim()": {
            "details": "This function is expected to perform several checks:      1. Retrieve claim IDs from the token's identity contract (`this.onchainID()`) for the configured `collateralProofTopic`.      2. For each claim, verify its issuer is trusted for that topic via the `identityRegistry`'s `issuersRegistry`.      3. Confirm the trusted issuer contract itself deems the claim valid (e.g., via `IClaimIssuer.isClaimValid`).      4. Decode the claim data, which is expected to contain a collateral `amount` and an `expiryTimestamp`.      5. Ensure the claim has not expired (i.e., `decodedExpiry > block.timestamp`).      The function should return the details of the *first* claim that successfully passes all these validations.      If no such claim is found, it should return zero values.      This is a `view` function, meaning it reads blockchain state but does not modify it, and thus      does not consume gas when called as a read-only operation from off-chain.",
            "returns": {
              "amount": "The collateral amount (e.g., maximum permissible total supply) decoded from the valid claim data.                Returns 0 if no valid collateral claim is found.",
              "expiryTimestamp": "The expiry timestamp (Unix time) decoded from the valid claim data.                         Returns 0 if no valid claim is found or if the found claim has already expired.",
              "issuer": "The address of the trusted `IClaimIssuer` contract that issued the valid collateral claim.                Returns `address(0)` if no valid claim is found."
            }
          },
          "forcedRecoverTokens(address,address)": {
            "details": "This is a powerful administrative function. It can recover tokens even if addresses are frozen or      if other transfer conditions (like compliance checks) would normally fail.      Requires strong authorization (e.g., a FORCED_TRANSFER_ROLE).",
            "params": {
              "lostWallet": "The address from which tokens will be recovered.",
              "newWallet": "The address to which tokens will be recovered."
            }
          },
          "forcedTransfer(address,address,uint256)": {
            "details": "This is a powerful administrative function. It can move tokens even if addresses are frozen or      if other transfer conditions (like compliance checks) would normally fail.      If the `from` address has partially frozen tokens, this function may automatically unfreeze      the necessary amount to cover the transfer.      The implementation typically uses an internal flag (like `__isForcedUpdate`) to bypass standard hooks      (e.g., `_beforeTransfer`) during the actual token movement.      Requires strong authorization (e.g., a FORCED_TRANSFER_ROLE).",
            "params": {
              "amount": "The quantity of tokens to transfer.",
              "from": "The address from which tokens will be transferred.",
              "to": "The address to which tokens will be transferred."
            },
            "returns": {
              "_0": "bool Returns `true` upon successful execution (should revert on failure)."
            }
          },
          "freezePartialTokens(address,uint256)": {
            "details": "This prevents the specified `amount` of tokens from being used in standard operations by `userAddress`.      The user can still transact with their unfrozen balance.      Reverts if the `amount` to freeze exceeds the user's available (currently unfrozen) balance.      Requires authorization.",
            "params": {
              "amount": "The quantity of tokens to freeze.",
              "userAddress": "The address for which to freeze tokens."
            }
          },
          "getFrozenTokens(address)": {
            "details": "This does not include tokens that are implicitly frozen because the entire address is frozen.",
            "params": {
              "userAddress": "The address to check."
            },
            "returns": {
              "_0": "uint256 The amount of tokens partially frozen for the address."
            }
          },
          "hasRole(bytes32,address)": {
            "details": "This function is crucial for permissioned systems, where certain actions      can only be performed by accounts holding specific roles (e.g., an admin role,      a minter role, etc.).",
            "params": {
              "account": "The address of the account whose roles are being checked.",
              "role": "The identifier of the role to check. Roles are typically represented             as a `bytes32` value, which is a fixed-size byte array often derived             from a descriptive string (e.g., keccak256(\"MINTER_ROLE\"))."
            },
            "returns": {
              "_0": "A boolean value: `true` if the account has the specified role,         `false` otherwise."
            }
          },
          "identityRegistry()": {
            "details": "The Identity Registry is used for verifying token holders against required claims and linking wallets to identities.",
            "returns": {
              "registryContract": "The `ISMARTIdentityRegistry` contract instance currently in use."
            }
          },
          "initialize(string,string,uint8,address,uint256,(address,bytes)[],address,address,address)": {
            "params": {
              "accessManager_": "The address of the access manager contract for this token.",
              "collateralTopicId_": "The topic ID of the collateral claim.",
              "compliance_": "The address of the compliance contract.",
              "decimals_": "The number of decimals for the deposit token.",
              "identityRegistry_": "The address of the identity registry contract.",
              "initialModulePairs_": "An array of initial compliance module and parameter pairs.",
              "name_": "The name of the deposit token.",
              "onchainID_": "Optional address of an existing onchain identity contract. Pass address(0) to create a new one.",
              "symbol_": "The symbol of the deposit token."
            }
          },
          "isFrozen(address)": {
            "details": "A `view` function does not modify blockchain state and does not cost gas when called externally.",
            "params": {
              "userAddress": "The address to check."
            },
            "returns": {
              "_0": "bool `true` if the address is frozen, `false` otherwise."
            }
          },
          "mint(address,uint256)": {
            "details": "This function is typically restricted to accounts with a specific minter role.      Implementations MUST perform identity verification and compliance checks on the `_to` address before minting.      Failure to meet these checks should result in a revert (e.g., with `RecipientNotVerified` or a compliance error).      Emits `MintCompleted` and the standard ERC20 `Transfer` event (from `address(0)` to `_to`).",
            "params": {
              "_amount": "The quantity of tokens to mint.",
              "_to": "The address that will receive the newly minted tokens."
            }
          },
          "name()": {
            "details": "Returns the name of the token."
          },
          "onchainID()": {
            "details": "This can represent the token issuer or the token entity.",
            "returns": {
              "idAddress": "The address of the on-chain ID contract, or `address(0)` if no on-chain ID is set for the token."
            }
          },
          "pause()": {
            "details": "Implementations should ensure this function can only be called by an authorized address      (e.g., through a modifier like `onlyPauser`). It should revert if the contract is already paused      to prevent redundant operations or event emissions."
          },
          "paused()": {
            "details": "This is a `view` function, meaning it does not modify the blockchain state and does not      cost gas when called externally (e.g., from an off-chain script or another contract's view function).",
            "returns": {
              "_0": "bool The current paused state of the contract."
            }
          },
          "recoverERC20(address,address,uint256)": {
            "details": "This function is crucial for retrieving assets that are not the SMART token itself but are held by the contract.      Access to this function MUST be strictly controlled (e.g., via an `_authorizeRecoverERC20` internal hook or role).      It is critical that this function CANNOT be used to recover the SMART token itself, as that could drain the contract or interfere with its logic.      It should use a safe transfer mechanism (like OpenZeppelin's `SafeERC20.safeTransfer`) to prevent issues with non-standard ERC20 tokens.",
            "params": {
              "amount": "The quantity of the `token` to recover and send to `to`.",
              "to": "The address where the recovered tokens will be sent.",
              "token": "The contract address of the ERC20 token to be recovered. This MUST NOT be `address(this)`."
            }
          },
          "recoverTokens(address)": {
            "details": "This will make it possible to recover SMART tokens from the lostWallet to msgSender, if it was correctly marked as lost in the identity registry.",
            "params": {
              "_lostWallet": "The address of the lost wallet containing tokens to recover."
            }
          },
          "registeredInterfaces()": {
            "details": "This function returns an array of bytes4 interface IDs that the token supports.",
            "returns": {
              "interfacesList": "An array of bytes4 interface IDs."
            }
          },
          "removeComplianceModule(address)": {
            "details": "Once removed, the rules enforced by this `_module` will no longer apply to token operations.      Typically restricted to an administrative role. Emits `ComplianceModuleRemoved`.",
            "params": {
              "_module": "The address of the compliance module contract to remove."
            }
          },
          "setAddressFrozen(address,bool)": {
            "details": "When an address is frozen, typically all standard transfers, mints (to it), and burns (from it)      are blocked. Unfreezing reverses this.      Implementations should ensure this function requires proper authorization (e.g., a FREEZER_ROLE).",
            "params": {
              "freeze": "`true` to freeze the address, `false` to unfreeze it.",
              "userAddress": "The target address whose frozen status is to be changed."
            }
          },
          "setCompliance(address)": {
            "details": "The Compliance contract orchestrates checks across various compliance modules to determine transfer legality.      Typically restricted to an administrative role. Emits `ComplianceAdded`.",
            "params": {
              "_compliance": "The address of the new `ISMARTCompliance` contract. Must not be `address(0)`."
            }
          },
          "setIdentityRegistry(address)": {
            "details": "The Identity Registry is responsible for managing associations between investor wallet addresses and their on-chain Identity contracts,      and for verifying identities against required claims.      Typically restricted to an administrative role. Emits `IdentityRegistryAdded`.",
            "params": {
              "_identityRegistry": "The address of the new `ISMARTIdentityRegistry` contract. Must not be `address(0)`."
            }
          },
          "setOnchainID(address)": {
            "details": "This can be used to represent the token issuer or the token itself as an on-chain entity.      Typically, this function is restricted to an administrative role.",
            "params": {
              "_onchainID": "The address of the on-chain ID contract. Pass `address(0)` to remove an existing ID."
            }
          },
          "setParametersForComplianceModule(address,bytes)": {
            "details": "This allows an administrator to change how a particular compliance rule behaves for this token.      The implementing contract (or the `ISMARTCompliance` contract) MUST validate these `_params` by calling      the module's `validateParameters(_params)` function before applying them.      Typically restricted to an administrative role. Emits `ModuleParametersUpdated`.",
            "params": {
              "_module": "The address of the compliance module (must be an active module for this token).",
              "_params": "The new ABI-encoded configuration parameters for the module."
            }
          },
          "supportsInterface(bytes4)": {
            "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
          },
          "symbol()": {
            "details": "Returns the symbol of the token."
          },
          "totalSupply()": {
            "details": "Returns the value of tokens in existence."
          },
          "transfer(address,uint256)": {
            "details": "Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
          },
          "transferFrom(address,address,uint256)": {
            "details": "Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
          },
          "unfreezePartialTokens(address,uint256)": {
            "details": "Reduces the partially frozen amount for `userAddress` by the specified `amount`.      Reverts if `amount` exceeds the currently frozen token amount for that address.      Requires authorization.",
            "params": {
              "amount": "The quantity of tokens to unfreeze.",
              "userAddress": "The address for which to unfreeze tokens."
            }
          },
          "unpause()": {
            "details": "Similar to `pause()`, this function should be restricted to authorized addresses and should      revert if the contract is not currently paused."
          }
        },
        "version": 1
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "accessManager()": {
            "notice": "Returns the address of the access manager for the token."
          },
          "addComplianceModule(address,bytes)": {
            "notice": "Adds a new compliance module contract to this token's compliance framework and sets its initial configuration parameters."
          },
          "batchBurn(address[],uint256[])": {
            "notice": "Burns (destroys) tokens from multiple user addresses in a single transaction."
          },
          "batchForcedTransfer(address[],address[],uint256[])": {
            "notice": "Forcefully transfers tokens for multiple address pairs in a batch."
          },
          "batchFreezePartialTokens(address[],uint256[])": {
            "notice": "Freezes specific amounts of tokens for multiple addresses in a batch."
          },
          "batchMint(address[],uint256[])": {
            "notice": "Mints tokens to multiple recipient addresses in a single batch transaction."
          },
          "batchSetAddressFrozen(address[],bool[])": {
            "notice": "Freezes or unfreezes multiple addresses in a batch operation."
          },
          "batchTransfer(address[],uint256[])": {
            "notice": "Transfers tokens from the caller to multiple recipient addresses in a single batch transaction."
          },
          "batchUnfreezePartialTokens(address[],uint256[])": {
            "notice": "Unfreezes specific amounts of tokens for multiple addresses in a batch."
          },
          "burn(address,uint256)": {
            "notice": "Burns (destroys) a specific amount of tokens from a given user's address."
          },
          "compliance()": {
            "notice": "Retrieves the address of the main `ISMARTCompliance` contract currently configured for this token."
          },
          "complianceModules()": {
            "notice": "Retrieves a list of all currently active compliance modules for this token, along with their configuration parameters."
          },
          "findValidCollateralClaim()": {
            "notice": "Attempts to find the first valid collateral claim associated with the token contract's         own OnchainID identity, based on a pre-configured claim topic."
          },
          "forcedRecoverTokens(address,address)": {
            "notice": "Forcefully recovers tokens from a lost or compromised wallet to a new wallet belonging to the same         verified identity."
          },
          "forcedTransfer(address,address,uint256)": {
            "notice": "Forcefully transfers tokens from one address to another, bypassing standard transfer restrictions."
          },
          "freezePartialTokens(address,uint256)": {
            "notice": "Freezes a specific amount of tokens for a given address."
          },
          "getFrozenTokens(address)": {
            "notice": "Gets the amount of tokens that are specifically (partially) frozen for an address."
          },
          "hasRole(bytes32,address)": {
            "notice": "Checks if a given account has a specific role."
          },
          "identityRegistry()": {
            "notice": "Retrieves the address of the `ISMARTIdentityRegistry` contract currently configured for this token."
          },
          "initialize(string,string,uint8,address,uint256,(address,bytes)[],address,address,address)": {
            "notice": "Initializes the ATK Deposit token contract."
          },
          "isFrozen(address)": {
            "notice": "Checks if an address is currently fully frozen."
          },
          "mint(address,uint256)": {
            "notice": "Creates (mints) a specified `_amount` of new tokens and assigns them to the `_to` address."
          },
          "onchainID()": {
            "notice": "Retrieves the optional on-chain identifier (e.g., an `IIdentity` contract) associated with the token contract itself."
          },
          "pause()": {
            "notice": "Pauses the contract, which typically prevents certain actions like token transfers."
          },
          "paused()": {
            "notice": "Returns `true` if the contract is currently paused, and `false` otherwise."
          },
          "recoverERC20(address,address,uint256)": {
            "notice": "Allows an authorized account to recover ERC20 tokens that were mistakenly sent to this SMART token contract's address."
          },
          "recoverTokens(address)": {
            "notice": "Recovers SMART tokens from a lost wallet to the caller's address."
          },
          "registeredInterfaces()": {
            "notice": "Retrieves a list of all currently active interfaces for this token."
          },
          "removeComplianceModule(address)": {
            "notice": "Removes an active compliance module from this token's compliance framework."
          },
          "setAddressFrozen(address,bool)": {
            "notice": "Freezes or unfreezes an entire address, preventing or allowing standard token operations."
          },
          "setCompliance(address)": {
            "notice": "Sets or updates the address of the main `ISMARTCompliance` contract used by this token."
          },
          "setIdentityRegistry(address)": {
            "notice": "Sets or updates the address of the `ISMARTIdentityRegistry` contract used by this token."
          },
          "setOnchainID(address)": {
            "notice": "Sets or updates the optional on-chain identifier (e.g., an `IIdentity` contract) associated with the token contract itself."
          },
          "setParametersForComplianceModule(address,bytes)": {
            "notice": "Sets or updates the configuration parameters for a specific, already added compliance module."
          },
          "unfreezePartialTokens(address,uint256)": {
            "notice": "Unfreezes a specific amount of previously partially frozen tokens for an address."
          },
          "unpause()": {
            "notice": "Unpauses the contract, resuming normal operations (e.g., allowing token transfers again)."
          }
        },
        "version": 1
      }
    },
    "settings": {
      "remappings": [
        "@axelar-network/axelar-gmp-sdk-solidity/=dependencies/openzeppelin-community-contracts-0.0.1/node_modules/@axelar-network/axelar-gmp-sdk-solidity/",
        "@onchainid-v2.2.1/=dependencies/@onchainid-v2.2.1/contracts/",
        "@onchainid/contracts/=dependencies/@onchainid-v2.2.1/contracts/",
        "@openzeppelin-contracts-5.2.0/=dependencies/@openzeppelin-contracts-5.2.0/",
        "@openzeppelin-contracts-5.3.0/=dependencies/@openzeppelin-contracts-5.3.0/",
        "@openzeppelin-contracts-upgradeable-5.2.0/=dependencies/@openzeppelin-contracts-upgradeable-5.2.0/",
        "@openzeppelin-contracts-upgradeable-5.3.0/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/",
        "@openzeppelin/community-contracts/=dependencies/openzeppelin-community-contracts-0.0.1/contracts/",
        "@openzeppelin/contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/",
        "@openzeppelin/contracts/=dependencies/@openzeppelin-contracts-5.3.0/",
        "@smartprotocol-v0.0.1/=dependencies/@smartprotocol-v0.0.1/contracts/",
        "eas-contracts-1.4.0/=dependencies/eas-contracts-1.4.0/contracts/",
        "forge-std-1.9.5/=dependencies/forge-std-1.9.5/src/",
        "forge-std-1.9.6/=dependencies/forge-std-1.9.6/src/",
        "forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/",
        "forge-std/=dependencies/forge-std-1.9.7/src/",
        "hardhat/=dependencies/smart-protocol-8.0.8/node_modules/hardhat/",
        "openzeppelin-community-contracts-0.0.1/=dependencies/openzeppelin-community-contracts-0.0.1/contracts/",
        "smart-protocol-8.0.10/=dependencies/smart-protocol-8.0.10/contracts/",
        "smart-protocol-8.0.5/=dependencies/smart-protocol-8.0.5/contracts/",
        "smart-protocol-8.0.7/=dependencies/smart-protocol-8.0.7/contracts/",
        "smart-protocol-8.0.8/=dependencies/smart-protocol-8.0.8/contracts/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "metadata": {
        "bytecodeHash": "none"
      },
      "compilationTarget": {
        "contracts/assets/deposit/IATKDeposit.sol": "IATKDeposit"
      },
      "evmVersion": "cancun",
      "libraries": {},
      "viaIR": true
    },
    "sources": {
      "contracts/assets/deposit/IATKDeposit.sol": {
        "keccak256": "0xb75d03a0a529589437c42f57cf1e12b3b9303ea976117cb3b05edd76dfea1f08",
        "urls": [
          "bzz-raw://7d39b1facf0d305e727eb9d276aa0eea69506e5185b0ad080d29b425aa641209",
          "dweb:/ipfs/QmcAEwoGz5uxRX66zR7DDaf1ovqiqB6K2a1RR2kc717bwy"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/extensions/access-managed/ISMARTTokenAccessManaged.sol": {
        "keccak256": "0xb05c08191398db750d9fd974e8df1bace09434c27fd81a9db7d36ff429affd97",
        "urls": [
          "bzz-raw://5155ee4da616fb8e3365c933952b07b93d603c6a4eb6542433b08c651a0e0c25",
          "dweb:/ipfs/QmW4C4YbYuDLX32oEFrp11t9TK44B5otKCXQemXs1jMgCD"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/extensions/burnable/ISMARTBurnable.sol": {
        "keccak256": "0x4b3408d79782202ec6b6f01f615b13ca00ad9c5974208acfa3d2ae8be3d28f1d",
        "urls": [
          "bzz-raw://df0fe9c4bb881f299c985f917761f16b7a2118d840cf36060f99e54fcc9f7f68",
          "dweb:/ipfs/QmPQrXG8UPPzK2Wt1aYNgPC2F17Yq5Bs2TW4Bt9fDjXo42"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/extensions/collateral/ISMARTCollateral.sol": {
        "keccak256": "0x822bf674043d5c717d66f1b9b21fdafd260db4ab9ec7fe3d59561d90ee72bcdb",
        "urls": [
          "bzz-raw://3ca1244fdd5e5f9737c7d36ce509fa041c41bff32744bb4a46835e49d9d4f0c0",
          "dweb:/ipfs/QmYhtFGkBqL4ZVDErazggigrsd3dYX33D1utbVp3JHB2Ft"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/extensions/custodian/ISMARTCustodian.sol": {
        "keccak256": "0xf7f74718eeb2d259be46ff82c7232c11b125127feb844d8140f3cff47c0c1663",
        "urls": [
          "bzz-raw://97465ae7ef179d5abeedcf57c7fb7cd3f933268da501ae2694a82731f046f119",
          "dweb:/ipfs/QmQivprpP7h75X57xioAnrNtGkGjZaqkSndwY3CUcAXb5V"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/extensions/pausable/ISMARTPausable.sol": {
        "keccak256": "0xab4d6f4bae5e7e8166d3c6206ea8ecd9742c02fb3a82f1420266b4a5872a0497",
        "urls": [
          "bzz-raw://a437838b9641a1c59910296decade4a5c397e12127160983eadafb6ab8514582",
          "dweb:/ipfs/QmNMndn4dMgkjGABjuYHdaHEaL6XwdsJwmsaT2WQugrxR1"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/interface/ERC-3643/IERC3643IdentityRegistryStorage.sol": {
        "keccak256": "0x3a8a72df8da5bf4d988bbfb00151b933ff17cdc8d4be47dc121cd9e2083ba86f",
        "urls": [
          "bzz-raw://369250658bf8d3ebb583946820afa494271ce6bfde607d15c7060cdf7a303cf3",
          "dweb:/ipfs/QmSJjaK6vyv8K9RX1k3rwxsoKfVNyMoHEszxyxdTQfDKQG"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ERC-3643/IERC3643TrustedIssuersRegistry.sol": {
        "keccak256": "0x15b72940814cd959b57bf75623f16c51fc6c50eab51fd2420a8b653519ebd76c",
        "urls": [
          "bzz-raw://479f5e24a1b608776d9d5d7da9c76dd3c9b1dd300d8b4eee7a15dcfba4817bee",
          "dweb:/ipfs/QmPhMBfQAqt5NeRcSu3jDTwhoQXnB7nXNEcmoJ7KoWVt7V"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ISMART.sol": {
        "keccak256": "0xfce323160dd5cd8c9db34de0ea872bec41fd2ea8d8496e1e3c17865d374994da",
        "urls": [
          "bzz-raw://1a1fafbdec0c59e078798438d2a3cd05bd70b864d7dfa67faf135d5634c5ae51",
          "dweb:/ipfs/QmehZwexgZN2BZKA6eFrG3DHUMRUZnzYTen6j5Ry5Znbf2"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/interface/ISMARTCompliance.sol": {
        "keccak256": "0x948341e4ad374e1dded6d1b30c395ad0f01e6ea2099fb6b96c5476e8b28c1d77",
        "urls": [
          "bzz-raw://d261e9a0c8682f11ac86048f13e367caee6d5f512d51b8752186b8c01b6ba618",
          "dweb:/ipfs/Qmdp14emh3NFSAphyuAgsTE7qZt1g1UYcNLS3tNNM8T6Hv"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/interface/ISMARTIdentityRegistry.sol": {
        "keccak256": "0x62a95a9db2ac97ceaf59f7585d7bbaf3acb65ed9b5e57597b9d1fe1b4d7c4eda",
        "urls": [
          "bzz-raw://bd870710359396db48e70ef7e40449125ff744c6c8ce15ad7e1894df430c87ea",
          "dweb:/ipfs/QmZ6khf5Vm6hBkkUgYC1b161jSQaZeegJVRY6ndjRW1EcG"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/interface/ISMARTIdentityRegistryStorage.sol": {
        "keccak256": "0x219b3d03958859e2f082aac5cbf3b40acf243e326ee6e74e6bb03be7724c2985",
        "urls": [
          "bzz-raw://8cf8d30ec47cb2aed5b51d373837584fb6f08deab1d35142510271e733404f52",
          "dweb:/ipfs/Qmc9NnABx9ouhhCR8qgJC3RtU5oAyycSjZkY6nGtuWFwuz"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/interface/ISMARTTopicSchemeRegistry.sol": {
        "keccak256": "0xec5e42dcf7d929f8a0db42c9c8a0fa81d089a9f7177b7da10df029f94334ca8a",
        "urls": [
          "bzz-raw://e346e3241e3110b3f17d2b244a49d68a1d79c6928bef7d372ea3458c1029cea0",
          "dweb:/ipfs/QmeSyCYN9qYXRjn799fRFP7X9apf7bubVhnFEUGQatx3xd"
        ],
        "license": "FSL-1.1-MIT"
      },
      "contracts/smart/interface/structs/SMARTComplianceModuleParamPair.sol": {
        "keccak256": "0x489a55538b554a0c935bee7efc28f7e821e161638c5726c9d367a644a0b7c62a",
        "urls": [
          "bzz-raw://04bb06aed3ee3c5c6f3df9a59721c08ddd57b5521da1c9c6fd96b7c8b57db813",
          "dweb:/ipfs/QmRuzqKDr2sBHNuQhCzWGa8euNiMyvP7LTjSFjvAj5uFqh"
        ],
        "license": "FSL-1.1-MIT"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IClaimIssuer.sol": {
        "keccak256": "0xae785f63b3cb3a94bcb454ef4ad6376aa4848fa29cff1cc8db3bef4a2994a779",
        "urls": [
          "bzz-raw://d8223d2710c51ee39cdfd2cb2f1858b3d64a3222c78ea8ed5eb3e11a93e1222e",
          "dweb:/ipfs/QmYRXPCww7BorScTC6QNMbrRm2zprUmSYFpWomwarJH7Df"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IERC734.sol": {
        "keccak256": "0x35a14a0d1a3ed51689f1a2cb12e26d30601afbcc1cc9b9b288a03cd11e6d049e",
        "urls": [
          "bzz-raw://156aac402e73e6bd2fa8c0ccd85b2add8d1bb505d8a652218173dbc8e7b9a3cb",
          "dweb:/ipfs/QmPzPyc3kKxoNCGqKAooUju6YvMkDN4MCUH198TEXnA82o"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IERC735.sol": {
        "keccak256": "0xeac82c37b16c1c1c83df3e88be987332b1230ed13e1d017f9d2929f978ac0122",
        "urls": [
          "bzz-raw://695a66b789ac417b7b2b78c578981779db374704382921ff499351cccab0323e",
          "dweb:/ipfs/QmeZoogvsEWf688Z849zZ2dLPDnor6YnnNQLMgedY9Tc9D"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IIdentity.sol": {
        "keccak256": "0x5ed42ab81b9b734c79e61d1f7e0734baab5479a356ab6bb469414d3c66269862",
        "urls": [
          "bzz-raw://a0863999b1ed334179a43e699e6057815eea011a78ed51e61b6110fc392e26f8",
          "dweb:/ipfs/Qme6hdHZCAy1V4sLgAZ5NxdrEjEf5mYMabf5UDmUDjkuzW"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/IERC20.sol": {
        "keccak256": "0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7",
        "urls": [
          "bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db",
          "dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "keccak256": "0x70f2f713b13b7ce4610bcd0ac9fec0f3cc43693b043abcb8dc40a42a726eb330",
        "urls": [
          "bzz-raw://c13d13304ac79a83ab1c30168967d19e2203342ebbd6a9bbce4db7550522dcbf",
          "dweb:/ipfs/QmeN5jKMN2vw5bhacr6tkg78afbTTZUeaacNHqjWt4Ew1r"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/utils/introspection/IERC165.sol": {
        "keccak256": "0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8",
        "urls": [
          "bzz-raw://f6fda447a62815e8064f47eff0dd1cf58d9207ad69b5d32280f8d7ed1d1e4621",
          "dweb:/ipfs/QmfDRc7pxfaXB2Dh9np5Uf29Na3pQ7tafRS684wd3GLjVL"
        ],
        "license": "MIT"
      }
    },
    "version": 1
  },
  "userdoc": {
    "version": 1,
    "kind": "user",
    "methods": {
      "accessManager()": {
        "notice": "Returns the address of the access manager for the token."
      },
      "addComplianceModule(address,bytes)": {
        "notice": "Adds a new compliance module contract to this token's compliance framework and sets its initial configuration parameters."
      },
      "batchBurn(address[],uint256[])": {
        "notice": "Burns (destroys) tokens from multiple user addresses in a single transaction."
      },
      "batchForcedTransfer(address[],address[],uint256[])": {
        "notice": "Forcefully transfers tokens for multiple address pairs in a batch."
      },
      "batchFreezePartialTokens(address[],uint256[])": {
        "notice": "Freezes specific amounts of tokens for multiple addresses in a batch."
      },
      "batchMint(address[],uint256[])": {
        "notice": "Mints tokens to multiple recipient addresses in a single batch transaction."
      },
      "batchSetAddressFrozen(address[],bool[])": {
        "notice": "Freezes or unfreezes multiple addresses in a batch operation."
      },
      "batchTransfer(address[],uint256[])": {
        "notice": "Transfers tokens from the caller to multiple recipient addresses in a single batch transaction."
      },
      "batchUnfreezePartialTokens(address[],uint256[])": {
        "notice": "Unfreezes specific amounts of tokens for multiple addresses in a batch."
      },
      "burn(address,uint256)": {
        "notice": "Burns (destroys) a specific amount of tokens from a given user's address."
      },
      "compliance()": {
        "notice": "Retrieves the address of the main `ISMARTCompliance` contract currently configured for this token."
      },
      "complianceModules()": {
        "notice": "Retrieves a list of all currently active compliance modules for this token, along with their configuration parameters."
      },
      "findValidCollateralClaim()": {
        "notice": "Attempts to find the first valid collateral claim associated with the token contract's         own OnchainID identity, based on a pre-configured claim topic."
      },
      "forcedRecoverTokens(address,address)": {
        "notice": "Forcefully recovers tokens from a lost or compromised wallet to a new wallet belonging to the same         verified identity."
      },
      "forcedTransfer(address,address,uint256)": {
        "notice": "Forcefully transfers tokens from one address to another, bypassing standard transfer restrictions."
      },
      "freezePartialTokens(address,uint256)": {
        "notice": "Freezes a specific amount of tokens for a given address."
      },
      "getFrozenTokens(address)": {
        "notice": "Gets the amount of tokens that are specifically (partially) frozen for an address."
      },
      "hasRole(bytes32,address)": {
        "notice": "Checks if a given account has a specific role."
      },
      "identityRegistry()": {
        "notice": "Retrieves the address of the `ISMARTIdentityRegistry` contract currently configured for this token."
      },
      "initialize(string,string,uint8,address,uint256,(address,bytes)[],address,address,address)": {
        "notice": "Initializes the ATK Deposit token contract."
      },
      "isFrozen(address)": {
        "notice": "Checks if an address is currently fully frozen."
      },
      "mint(address,uint256)": {
        "notice": "Creates (mints) a specified `_amount` of new tokens and assigns them to the `_to` address."
      },
      "onchainID()": {
        "notice": "Retrieves the optional on-chain identifier (e.g., an `IIdentity` contract) associated with the token contract itself."
      },
      "pause()": {
        "notice": "Pauses the contract, which typically prevents certain actions like token transfers."
      },
      "paused()": {
        "notice": "Returns `true` if the contract is currently paused, and `false` otherwise."
      },
      "recoverERC20(address,address,uint256)": {
        "notice": "Allows an authorized account to recover ERC20 tokens that were mistakenly sent to this SMART token contract's address."
      },
      "recoverTokens(address)": {
        "notice": "Recovers SMART tokens from a lost wallet to the caller's address."
      },
      "registeredInterfaces()": {
        "notice": "Retrieves a list of all currently active interfaces for this token."
      },
      "removeComplianceModule(address)": {
        "notice": "Removes an active compliance module from this token's compliance framework."
      },
      "setAddressFrozen(address,bool)": {
        "notice": "Freezes or unfreezes an entire address, preventing or allowing standard token operations."
      },
      "setCompliance(address)": {
        "notice": "Sets or updates the address of the main `ISMARTCompliance` contract used by this token."
      },
      "setIdentityRegistry(address)": {
        "notice": "Sets or updates the address of the `ISMARTIdentityRegistry` contract used by this token."
      },
      "setOnchainID(address)": {
        "notice": "Sets or updates the optional on-chain identifier (e.g., an `IIdentity` contract) associated with the token contract itself."
      },
      "setParametersForComplianceModule(address,bytes)": {
        "notice": "Sets or updates the configuration parameters for a specific, already added compliance module."
      },
      "unfreezePartialTokens(address,uint256)": {
        "notice": "Unfreezes a specific amount of previously partially frozen tokens for an address."
      },
      "unpause()": {
        "notice": "Unpauses the contract, resuming normal operations (e.g., allowing token transfers again)."
      }
    },
    "events": {
      "AccessManagerSet(address,address)": {
        "notice": "Emitted when the address of the access manager contract is successfully changed or set."
      },
      "AddressFrozen(address,address,bool)": {
        "notice": "Emitted when an address's full frozen status (i.e., the entire address is frozen or unfrozen)         is changed by an authorized custodian."
      },
      "BurnCompleted(address,address,uint256)": {
        "notice": "Emitted when a token burn operation has been successfully completed."
      },
      "ComplianceAdded(address,address)": {
        "notice": "Emitted when the address of the main `ISMARTCompliance` contract, used by this token, is successfully updated."
      },
      "ComplianceModuleAdded(address,address,bytes)": {
        "notice": "Emitted when a new compliance module is successfully added to the token's compliance framework."
      },
      "ComplianceModuleRemoved(address,address)": {
        "notice": "Emitted when an existing compliance module is successfully removed from the token's compliance framework."
      },
      "ERC20TokenRecovered(address,address,address,uint256)": {
        "notice": "Emitted when mistakenly sent ERC20 tokens are recovered from the contract."
      },
      "ForcedTransfer(address,address,address,uint256)": {
        "notice": "Emitted when a forced transfer of tokens is executed by a custodian."
      },
      "IdentityRegistryAdded(address,address)": {
        "notice": "Emitted when the address of the `ISMARTIdentityRegistry` contract, used by this token, is successfully updated."
      },
      "MintCompleted(address,address,uint256)": {
        "notice": "Emitted after a token minting operation has successfully completed, passing all relevant checks."
      },
      "ModuleParametersUpdated(address,address,bytes)": {
        "notice": "Emitted when the configuration parameters for an existing, active compliance module are successfully updated."
      },
      "Paused(address)": {
        "notice": "Emitted when the contract transitions to a paused state."
      },
      "RecoverySuccess(address,address,address,address)": {
        "notice": "Emitted when assets are successfully recovered from a lost or compromised wallet to a new wallet         belonging to the same verified identity."
      },
      "TokensFrozen(address,address,uint256)": {
        "notice": "Emitted when a specific amount of tokens is partially frozen for an address."
      },
      "TokensRecovered(address,address,address,uint256)": {
        "notice": "Emitted when tokens are recovered from a lost wallet to the caller's address."
      },
      "TokensUnfrozen(address,address,uint256)": {
        "notice": "Emitted when a specific amount of previously partially frozen tokens is unfrozen for an address."
      },
      "TransferCompleted(address,address,address,uint256)": {
        "notice": "Emitted after a token transfer operation (e.g., via `transfer` or `transferFrom`) has successfully completed,         passing all identity and compliance checks."
      },
      "Unpaused(address)": {
        "notice": "Emitted when the contract transitions out of a paused state (i.e., is unpaused)."
      },
      "UpdatedTokenInformation(address,uint8,address)": {
        "notice": "Emitted when fundamental information about the token, such as its decimals or on-chain ID, is updated."
      }
    },
    "errors": {
      "AccessControlUnauthorizedAccount(address,bytes32)": [
        {
          "notice": "This error is functionally identical to `AccessControlUnauthorizedAccount`         defined in OpenZeppelin's `access/AccessControl.sol` contract.         Re-defining it here ensures consistency within the SMART framework and can         help in scenarios where specific error catching is needed for this module."
        }
      ],
      "CannotRecoverSelf()": [
        {
          "notice": "Error indicating an attempt to recover the token contract's own tokens."
        }
      ],
      "DuplicateModule(address)": [
        {
          "notice": "Error indicating that a compliance module is being added but already exists."
        }
      ],
      "ExpectedPause()": [
        {
          "notice": "Error reverted when an action is attempted that requires the contract to be in a paused state,         but the contract is currently not paused (i.e., it is unpaused)."
        }
      ],
      "FreezeAmountExceedsAvailableBalance(uint256,uint256)": [
        {
          "notice": "Error indicating that the amount requested to be frozen exceeds the user's available (unfrozen) balance."
        }
      ],
      "InsufficientCollateral(uint256,uint256)": [
        {
          "notice": "Error: Insufficient collateral to cover the proposed total supply after minting."
        }
      ],
      "InsufficientFrozenTokens(uint256,uint256)": [
        {
          "notice": "Error indicating that an attempt to unfreeze or use frozen tokens failed because the         amount requested exceeds the currently frozen token balance for the address."
        }
      ],
      "InsufficientTokenBalance()": [
        {
          "notice": "Error indicating that the token balance is insufficient for an operation."
        }
      ],
      "InvalidCollateralTopic(uint256)": [
        {
          "notice": "Error: An invalid collateral proof topic ID was provided during initialization."
        }
      ],
      "InvalidDecimals(uint8)": [
        {
          "notice": "Error indicating that the provided decimals value is invalid."
        }
      ],
      "InvalidLostWallet()": [
        {
          "notice": "Error indicating that the provided lost wallet is not marked as lost."
        }
      ],
      "LengthMismatch()": [
        {
          "notice": "Error: Array Length Mismatch in Batch Operation."
        }
      ],
      "MintNotCompliant()": [
        {
          "notice": "Error indicating that a mint operation failed compliance checks."
        }
      ],
      "ModuleAlreadyAdded()": [
        {
          "notice": "Error indicating that an attempt was made to add a compliance module that is already registered."
        }
      ],
      "ModuleNotFound()": [
        {
          "notice": "Error indicating that a specified compliance module was not found."
        }
      ],
      "NoTokensToRecover()": [
        {
          "notice": "Error indicating that there are no tokens to recover."
        }
      ],
      "RecipientAddressFrozen()": [
        {
          "notice": "Error indicating that an operation (e.g., mint, transfer) cannot proceed because the recipient address is frozen."
        }
      ],
      "SenderAddressFrozen()": [
        {
          "notice": "Error indicating that an operation (e.g., transfer, burn, redeem) cannot proceed because the sender address is frozen."
        }
      ],
      "TokenPaused()": [
        {
          "notice": "Error reverted when an action is attempted that requires the contract to be unpaused (not paused),         but the contract is currently paused."
        }
      ],
      "TransferNotCompliant()": [
        {
          "notice": "Error indicating that a transfer operation failed compliance checks."
        }
      ],
      "ZeroAddressNotAllowed()": [
        {
          "notice": "Error: Zero Address Not Allowed."
        }
      ]
    },
    "notice": "Defines the core functionality and extensions for a ATK Deposit token."
  },
  "devdoc": {
    "version": 1,
    "kind": "dev",
    "methods": {
      "accessManager()": {
        "returns": {
          "_0": "The address of the access manager."
        }
      },
      "addComplianceModule(address,bytes)": {
        "details": "Before adding, the implementation (or the main `ISMARTCompliance` contract) MUST validate:      1. That `_module` is a valid contract address.      2. That `_module` correctly implements the `ISMARTComplianceModule` interface (e.g., via ERC165 `supportsInterface`).      3. That the provided `_params` are valid for the `_module` (by calling `_module.validateParameters(_params)`).      Typically restricted to an administrative role. Emits `ComplianceModuleAdded`.",
        "params": {
          "_module": "The address of the compliance module contract to add.",
          "_params": "The initial ABI-encoded configuration parameters for this module specific to this token."
        }
      },
      "allowance(address,address)": {
        "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
      },
      "approve(address,uint256)": {
        "details": "Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
      },
      "balanceOf(address)": {
        "details": "Returns the value of tokens owned by `account`."
      },
      "batchBurn(address[],uint256[])": {
        "details": "This function allows for efficient batch processing of token burns, which can save on      transaction fees (gas) compared to calling `burn` multiple times individually.      It requires that the `userAddresses` array and the `amounts` array have the same number of elements,      with each `amounts[i]` corresponding to `userAddresses[i]`.      Similar to the single `burn` function, authorization for each individual burn within the batch      is expected to be handled by the implementing contract (e.g., via an `_authorizeBurn` hook).      If the lengths of the input arrays do not match, the transaction should revert to prevent errors.",
        "params": {
          "amounts": "An array of token quantities to be burned. `amounts[i]` tokens will be burned                from `userAddresses[i]`.",
          "userAddresses": "An array of blockchain addresses from which tokens will be burned."
        }
      },
      "batchForcedTransfer(address[],address[],uint256[])": {
        "details": "A gas-efficient version of `forcedTransfer` for multiple operations.      Requires strong authorization for the entire batch.      Arrays `fromList`, `toList`, and `amounts` must be of the same length.",
        "params": {
          "amounts": "A list of corresponding token amounts to transfer.",
          "fromList": "A list of sender addresses.",
          "toList": "A list of recipient addresses."
        }
      },
      "batchFreezePartialTokens(address[],uint256[])": {
        "details": "Allows freezing different amounts for different users simultaneously.      Requires authorization for each partial freeze operation.      Arrays must be of the same length.",
        "params": {
          "amounts": "A list of corresponding token amounts to freeze.",
          "userAddresses": "A list of target addresses."
        }
      },
      "batchMint(address[],uint256[])": {
        "details": "This is an efficiency function to reduce transaction costs when minting to many users.      Typically restricted to accounts with a specific minter role.      Implementations MUST perform identity verification and compliance checks for *each* recipient in `_toList`.      If any recipient fails checks, the entire batch operation should revert to maintain atomicity.      Emits multiple `MintCompleted` and ERC20 `Transfer` events.",
        "params": {
          "_amounts": "An array of corresponding token quantities to mint for each address in `_toList`. The lengths of `_toList` and `_amounts` MUST be equal.",
          "_toList": "An array of addresses to receive the newly minted tokens."
        }
      },
      "batchSetAddressFrozen(address[],bool[])": {
        "details": "A gas-efficient way to update the frozen status for several addresses at once.      Requires authorization for each underlying freeze/unfreeze operation.      The `userAddresses` and `freeze` arrays must be of the same length.",
        "params": {
          "freeze": "A list of corresponding boolean freeze statuses (`true` for freeze, `false` for unfreeze).",
          "userAddresses": "A list of target addresses."
        }
      },
      "batchTransfer(address[],uint256[])": {
        "details": "This is an efficiency function, useful for distributions or airdrops (if compliant).      The caller (`msg.sender`) must have a sufficient balance to cover the sum of all `_amounts`.      Implementations MUST perform identity verification and compliance checks for *each* recipient in `_toList`      and also check the sender (`msg.sender`) if sender-side compliance rules apply.      If any part of the batch fails checks, the entire operation should revert.      Emits multiple `TransferCompleted` and ERC20 `Transfer` events.",
        "params": {
          "_amounts": "An array of corresponding token quantities to transfer. The lengths of `_toList` and `_amounts` MUST be equal.",
          "_toList": "An array of addresses to receive the tokens."
        }
      },
      "batchUnfreezePartialTokens(address[],uint256[])": {
        "details": "Allows unfreezing different amounts for different users simultaneously.      Requires authorization for each partial unfreeze operation.      Arrays must be of the same length.",
        "params": {
          "amounts": "A list of corresponding token amounts to unfreeze.",
          "userAddresses": "A list of target addresses."
        }
      },
      "burn(address,uint256)": {
        "details": "This function is intended for an authorized operator (like an admin or a special role)      to burn tokens on behalf of a user, or from a specific account as part of token management.      The actual authorization logic (who can call this) is typically handled by the contract      implementing this interface, often through a mechanism like an `_authorizeBurn` hook.      The function signature and intent are similar to `operatorBurn` as suggested by standards      like ERC3643, where an operator can manage token holdings.",
        "params": {
          "amount": "The quantity of tokens to burn. This should be a non-negative integer.",
          "userAddress": "The blockchain address of the account from which tokens will be burned.                    This is the account whose token balance will decrease."
        }
      },
      "compliance()": {
        "details": "The Compliance contract is responsible for orchestrating compliance checks for token operations.",
        "returns": {
          "complianceContract": "The `ISMARTCompliance` contract instance currently in use."
        }
      },
      "complianceModules()": {
        "details": "Each element in the returned array is a `SMARTComplianceModuleParamPair` struct, containing the module's address      and its current ABI-encoded parameters specific to this token.",
        "returns": {
          "modulesList": "An array of `SMARTComplianceModuleParamPair` structs."
        }
      },
      "decimals()": {
        "details": "Returns the decimals places of the token."
      },
      "findValidCollateralClaim()": {
        "details": "This function is expected to perform several checks:      1. Retrieve claim IDs from the token's identity contract (`this.onchainID()`) for the configured `collateralProofTopic`.      2. For each claim, verify its issuer is trusted for that topic via the `identityRegistry`'s `issuersRegistry`.      3. Confirm the trusted issuer contract itself deems the claim valid (e.g., via `IClaimIssuer.isClaimValid`).      4. Decode the claim data, which is expected to contain a collateral `amount` and an `expiryTimestamp`.      5. Ensure the claim has not expired (i.e., `decodedExpiry > block.timestamp`).      The function should return the details of the *first* claim that successfully passes all these validations.      If no such claim is found, it should return zero values.      This is a `view` function, meaning it reads blockchain state but does not modify it, and thus      does not consume gas when called as a read-only operation from off-chain.",
        "returns": {
          "amount": "The collateral amount (e.g., maximum permissible total supply) decoded from the valid claim data.                Returns 0 if no valid collateral claim is found.",
          "expiryTimestamp": "The expiry timestamp (Unix time) decoded from the valid claim data.                         Returns 0 if no valid claim is found or if the found claim has already expired.",
          "issuer": "The address of the trusted `IClaimIssuer` contract that issued the valid collateral claim.                Returns `address(0)` if no valid claim is found."
        }
      },
      "forcedRecoverTokens(address,address)": {
        "details": "This is a powerful administrative function. It can recover tokens even if addresses are frozen or      if other transfer conditions (like compliance checks) would normally fail.      Requires strong authorization (e.g., a FORCED_TRANSFER_ROLE).",
        "params": {
          "lostWallet": "The address from which tokens will be recovered.",
          "newWallet": "The address to which tokens will be recovered."
        }
      },
      "forcedTransfer(address,address,uint256)": {
        "details": "This is a powerful administrative function. It can move tokens even if addresses are frozen or      if other transfer conditions (like compliance checks) would normally fail.      If the `from` address has partially frozen tokens, this function may automatically unfreeze      the necessary amount to cover the transfer.      The implementation typically uses an internal flag (like `__isForcedUpdate`) to bypass standard hooks      (e.g., `_beforeTransfer`) during the actual token movement.      Requires strong authorization (e.g., a FORCED_TRANSFER_ROLE).",
        "params": {
          "amount": "The quantity of tokens to transfer.",
          "from": "The address from which tokens will be transferred.",
          "to": "The address to which tokens will be transferred."
        },
        "returns": {
          "_0": "bool Returns `true` upon successful execution (should revert on failure)."
        }
      },
      "freezePartialTokens(address,uint256)": {
        "details": "This prevents the specified `amount` of tokens from being used in standard operations by `userAddress`.      The user can still transact with their unfrozen balance.      Reverts if the `amount` to freeze exceeds the user's available (currently unfrozen) balance.      Requires authorization.",
        "params": {
          "amount": "The quantity of tokens to freeze.",
          "userAddress": "The address for which to freeze tokens."
        }
      },
      "getFrozenTokens(address)": {
        "details": "This does not include tokens that are implicitly frozen because the entire address is frozen.",
        "params": {
          "userAddress": "The address to check."
        },
        "returns": {
          "_0": "uint256 The amount of tokens partially frozen for the address."
        }
      },
      "hasRole(bytes32,address)": {
        "details": "This function is crucial for permissioned systems, where certain actions      can only be performed by accounts holding specific roles (e.g., an admin role,      a minter role, etc.).",
        "params": {
          "account": "The address of the account whose roles are being checked.",
          "role": "The identifier of the role to check. Roles are typically represented             as a `bytes32` value, which is a fixed-size byte array often derived             from a descriptive string (e.g., keccak256(\"MINTER_ROLE\"))."
        },
        "returns": {
          "_0": "A boolean value: `true` if the account has the specified role,         `false` otherwise."
        }
      },
      "identityRegistry()": {
        "details": "The Identity Registry is used for verifying token holders against required claims and linking wallets to identities.",
        "returns": {
          "registryContract": "The `ISMARTIdentityRegistry` contract instance currently in use."
        }
      },
      "initialize(string,string,uint8,address,uint256,(address,bytes)[],address,address,address)": {
        "params": {
          "accessManager_": "The address of the access manager contract for this token.",
          "collateralTopicId_": "The topic ID of the collateral claim.",
          "compliance_": "The address of the compliance contract.",
          "decimals_": "The number of decimals for the deposit token.",
          "identityRegistry_": "The address of the identity registry contract.",
          "initialModulePairs_": "An array of initial compliance module and parameter pairs.",
          "name_": "The name of the deposit token.",
          "onchainID_": "Optional address of an existing onchain identity contract. Pass address(0) to create a new one.",
          "symbol_": "The symbol of the deposit token."
        }
      },
      "isFrozen(address)": {
        "details": "A `view` function does not modify blockchain state and does not cost gas when called externally.",
        "params": {
          "userAddress": "The address to check."
        },
        "returns": {
          "_0": "bool `true` if the address is frozen, `false` otherwise."
        }
      },
      "mint(address,uint256)": {
        "details": "This function is typically restricted to accounts with a specific minter role.      Implementations MUST perform identity verification and compliance checks on the `_to` address before minting.      Failure to meet these checks should result in a revert (e.g., with `RecipientNotVerified` or a compliance error).      Emits `MintCompleted` and the standard ERC20 `Transfer` event (from `address(0)` to `_to`).",
        "params": {
          "_amount": "The quantity of tokens to mint.",
          "_to": "The address that will receive the newly minted tokens."
        }
      },
      "name()": {
        "details": "Returns the name of the token."
      },
      "onchainID()": {
        "details": "This can represent the token issuer or the token entity.",
        "returns": {
          "idAddress": "The address of the on-chain ID contract, or `address(0)` if no on-chain ID is set for the token."
        }
      },
      "pause()": {
        "details": "Implementations should ensure this function can only be called by an authorized address      (e.g., through a modifier like `onlyPauser`). It should revert if the contract is already paused      to prevent redundant operations or event emissions."
      },
      "paused()": {
        "details": "This is a `view` function, meaning it does not modify the blockchain state and does not      cost gas when called externally (e.g., from an off-chain script or another contract's view function).",
        "returns": {
          "_0": "bool The current paused state of the contract."
        }
      },
      "recoverERC20(address,address,uint256)": {
        "details": "This function is crucial for retrieving assets that are not the SMART token itself but are held by the contract.      Access to this function MUST be strictly controlled (e.g., via an `_authorizeRecoverERC20` internal hook or role).      It is critical that this function CANNOT be used to recover the SMART token itself, as that could drain the contract or interfere with its logic.      It should use a safe transfer mechanism (like OpenZeppelin's `SafeERC20.safeTransfer`) to prevent issues with non-standard ERC20 tokens.",
        "params": {
          "amount": "The quantity of the `token` to recover and send to `to`.",
          "to": "The address where the recovered tokens will be sent.",
          "token": "The contract address of the ERC20 token to be recovered. This MUST NOT be `address(this)`."
        }
      },
      "recoverTokens(address)": {
        "details": "This will make it possible to recover SMART tokens from the lostWallet to msgSender, if it was correctly marked as lost in the identity registry.",
        "params": {
          "_lostWallet": "The address of the lost wallet containing tokens to recover."
        }
      },
      "registeredInterfaces()": {
        "details": "This function returns an array of bytes4 interface IDs that the token supports.",
        "returns": {
          "interfacesList": "An array of bytes4 interface IDs."
        }
      },
      "removeComplianceModule(address)": {
        "details": "Once removed, the rules enforced by this `_module` will no longer apply to token operations.      Typically restricted to an administrative role. Emits `ComplianceModuleRemoved`.",
        "params": {
          "_module": "The address of the compliance module contract to remove."
        }
      },
      "setAddressFrozen(address,bool)": {
        "details": "When an address is frozen, typically all standard transfers, mints (to it), and burns (from it)      are blocked. Unfreezing reverses this.      Implementations should ensure this function requires proper authorization (e.g., a FREEZER_ROLE).",
        "params": {
          "freeze": "`true` to freeze the address, `false` to unfreeze it.",
          "userAddress": "The target address whose frozen status is to be changed."
        }
      },
      "setCompliance(address)": {
        "details": "The Compliance contract orchestrates checks across various compliance modules to determine transfer legality.      Typically restricted to an administrative role. Emits `ComplianceAdded`.",
        "params": {
          "_compliance": "The address of the new `ISMARTCompliance` contract. Must not be `address(0)`."
        }
      },
      "setIdentityRegistry(address)": {
        "details": "The Identity Registry is responsible for managing associations between investor wallet addresses and their on-chain Identity contracts,      and for verifying identities against required claims.      Typically restricted to an administrative role. Emits `IdentityRegistryAdded`.",
        "params": {
          "_identityRegistry": "The address of the new `ISMARTIdentityRegistry` contract. Must not be `address(0)`."
        }
      },
      "setOnchainID(address)": {
        "details": "This can be used to represent the token issuer or the token itself as an on-chain entity.      Typically, this function is restricted to an administrative role.",
        "params": {
          "_onchainID": "The address of the on-chain ID contract. Pass `address(0)` to remove an existing ID."
        }
      },
      "setParametersForComplianceModule(address,bytes)": {
        "details": "This allows an administrator to change how a particular compliance rule behaves for this token.      The implementing contract (or the `ISMARTCompliance` contract) MUST validate these `_params` by calling      the module's `validateParameters(_params)` function before applying them.      Typically restricted to an administrative role. Emits `ModuleParametersUpdated`.",
        "params": {
          "_module": "The address of the compliance module (must be an active module for this token).",
          "_params": "The new ABI-encoded configuration parameters for the module."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
      },
      "symbol()": {
        "details": "Returns the symbol of the token."
      },
      "totalSupply()": {
        "details": "Returns the value of tokens in existence."
      },
      "transfer(address,uint256)": {
        "details": "Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
      },
      "transferFrom(address,address,uint256)": {
        "details": "Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
      },
      "unfreezePartialTokens(address,uint256)": {
        "details": "Reduces the partially frozen amount for `userAddress` by the specified `amount`.      Reverts if `amount` exceeds the currently frozen token amount for that address.      Requires authorization.",
        "params": {
          "amount": "The quantity of tokens to unfreeze.",
          "userAddress": "The address for which to unfreeze tokens."
        }
      },
      "unpause()": {
        "details": "Similar to `pause()`, this function should be restricted to authorized addresses and should      revert if the contract is not currently paused."
      }
    },
    "events": {
      "AccessManagerSet(address,address)": {
        "details": "This event is crucial for transparency and monitoring. It allows external observers      to know when the authority managing roles and permissions for a token has been updated.      The `indexed` keyword for `sender` and `manager` allows these addresses to be efficiently      searched for in event logs.",
        "params": {
          "manager": "The new address of the `SMARTTokenAccessManager` contract that will now                oversee access control for the token.",
          "sender": "The address of the account that initiated the change of the access manager.               This is typically an administrator or an account with special privileges."
        }
      },
      "AddressFrozen(address,address,bool)": {
        "params": {
          "isFrozen": "The new frozen status: `true` if the address is now frozen, `false` if unfrozen.                 `indexed` to quickly find all freeze or unfreeze events.",
          "sender": "The address (e.g., custodian, admin) that initiated the freeze/unfreeze operation.               `indexed` for easier filtering of operations by a specific admin.",
          "userAddress": "The address whose frozen status was changed. `indexed` for tracking a specific user."
        }
      },
      "Approval(address,address,uint256)": {
        "details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
      },
      "BurnCompleted(address,address,uint256)": {
        "details": "This event signifies that a specified `amount` of tokens has been destroyed from the `from` address,      triggered by the `sender`.      The `indexed` keyword for `sender` and `from` parameters is a special feature in Solidity events.      It allows these parameters to be efficiently searched and filtered by off-chain applications.      Think of them as creating a searchable index for these specific fields in the event logs.",
        "params": {
          "amount": "The quantity of tokens that were burned (destroyed).",
          "from": "The address from which the tokens were actually burned. This is the account whose token balance was reduced.",
          "sender": "The address of the account that initiated or authorized the burn operation.               This could be an administrator, an operator, or under certain rules, the token holder themselves."
        }
      },
      "ComplianceAdded(address,address)": {
        "details": "This event indicates a change in the primary contract responsible for enforcing compliance rules on token transfers.",
        "params": {
          "_compliance": "The address of the newly configured `ISMARTCompliance` contract.",
          "sender": "The address of the account (e.g., admin) that initiated this configuration change."
        }
      },
      "ComplianceModuleAdded(address,address,bytes)": {
        "details": "Compliance modules implement specific rules (e.g., geographic restrictions, holding limits).",
        "params": {
          "_module": "The address of the newly added compliance module contract (which should implement `ISMARTComplianceModule`).",
          "_params": "The ABI-encoded configuration parameters initially set for this module instance on this token.",
          "sender": "The address of the account (e.g., admin) that added the module."
        }
      },
      "ComplianceModuleRemoved(address,address)": {
        "details": "Removing a module means its rules will no longer be applied to token operations.",
        "params": {
          "_module": "The address of the compliance module contract that was removed.",
          "sender": "The address of the account (e.g., admin) that removed the module."
        }
      },
      "ERC20TokenRecovered(address,address,address,uint256)": {
        "params": {
          "amount": "The amount of tokens recovered.",
          "sender": "The address that initiated the recovery operation.",
          "to": "The address to which the tokens were recovered.",
          "token": "The address of the ERC20 token recovered."
        }
      },
      "ForcedTransfer(address,address,address,uint256)": {
        "params": {
          "amount": "The amount of tokens transferred.",
          "from": "The source address of the tokens. `indexed`.",
          "sender": "The address of the custodian who initiated the forced transfer. `indexed`.",
          "to": "The destination address of the tokens. `indexed`."
        }
      },
      "IdentityRegistryAdded(address,address)": {
        "details": "This event signals a change in the system component responsible for managing and verifying user identities.",
        "params": {
          "_identityRegistry": "The address of the newly configured `ISMARTIdentityRegistry` contract.",
          "sender": "The address of the account (e.g., admin) that initiated this configuration change."
        }
      },
      "MintCompleted(address,address,uint256)": {
        "params": {
          "amount": "The quantity of tokens minted.",
          "sender": "The address of the account (e.g., minter role) that initiated the minting.",
          "to": "The address that received the newly minted tokens."
        }
      },
      "ModuleParametersUpdated(address,address,bytes)": {
        "details": "This allows tweaking the behavior of a module without removing and re-adding it.",
        "params": {
          "_module": "The address of the compliance module whose parameters were updated.",
          "_params": "The new ABI-encoded configuration parameters for the module.",
          "sender": "The address of the account (e.g., admin) that updated the parameters."
        }
      },
      "Paused(address)": {
        "details": "This event signals that standard operations (like transfers) are likely now blocked.",
        "params": {
          "sender": "The address that initiated the `pause` operation. This is typically an authorized               account with a PAUSER_ROLE. `indexed` for easier filtering of events initiated               by a specific admin or pauser address."
        }
      },
      "RecoverySuccess(address,address,address,address)": {
        "params": {
          "investorOnchainID": "The on-chain ID contract address that links the `lostWallet` and `newWallet`,                          confirming they belong to the same beneficial owner.                          Not typically indexed as it might be a shared contract for many users.",
          "lostWallet": "The address from which assets were recovered. `indexed`.",
          "newWallet": "The address to which assets were transferred and identity re-associated. `indexed`.",
          "sender": "The address (e.g., custodian) that initiated the recovery operation. `indexed`."
        }
      },
      "TokensFrozen(address,address,uint256)": {
        "details": "This refers to freezing a portion of an address's tokens, distinct from freezing the entire address.",
        "params": {
          "amount": "The quantity of tokens that were specifically frozen.",
          "sender": "The address that initiated the partial freeze operation. `indexed`.",
          "user": "The address for which a specific amount of tokens was frozen. `indexed`."
        }
      },
      "TokensRecovered(address,address,address,uint256)": {
        "params": {
          "amount": "The amount of tokens recovered.",
          "lostWallet": "The address of the lost wallet containing tokens to recover.",
          "newWallet": "The address to which the tokens were recovered.",
          "sender": "The address that initiated the recovery operation."
        }
      },
      "TokensUnfrozen(address,address,uint256)": {
        "params": {
          "amount": "The quantity of tokens that were unfrozen from the partial freeze.",
          "sender": "The address that initiated the partial unfreeze operation. `indexed`.",
          "user": "The address for which a specific amount of tokens was unfrozen. `indexed`."
        }
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
      },
      "TransferCompleted(address,address,address,uint256)": {
        "params": {
          "amount": "The quantity of tokens transferred.",
          "from": "The address from which tokens were sent.",
          "sender": "The address that initiated the transfer action (could be the `from` address or an operator).",
          "to": "The address to which tokens were received."
        }
      },
      "Unpaused(address)": {
        "details": "This event signals that standard operations are likely resumed.",
        "params": {
          "sender": "The address that initiated the `unpause` operation. Similar to `Paused` event, this is               typically an authorized account. `indexed` for filtering."
        }
      },
      "UpdatedTokenInformation(address,uint8,address)": {
        "details": "Note: While `name` and `symbol` are part of `IERC20Metadata`, their update mechanism isn't explicitly defined here,      but if updatable, would likely also trigger such an event. This event specifically calls out decimals and onchainID.",
        "params": {
          "_newDecimals": "The new number of decimal places the token uses. (Note: Changing decimals post-deployment is highly unusual and complex for ERC20 tokens).",
          "_newOnchainID": "The address of the new on-chain Identity contract representing the token itself (if applicable).",
          "sender": "The address of the account (e.g., admin) that initiated the update."
        }
      }
    },
    "errors": {
      "AccessControlUnauthorizedAccount(address,bytes32)": [
        {
          "details": "Error: Account Lacks Required Role.      This error is emitted when an action is attempted by an account (`account`)      that does not possess the necessary authorization role (`neededRole`).      For example, if an account tries to mint new tokens but doesn't have the 'MINTER_ROLE'.",
          "params": {
            "account": "The address of the account that attempted the unauthorized action.",
            "neededRole": "The `bytes32` identifier of the role that the `account` was missing."
          }
        }
      ],
      "CannotRecoverSelf()": [
        {
          "details": "The `recoverERC20` function is designed to recover other ERC20 tokens mistakenly sent to this contract,      not the token this contract itself represents."
        }
      ],
      "DuplicateModule(address)": [
        {
          "params": {
            "module": "The address of the duplicate compliance module."
          }
        }
      ],
      "ExpectedPause()": [
        {
          "details": "For example, this might be used if an `unpause()` function is called when the contract is already unpaused,      or if a specific admin action is only allowed during a maintenance (paused) period."
        }
      ],
      "FreezeAmountExceedsAvailableBalance(uint256,uint256)": [
        {
          "params": {
            "available": "The available, unfrozen balance of the user.",
            "requested": "The amount of tokens requested to be frozen."
          }
        }
      ],
      "InsufficientCollateral(uint256,uint256)": [
        {
          "details": "This error is thrown by the `__collateral_beforeMintLogic` function if a valid collateral claim      is found on the token contract's identity, but the `amount` specified in that claim is less than      what the token's total supply would become *after* the current mint operation.      For example, if the collateral claim specifies a collateral amount (effectively a supply cap) of 1,000,000 tokens,      the current total supply is 900,000, and an attempt is made to mint 200,000 more tokens,      the `required` total supply would be 1,100,000. Since 1,100,000 (required) > 1,000,000 (available), this error occurs.      It also occurs if no valid collateral claim is found (in which case `available` would be 0), unless the      `required` supply is also 0.",
          "params": {
            "available": "The collateral amount found in the valid, non-expired claim on the token's identity. This acts as the effective cap.",
            "required": "The total supply that would be reached if the mint operation were to proceed (current supply + mint amount)."
          }
        }
      ],
      "InsufficientFrozenTokens(uint256,uint256)": [
        {
          "params": {
            "frozenBalance": "The current amount of tokens specifically frozen for the address.",
            "requested": "The amount requested to be unfrozen or used from the frozen portion."
          }
        }
      ],
      "InsufficientTokenBalance()": [
        {
          "details": "This typically occurs during token recovery if the contract holds less of the target token than the amount requested for recovery."
        }
      ],
      "InvalidCollateralTopic(uint256)": [
        {
          "details": "This error is thrown by the initializer or constructor of the collateral extension      if the provided `collateralProofTopic_` (the ERC-735 claim topic ID) is invalid.      Typically, an invalid topic ID would be `0`, as topic ID 0 is often reserved or considered null.      A valid topic ID is crucial for correctly identifying and verifying the specific collateral claims.",
          "params": {
            "topicId": "The invalid topic ID (e.g., 0) that was provided during the contract's initialization."
          }
        }
      ],
      "InvalidDecimals(uint8)": [
        {
          "details": "This error is typically reverted if `decimals` is greater than 18, which is a common upper limit.",
          "params": {
            "decimals": "The invalid decimals value that was provided."
          }
        }
      ],
      "InvalidLostWallet()": [
        {
          "details": "This can occur if the wallet is not associated with any lost identity."
        }
      ],
      "LengthMismatch()": [
        {
          "details": "This error is typically triggered in functions that process multiple items in batches,      such as `batchBurn` or `batchTransfer`, when the input arrays (e.g., an array of addresses      and an array of corresponding amounts) do not have the same number of elements.      For example, if 3 addresses are provided but only 2 amounts, this error would be raised      because it's unclear how to map the amounts to the addresses."
        }
      ],
      "MintNotCompliant()": [
        {
          "details": "This means the conditions required by the active compliance modules for minting were not met."
        }
      ],
      "ModuleNotFound()": [
        {
          "details": "This can occur when trying to remove or update parameters for a non-existent module."
        }
      ],
      "NoTokensToRecover()": [
        {
          "details": "This can occur if the contract holds no tokens to recover."
        }
      ],
      "TokenPaused()": [
        {
          "details": "For example, this error is typically used in a `whenNotPaused` modifier if a function like `transfer`      is called while the token operations are halted."
        }
      ],
      "TransferNotCompliant()": [
        {
          "details": "This means the conditions required by the active compliance modules for transferring tokens were not met."
        }
      ],
      "ZeroAddressNotAllowed()": [
        {
          "details": "This error is used to indicate that an operation or initialization was attempted with the      zero address (`address(0)`), which is often an invalid or disallowed address in many contexts.      For example, setting a critical administrative role to the zero address, or transferring tokens      to the zero address (which can effectively burn them, but should be explicit if intended)."
        }
      ]
    },
    "title": "Interface for a ATK Deposit token"
  },
  "id": 10
}