{
  "abi": [
    {
      "type": "function",
      "name": "allowance",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "spender",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "approve",
      "inputs": [
        {
          "name": "spender",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "balanceOf",
      "inputs": [
        {
          "name": "account",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "batchBurn",
      "inputs": [
        {
          "name": "_userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchForcedTransfer",
      "inputs": [
        {
          "name": "_fromList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_toList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchFreezePartialTokens",
      "inputs": [
        {
          "name": "_userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchMint",
      "inputs": [
        {
          "name": "_toList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchSetAddressFrozen",
      "inputs": [
        {
          "name": "_userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_freeze",
          "type": "bool[]",
          "internalType": "bool[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchTransfer",
      "inputs": [
        {
          "name": "_toList",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "batchUnfreezePartialTokens",
      "inputs": [
        {
          "name": "_userAddresses",
          "type": "address[]",
          "internalType": "address[]"
        },
        {
          "name": "_amounts",
          "type": "uint256[]",
          "internalType": "uint256[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "burn",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "compliance",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IERC3643Compliance"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint8",
          "internalType": "uint8"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "forcedTransfer",
      "inputs": [
        {
          "name": "_from",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "freezePartialTokens",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "getFrozenTokens",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "identityRegistry",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IERC3643IdentityRegistry"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "isFrozen",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "mint",
      "inputs": [
        {
          "name": "_to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "name",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "onchainID",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "pause",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "paused",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "recoveryAddress",
      "inputs": [
        {
          "name": "_lostWallet",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_newWallet",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_investorOnchainID",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setAddressFrozen",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_freeze",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setCompliance",
      "inputs": [
        {
          "name": "_compliance",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setIdentityRegistry",
      "inputs": [
        {
          "name": "_identityRegistry",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setName",
      "inputs": [
        {
          "name": "_name",
          "type": "string",
          "internalType": "string"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setOnchainID",
      "inputs": [
        {
          "name": "_onchainID",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setSymbol",
      "inputs": [
        {
          "name": "_symbol",
          "type": "string",
          "internalType": "string"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "symbol",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "totalSupply",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "transfer",
      "inputs": [
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "transferFrom",
      "inputs": [
        {
          "name": "from",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unfreezePartialTokens",
      "inputs": [
        {
          "name": "_userAddress",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unpause",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "version",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "string",
          "internalType": "string"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "event",
      "name": "Approval",
      "inputs": [
        {
          "name": "owner",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "spender",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Transfer",
      "inputs": [
        {
          "name": "from",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "to",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "value",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    }
  ],
  "bytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "deployedBytecode": {
    "object": "0x",
    "sourceMap": "",
    "linkReferences": {}
  },
  "methodIdentifiers": {
    "allowance(address,address)": "dd62ed3e",
    "approve(address,uint256)": "095ea7b3",
    "balanceOf(address)": "70a08231",
    "batchBurn(address[],uint256[])": "4a6cc677",
    "batchForcedTransfer(address[],address[],uint256[])": "42a47abc",
    "batchFreezePartialTokens(address[],uint256[])": "fc7e5fa8",
    "batchMint(address[],uint256[])": "68573107",
    "batchSetAddressFrozen(address[],bool[])": "1a7af379",
    "batchTransfer(address[],uint256[])": "88d695b2",
    "batchUnfreezePartialTokens(address[],uint256[])": "4710362d",
    "burn(address,uint256)": "9dc29fac",
    "compliance()": "6290865d",
    "decimals()": "313ce567",
    "forcedTransfer(address,address,uint256)": "9fc1d0e7",
    "freezePartialTokens(address,uint256)": "125c4a33",
    "getFrozenTokens(address)": "158b1a57",
    "identityRegistry()": "134e18f4",
    "isFrozen(address)": "e5839836",
    "mint(address,uint256)": "40c10f19",
    "name()": "06fdde03",
    "onchainID()": "aba63705",
    "pause()": "8456cb59",
    "paused()": "5c975abb",
    "recoveryAddress(address,address,address)": "9285948a",
    "setAddressFrozen(address,bool)": "c69c09cf",
    "setCompliance(address)": "f8981789",
    "setIdentityRegistry(address)": "cbf3f861",
    "setName(string)": "c47f0027",
    "setOnchainID(address)": "3d1ddc5b",
    "setSymbol(string)": "b84c8246",
    "symbol()": "95d89b41",
    "totalSupply()": "18160ddd",
    "transfer(address,uint256)": "a9059cbb",
    "transferFrom(address,address,uint256)": "23b872dd",
    "unfreezePartialTokens(address,uint256)": "1fe56f7d",
    "unpause()": "3f4ba83a",
    "version()": "54fd4d50"
  },
  "rawMetadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fromList\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_toList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchForcedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchFreezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_toList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_freeze\",\"type\":\"bool[]\"}],\"name\":\"batchSetAddressFrozen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_toList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchUnfreezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compliance\",\"outputs\":[{\"internalType\":\"contract IERC3643Compliance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"forcedTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"freezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getFrozenTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityRegistry\",\"outputs\":[{\"internalType\":\"contract IERC3643IdentityRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onchainID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lostWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_investorOnchainID\",\"type\":\"address\"}],\"name\":\"recoveryAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"setAddressFrozen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_compliance\",\"type\":\"address\"}],\"name\":\"setCompliance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identityRegistry\",\"type\":\"address\"}],\"name\":\"setIdentityRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_onchainID\",\"type\":\"address\"}],\"name\":\"setOnchainID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unfreezePartialTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the value of tokens owned by `account`.\"},\"batchBurn(address[],uint256[])\":{\"details\":\"Initiates burning of tokens in batch.  Requires that the `_userAddresses` addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \\\"OUT OF GAS\\\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.\",\"params\":{\"_amounts\":\"The number of tokens to burn from the corresponding wallets.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from burning tokens.  Emits _userAddresses.length `Transfer` events upon successful batch burn.  To execute this function, the calling agent must not be restricted from burning tokens.  If the agent is restricted from this capability, the function call will fail.\",\"_userAddresses\":\"The addresses of the wallets concerned by the burn.\"}},\"batchForcedTransfer(address[],address[],uint256[])\":{\"details\":\"Initiates forced transfers in batch.  Requires that each _amounts[i] does not exceed the available balance of _fromList[i].  Requires that the _toList addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF _fromList.length IS TOO HIGH.  USE WITH CARE TO AVOID \\\"OUT OF GAS\\\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.\",\"params\":{\"_amounts\":\"The number of tokens to transfer to the corresponding receiver.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from initiating forced transfers in batch.  Emits `TokensUnfrozen` events for each `_amounts[i]` that exceeds the free balance of `_fromList[i]`.  Also emits _fromList.length `Transfer` events upon successful batch transfer.  To execute this function, the calling agent must not be restricted from initiating forced transfer.  If the agent is restricted from this capability, the function call will fail.\",\"_fromList\":\"The addresses of the senders.\",\"_toList\":\"The addresses of the receivers.\"}},\"batchFreezePartialTokens(address[],uint256[])\":{\"details\":\"Initiates partial freezing of tokens in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \\\"OUT OF GAS\\\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.\",\"params\":{\"_amounts\":\"The amount of tokens to freeze on the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from partially freezing tokens.  Emits _userAddresses.length `TokensFrozen` events upon successful batch partial freezing.  To execute this function, the calling agent must not be restricted from partially freezing tokens.  If the agent is restricted from this capability, the function call will fail.\",\"_userAddresses\":\"The addresses on which tokens need to be partially frozen.\"}},\"batchMint(address[],uint256[])\":{\"details\":\"Initiates minting of tokens in batch.  Requires that the `_toList` addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH.  USE WITH CARE TO AVOID \\\"OUT OF GAS\\\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.\",\"params\":{\"_amounts\":\"The number of tokens to mint to the corresponding receiver.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from minting tokens.  Emits _toList.length `Transfer` events upon successful batch minting.  To execute this function, the calling agent must not be restricted from minting tokens.  If the agent is restricted from this capability, the function call will fail.\",\"_toList\":\"The addresses of the receivers.\"}},\"batchSetAddressFrozen(address[],bool[])\":{\"details\":\"Initiates setting of frozen status for addresses in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \\\"OUT OF GAS\\\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.\",\"params\":{\"_freeze\":\"Frozen status of the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from setting frozen addresses.  Emits _userAddresses.length `AddressFrozen` events upon successful batch update of frozen status.  To execute this function, the calling agent must not be restricted from setting frozen addresses.  If the agent is restricted from this capability, the function call will fail.\",\"_userAddresses\":\"The addresses for which to update frozen status.\"}},\"batchTransfer(address[],uint256[])\":{\"details\":\"function allowing to issue transfers in batch  Require that the _msgSender() and `to` addresses are not frozen.  Require that the total value should not exceed available balance.  Require that the `to` addresses are all verified addresses,  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \\\"OUT OF GAS\\\" TRANSACTION\",\"params\":{\"_amounts\":\"The number of tokens to transfer to the corresponding receiver  emits _toList.length `Transfer` events\",\"_toList\":\"The addresses of the receivers\"}},\"batchUnfreezePartialTokens(address[],uint256[])\":{\"details\":\"Initiates partial unfreezing of tokens in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \\\"OUT OF GAS\\\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.\",\"params\":{\"_amounts\":\"The amount of tokens to unfreeze on the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from partially freezing tokens.  Emits _userAddresses.length `TokensUnfrozen` events upon successful batch partial unfreezing.  To execute this function, the calling agent must not be restricted from partially freezing tokens.  If the agent is restricted from this capability, the function call will fail.\",\"_userAddresses\":\"The addresses on which tokens need to be partially unfrozen.\"}},\"burn(address,uint256)\":{\"details\":\"Burns tokens from a specified address.  If the account address does not have sufficient free tokens (unfrozen tokens)  but possesses a total balance equal to or greater than the specified value,  the frozen token amount is reduced to ensure enough free tokens for the burn.  In such cases, the remaining balance in the account consists entirely of frozen tokens post-transaction.\",\"params\":{\"_amount\":\"Amount of tokens to burn.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from burning tokens.  Emits a `TokensUnfrozen` event if `_amount` exceeds the free balance of `_userAddress`.  Also emits a `Transfer` event.  To execute this function, the calling agent must not be restricted from burning tokens.  If the agent is restricted from this capability, the function call will fail.\",\"_userAddress\":\"Address to burn the tokens from.\"}},\"compliance()\":{\"details\":\"Returns the Compliance contract linked to the token\"},\"decimals()\":{\"details\":\"Returns the decimals places of the token.\"},\"forcedTransfer(address,address,uint256)\":{\"details\":\"Initiates a forced transfer of tokens between two whitelisted wallets.  If the `from` address does not have sufficient free tokens (unfrozen tokens)  but possesses a total balance equal to or greater than the specified `amount`,  the frozen token amount is reduced to ensure enough free tokens for the transfer.  In such cases, the remaining balance in the `from` account consists entirely of frozen tokens post-transfer.  It is imperative that the `to` address is a verified and whitelisted address.\",\"params\":{\"_amount\":\"The number of tokens to be transferred.  This function can only be invoked by a wallet designated as an agent of the token,  provided the agent is not restricted from initiating forced transfers of the token.  Emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_from`.  Also emits a `Transfer` event.  To execute this function, the calling agent must not be restricted from initiating forced transfers of the token.  If the agent is restricted from this capability, the function call will fail.  The function can only be called when the contract is not already paused.  error `AgentNotAuthorized` - Thrown if the agent is restricted from initiating forced transfers of the token,  indicating they do not have the necessary permissions to execute this function.\",\"_from\":\"The address of the sender.\",\"_to\":\"The address of the receiver.\"}},\"freezePartialTokens(address,uint256)\":{\"details\":\"Freezes a specified token amount for a given address, preventing those tokens from being transferred. This function can be called by an agent of the token, provided the agent is not restricted from freezing tokens. emits a `TokensFrozen` event upon successful execution.\",\"params\":{\"_amount\":\"The amount of tokens to be frozen.\",\"_userAddress\":\"The address for which to freeze tokens.\"}},\"getFrozenTokens(address)\":{\"details\":\"Returns the amount of tokens that are partially frozen on a wallet  the amount of frozen tokens is always <= to the total balance of the wallet\",\"params\":{\"_userAddress\":\"the address of the wallet on which getFrozenTokens is called\"}},\"identityRegistry()\":{\"details\":\"Returns the Identity Registry linked to the token\"},\"isFrozen(address)\":{\"details\":\"Returns the freezing status of a wallet  if isFrozen returns `true` the wallet is frozen  if isFrozen returns `false` the wallet is not frozen  isFrozen returning `true` doesn't mean that the balance is free, tokens could be blocked by  a partial freeze or the whole token could be blocked by pause\",\"params\":{\"_userAddress\":\"the address of the wallet on which isFrozen is called\"}},\"mint(address,uint256)\":{\"details\":\"Mints tokens to a specified address.  This enhanced version of the default mint method allows tokens to be minted  to an address only if it is a verified and whitelisted address according to the security token.\",\"params\":{\"_amount\":\"Amount of tokens to mint.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from minting tokens.  Emits a `Transfer` event upon successful minting.  To execute this function, the calling agent must not be restricted from minting tokens.  If the agent is restricted from this capability, the function call will fail.\",\"_to\":\"Address to mint the tokens to.\"}},\"name()\":{\"details\":\"Returns the name of the token.\"},\"onchainID()\":{\"details\":\"Returns the address of the onchainID of the token. the onchainID of the token gives all the information available about the token and is managed by the token issuer or his agent.\"},\"pause()\":{\"details\":\"Pauses the token contract. When the contract is paused, investors cannot transfer tokens anymore. This function can only be called by an agent of the token, provided the agent is not restricted from pausing the token. emits a `Paused` event upon successful execution. To pause token transfers, the calling agent must have pausing capabilities enabled. If the agent is disabled from pausing, the function call will fail. The function can be called only when the contract is not already paused. error AgentNotAuthorized - Thrown if the agent is disabled from pausing the token, indicating they do not have the necessary permissions to execute this function.\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"recoveryAddress(address,address,address)\":{\"details\":\"Initiates a recovery process to transfer tokens and associated states from a lost wallet to a new wallet for an investor. This function allows an authorized agent to recover tokens from a lost wallet, transferring them to a new wallet while preserving the investor's identity and status within the token ecosystem. The function ensures that all relevant data, including frozen tokens and address freezing status, is accurately transferred to the new wallet.\",\"params\":{\"_investorOnchainID\":\"The ONCHAINID of the investor whose tokens are being recovered. Requirements: - The caller must be an agent authorized to perform recovery operations, with no restrictions on this capability. - The `_lostWallet` must have a non-zero token balance; otherwise, the recovery is unnecessary and will revert. - Either the `_lostWallet` or the `_newWallet` must be present in the identity registry;   if neither is present, the function will revert. Operations: - Transfers the entire token balance from `_lostWallet` to `_newWallet`. - Transfers any frozen tokens from `_lostWallet` to `_newWallet`, updating the frozen token count accordingly. - Transfers the address freeze status from `_lostWallet` to `_newWallet`,   ensuring the new wallet retains any restrictions if applicable. - Updates the identity registry:   - If `_lostWallet` is listed in the identity registry, it will be removed,     and `_newWallet` will be registered unless already present. Emits the following events: - `TokensUnfrozen` if there are frozen tokens on `_lostWallet` that are transferred. - `TokensFrozen` if frozen tokens are added to `_newWallet`. - `AddressFrozen` if the freeze status of either wallet changes. - `Transfer` to reflect the movement of tokens from `_lostWallet` to `_newWallet`. - `RecoverySuccess` upon successful completion of the recovery process. Reverts if: - The agent calling the function does not have the necessary permissions to perform recovery (`AgentNotAuthorized`). - The `_lostWallet` has no tokens to recover (`NoTokenToRecover`). - Neither `_lostWallet` nor `_newWallet` is present in the identity registry (`RecoveryNotPossible`).\",\"_lostWallet\":\"The wallet that the investor lost, containing the tokens to be recovered.\",\"_newWallet\":\"The newly provided wallet to which tokens and associated statuses must be transferred.\"},\"returns\":{\"_0\":\"A boolean value indicating whether the recovery process was successful.\"}},\"setAddressFrozen(address,bool)\":{\"details\":\"Sets an address's frozen status for this token, either freezing or unfreezing the address based on the provided boolean value. This function can be called by an agent of the token, assuming the agent is not restricted from freezing addresses. emits an `AddressFrozen` event upon successful execution.\",\"params\":{\"_freeze\":\"The frozen status to be applied: `true` to freeze, `false` to unfreeze.\",\"_userAddress\":\"The address for which to update the frozen status.\"}},\"setCompliance(address)\":{\"details\":\"sets the compliance contract of the token\",\"params\":{\"_compliance\":\"the address of the compliance contract to set  Only the owner of the token smart contract can call this function  calls bindToken on the compliance contract  emits a `ComplianceAdded` event\"}},\"setIdentityRegistry(address)\":{\"details\":\"sets the Identity Registry for the token\",\"params\":{\"_identityRegistry\":\"the address of the Identity Registry to set  Only the owner of the token smart contract can call this function  emits an `IdentityRegistryAdded` event\"}},\"setName(string)\":{\"details\":\"sets the token name\",\"params\":{\"_name\":\"the name of token to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event\"}},\"setOnchainID(address)\":{\"details\":\"sets the onchain ID of the token\",\"params\":{\"_onchainID\":\"the address of the onchain ID to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event\"}},\"setSymbol(string)\":{\"details\":\"sets the token symbol\",\"params\":{\"_symbol\":\"the token symbol to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event\"}},\"symbol()\":{\"details\":\"Returns the symbol of the token.\"},\"totalSupply()\":{\"details\":\"Returns the value of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"unfreezePartialTokens(address,uint256)\":{\"details\":\"Unfreezes a specified token amount for a given address, allowing those tokens to be transferred again. This function can be called by an agent of the token, assuming the agent is not restricted from unfreezing tokens. emits a `TokensUnfrozen` event upon successful execution.\",\"params\":{\"_amount\":\"The amount of tokens to be unfrozen.\",\"_userAddress\":\"The address for which to unfreeze tokens.\"}},\"unpause()\":{\"details\":\"Unpauses the token contract, allowing investors to resume token transfers under normal conditions This function can only be called by an agent of the token, provided the agent is not restricted from pausing the token. emits an `Unpaused` event upon successful execution. To unpause token transfers, the calling agent must have pausing capabilities enabled. If the agent is disabled from pausing, the function call will fail. The function can be called only when the contract is currently paused. error AgentNotAuthorized - Thrown if the agent is disabled from pausing the token, indicating they do not have the necessary permissions to execute this function.\"},\"version()\":{\"details\":\"Returns the TREX version of the token.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"freezePartialTokens(address,uint256)\":{\"notice\":\"To freeze tokens for an address, the calling agent must have the capability to freeze tokens enabled. If the agent is disabled from freezing tokens, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from freezing tokens, indicating they do not have the necessary permissions to execute this function.\"},\"setAddressFrozen(address,bool)\":{\"notice\":\"To change an address's frozen status, the calling agent must have the capability to freeze addresses enabled. If the agent is disabled from freezing addresses, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from freezing addresses, indicating they do not have the necessary permissions to execute this function.\"},\"unfreezePartialTokens(address,uint256)\":{\"notice\":\"To unfreeze tokens for an address, the calling agent must have the capability to unfreeze tokens enabled. If the agent is disabled from unfreezing tokens, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from unfreezing tokens, indicating they do not have the necessary permissions to execute this function.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/smart/interface/ERC-3643/IERC3643.sol\":\"IERC3643\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@onchainid-v2.2.1/=dependencies/@onchainid-v2.2.1/contracts/\",\":@onchainid/contracts/=dependencies/@onchainid-v2.2.1/contracts/\",\":@openzeppelin-contracts-5.3.0/=dependencies/@openzeppelin-contracts-5.3.0/\",\":@openzeppelin-contracts-upgradeable-5.3.0/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/\",\":@openzeppelin/contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/\",\":@openzeppelin/contracts/=dependencies/@openzeppelin-contracts-5.3.0/\",\":forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/\",\":forge-std/=dependencies/forge-std-1.9.7/src/\"],\"viaIR\":true},\"sources\":{\"contracts/smart/interface/ERC-3643/IERC3643.sol\":{\"keccak256\":\"0x099776fa1fad2e252662b28361a83edab590f91199705308582d18ac5647294b\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://72ab4565218df61982b12925949efbef16829ff94c7b6cbc8f57985ff11d1bc0\",\"dweb:/ipfs/QmehWa3gD4p7ijEsfrJ6xsYrVVEXvTkQvwxa74quvab5pU\"]},\"contracts/smart/interface/ERC-3643/IERC3643ClaimTopicsRegistry.sol\":{\"keccak256\":\"0xb085bf139ab9b7e15dd09374bc112774e068f92601842626e50f36dbd95951fa\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://61eb64cf3dacd25cfc5ccdc62a09ccc6a327691a9e3023007ebf0987803e3d55\",\"dweb:/ipfs/QmTV5trbDvpVrpkU2eGj9r5wxJnnRK26GfGUoRnm4m91De\"]},\"contracts/smart/interface/ERC-3643/IERC3643Compliance.sol\":{\"keccak256\":\"0x803db557cae3cdd49ad7c7f668fe9c5583ade2575e24b234224dde54115abef0\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://e44d3e6b2ecfe5f719362edd3b1177926ccc748837361fd4ffd3f8c39dfa25d2\",\"dweb:/ipfs/QmTPQzetHvAj8y8CHC6fB69twDFmpLz371A6uFzb2kiH2T\"]},\"contracts/smart/interface/ERC-3643/IERC3643IdentityRegistry.sol\":{\"keccak256\":\"0x5c0cf01862935ea3ce46409b73e362334344acb128af2d53d3ae66dd1d5ebb82\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://c1520768602149d894d6ffb05989cc9a4474d13e996b26c98a80f44a7e440370\",\"dweb:/ipfs/QmZGHa5natSu5LLnyKSi2dkQjafWzX5E5KZYXD4LtqUsFR\"]},\"contracts/smart/interface/ERC-3643/IERC3643IdentityRegistryStorage.sol\":{\"keccak256\":\"0x3a8a72df8da5bf4d988bbfb00151b933ff17cdc8d4be47dc121cd9e2083ba86f\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://369250658bf8d3ebb583946820afa494271ce6bfde607d15c7060cdf7a303cf3\",\"dweb:/ipfs/QmSJjaK6vyv8K9RX1k3rwxsoKfVNyMoHEszxyxdTQfDKQG\"]},\"contracts/smart/interface/ERC-3643/IERC3643TrustedIssuersRegistry.sol\":{\"keccak256\":\"0x15b72940814cd959b57bf75623f16c51fc6c50eab51fd2420a8b653519ebd76c\",\"license\":\"CC0-1.0\",\"urls\":[\"bzz-raw://479f5e24a1b608776d9d5d7da9c76dd3c9b1dd300d8b4eee7a15dcfba4817bee\",\"dweb:/ipfs/QmPhMBfQAqt5NeRcSu3jDTwhoQXnB7nXNEcmoJ7KoWVt7V\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IClaimIssuer.sol\":{\"keccak256\":\"0xae785f63b3cb3a94bcb454ef4ad6376aa4848fa29cff1cc8db3bef4a2994a779\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://d8223d2710c51ee39cdfd2cb2f1858b3d64a3222c78ea8ed5eb3e11a93e1222e\",\"dweb:/ipfs/QmYRXPCww7BorScTC6QNMbrRm2zprUmSYFpWomwarJH7Df\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IERC734.sol\":{\"keccak256\":\"0x35a14a0d1a3ed51689f1a2cb12e26d30601afbcc1cc9b9b288a03cd11e6d049e\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://156aac402e73e6bd2fa8c0ccd85b2add8d1bb505d8a652218173dbc8e7b9a3cb\",\"dweb:/ipfs/QmPzPyc3kKxoNCGqKAooUju6YvMkDN4MCUH198TEXnA82o\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IERC735.sol\":{\"keccak256\":\"0xeac82c37b16c1c1c83df3e88be987332b1230ed13e1d017f9d2929f978ac0122\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://695a66b789ac417b7b2b78c578981779db374704382921ff499351cccab0323e\",\"dweb:/ipfs/QmeZoogvsEWf688Z849zZ2dLPDnor6YnnNQLMgedY9Tc9D\"]},\"dependencies/@onchainid-v2.2.1/contracts/interface/IIdentity.sol\":{\"keccak256\":\"0x5ed42ab81b9b734c79e61d1f7e0734baab5479a356ab6bb469414d3c66269862\",\"license\":\"GPL-3.0\",\"urls\":[\"bzz-raw://a0863999b1ed334179a43e699e6057815eea011a78ed51e61b6110fc392e26f8\",\"dweb:/ipfs/Qme6hdHZCAy1V4sLgAZ5NxdrEjEf5mYMabf5UDmUDjkuzW\"]},\"dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db\",\"dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9\"]},\"dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x70f2f713b13b7ce4610bcd0ac9fec0f3cc43693b043abcb8dc40a42a726eb330\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c13d13304ac79a83ab1c30168967d19e2203342ebbd6a9bbce4db7550522dcbf\",\"dweb:/ipfs/QmeN5jKMN2vw5bhacr6tkg78afbTTZUeaacNHqjWt4Ew1r\"]},\"dependencies/@openzeppelin-contracts-5.3.0/utils/introspection/IERC165.sol\":{\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f6fda447a62815e8064f47eff0dd1cf58d9207ad69b5d32280f8d7ed1d1e4621\",\"dweb:/ipfs/QmfDRc7pxfaXB2Dh9np5Uf29Na3pQ7tafRS684wd3GLjVL\"]}},\"version\":1}",
  "metadata": {
    "compiler": {
      "version": "0.8.28+commit.7893614a"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "Approval",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address",
              "indexed": true
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "Transfer",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "spender",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "spender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchBurn"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_fromList",
              "type": "address[]"
            },
            {
              "internalType": "address[]",
              "name": "_toList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchForcedTransfer"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchFreezePartialTokens"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_toList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchMint"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "bool[]",
              "name": "_freeze",
              "type": "bool[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchSetAddressFrozen"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_toList",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchTransfer"
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "_userAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "_amounts",
              "type": "uint256[]"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "batchUnfreezePartialTokens"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "compliance",
          "outputs": [
            {
              "internalType": "contract IERC3643Compliance",
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "outputs": [
            {
              "internalType": "uint8",
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "forcedTransfer",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "freezePartialTokens"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "getFrozenTokens",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "identityRegistry",
          "outputs": [
            {
              "internalType": "contract IERC3643IdentityRegistry",
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "isFrozen",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "onchainID",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "paused",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_lostWallet",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_newWallet",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_investorOnchainID",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoveryAddress",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "_freeze",
              "type": "bool"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAddressFrozen"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_compliance",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCompliance"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_identityRegistry",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIdentityRegistry"
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "_name",
              "type": "string"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setName"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_onchainID",
              "type": "address"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setOnchainID"
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "_symbol",
              "type": "string"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setSymbol"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_userAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "unfreezePartialTokens"
        },
        {
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "unpause"
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "version",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ]
        }
      ],
      "devdoc": {
        "kind": "dev",
        "methods": {
          "allowance(address,address)": {
            "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
          },
          "approve(address,uint256)": {
            "details": "Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
          },
          "balanceOf(address)": {
            "details": "Returns the value of tokens owned by `account`."
          },
          "batchBurn(address[],uint256[])": {
            "details": "Initiates burning of tokens in batch.  Requires that the `_userAddresses` addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
            "params": {
              "_amounts": "The number of tokens to burn from the corresponding wallets.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from burning tokens.  Emits _userAddresses.length `Transfer` events upon successful batch burn.  To execute this function, the calling agent must not be restricted from burning tokens.  If the agent is restricted from this capability, the function call will fail.",
              "_userAddresses": "The addresses of the wallets concerned by the burn."
            }
          },
          "batchForcedTransfer(address[],address[],uint256[])": {
            "details": "Initiates forced transfers in batch.  Requires that each _amounts[i] does not exceed the available balance of _fromList[i].  Requires that the _toList addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF _fromList.length IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
            "params": {
              "_amounts": "The number of tokens to transfer to the corresponding receiver.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from initiating forced transfers in batch.  Emits `TokensUnfrozen` events for each `_amounts[i]` that exceeds the free balance of `_fromList[i]`.  Also emits _fromList.length `Transfer` events upon successful batch transfer.  To execute this function, the calling agent must not be restricted from initiating forced transfer.  If the agent is restricted from this capability, the function call will fail.",
              "_fromList": "The addresses of the senders.",
              "_toList": "The addresses of the receivers."
            }
          },
          "batchFreezePartialTokens(address[],uint256[])": {
            "details": "Initiates partial freezing of tokens in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
            "params": {
              "_amounts": "The amount of tokens to freeze on the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from partially freezing tokens.  Emits _userAddresses.length `TokensFrozen` events upon successful batch partial freezing.  To execute this function, the calling agent must not be restricted from partially freezing tokens.  If the agent is restricted from this capability, the function call will fail.",
              "_userAddresses": "The addresses on which tokens need to be partially frozen."
            }
          },
          "batchMint(address[],uint256[])": {
            "details": "Initiates minting of tokens in batch.  Requires that the `_toList` addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
            "params": {
              "_amounts": "The number of tokens to mint to the corresponding receiver.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from minting tokens.  Emits _toList.length `Transfer` events upon successful batch minting.  To execute this function, the calling agent must not be restricted from minting tokens.  If the agent is restricted from this capability, the function call will fail.",
              "_toList": "The addresses of the receivers."
            }
          },
          "batchSetAddressFrozen(address[],bool[])": {
            "details": "Initiates setting of frozen status for addresses in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
            "params": {
              "_freeze": "Frozen status of the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from setting frozen addresses.  Emits _userAddresses.length `AddressFrozen` events upon successful batch update of frozen status.  To execute this function, the calling agent must not be restricted from setting frozen addresses.  If the agent is restricted from this capability, the function call will fail.",
              "_userAddresses": "The addresses for which to update frozen status."
            }
          },
          "batchTransfer(address[],uint256[])": {
            "details": "function allowing to issue transfers in batch  Require that the _msgSender() and `to` addresses are not frozen.  Require that the total value should not exceed available balance.  Require that the `to` addresses are all verified addresses,  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION",
            "params": {
              "_amounts": "The number of tokens to transfer to the corresponding receiver  emits _toList.length `Transfer` events",
              "_toList": "The addresses of the receivers"
            }
          },
          "batchUnfreezePartialTokens(address[],uint256[])": {
            "details": "Initiates partial unfreezing of tokens in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
            "params": {
              "_amounts": "The amount of tokens to unfreeze on the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from partially freezing tokens.  Emits _userAddresses.length `TokensUnfrozen` events upon successful batch partial unfreezing.  To execute this function, the calling agent must not be restricted from partially freezing tokens.  If the agent is restricted from this capability, the function call will fail.",
              "_userAddresses": "The addresses on which tokens need to be partially unfrozen."
            }
          },
          "burn(address,uint256)": {
            "details": "Burns tokens from a specified address.  If the account address does not have sufficient free tokens (unfrozen tokens)  but possesses a total balance equal to or greater than the specified value,  the frozen token amount is reduced to ensure enough free tokens for the burn.  In such cases, the remaining balance in the account consists entirely of frozen tokens post-transaction.",
            "params": {
              "_amount": "Amount of tokens to burn.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from burning tokens.  Emits a `TokensUnfrozen` event if `_amount` exceeds the free balance of `_userAddress`.  Also emits a `Transfer` event.  To execute this function, the calling agent must not be restricted from burning tokens.  If the agent is restricted from this capability, the function call will fail.",
              "_userAddress": "Address to burn the tokens from."
            }
          },
          "compliance()": {
            "details": "Returns the Compliance contract linked to the token"
          },
          "decimals()": {
            "details": "Returns the decimals places of the token."
          },
          "forcedTransfer(address,address,uint256)": {
            "details": "Initiates a forced transfer of tokens between two whitelisted wallets.  If the `from` address does not have sufficient free tokens (unfrozen tokens)  but possesses a total balance equal to or greater than the specified `amount`,  the frozen token amount is reduced to ensure enough free tokens for the transfer.  In such cases, the remaining balance in the `from` account consists entirely of frozen tokens post-transfer.  It is imperative that the `to` address is a verified and whitelisted address.",
            "params": {
              "_amount": "The number of tokens to be transferred.  This function can only be invoked by a wallet designated as an agent of the token,  provided the agent is not restricted from initiating forced transfers of the token.  Emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_from`.  Also emits a `Transfer` event.  To execute this function, the calling agent must not be restricted from initiating forced transfers of the token.  If the agent is restricted from this capability, the function call will fail.  The function can only be called when the contract is not already paused.  error `AgentNotAuthorized` - Thrown if the agent is restricted from initiating forced transfers of the token,  indicating they do not have the necessary permissions to execute this function.",
              "_from": "The address of the sender.",
              "_to": "The address of the receiver."
            }
          },
          "freezePartialTokens(address,uint256)": {
            "details": "Freezes a specified token amount for a given address, preventing those tokens from being transferred. This function can be called by an agent of the token, provided the agent is not restricted from freezing tokens. emits a `TokensFrozen` event upon successful execution.",
            "params": {
              "_amount": "The amount of tokens to be frozen.",
              "_userAddress": "The address for which to freeze tokens."
            }
          },
          "getFrozenTokens(address)": {
            "details": "Returns the amount of tokens that are partially frozen on a wallet  the amount of frozen tokens is always <= to the total balance of the wallet",
            "params": {
              "_userAddress": "the address of the wallet on which getFrozenTokens is called"
            }
          },
          "identityRegistry()": {
            "details": "Returns the Identity Registry linked to the token"
          },
          "isFrozen(address)": {
            "details": "Returns the freezing status of a wallet  if isFrozen returns `true` the wallet is frozen  if isFrozen returns `false` the wallet is not frozen  isFrozen returning `true` doesn't mean that the balance is free, tokens could be blocked by  a partial freeze or the whole token could be blocked by pause",
            "params": {
              "_userAddress": "the address of the wallet on which isFrozen is called"
            }
          },
          "mint(address,uint256)": {
            "details": "Mints tokens to a specified address.  This enhanced version of the default mint method allows tokens to be minted  to an address only if it is a verified and whitelisted address according to the security token.",
            "params": {
              "_amount": "Amount of tokens to mint.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from minting tokens.  Emits a `Transfer` event upon successful minting.  To execute this function, the calling agent must not be restricted from minting tokens.  If the agent is restricted from this capability, the function call will fail.",
              "_to": "Address to mint the tokens to."
            }
          },
          "name()": {
            "details": "Returns the name of the token."
          },
          "onchainID()": {
            "details": "Returns the address of the onchainID of the token. the onchainID of the token gives all the information available about the token and is managed by the token issuer or his agent."
          },
          "pause()": {
            "details": "Pauses the token contract. When the contract is paused, investors cannot transfer tokens anymore. This function can only be called by an agent of the token, provided the agent is not restricted from pausing the token. emits a `Paused` event upon successful execution. To pause token transfers, the calling agent must have pausing capabilities enabled. If the agent is disabled from pausing, the function call will fail. The function can be called only when the contract is not already paused. error AgentNotAuthorized - Thrown if the agent is disabled from pausing the token, indicating they do not have the necessary permissions to execute this function."
          },
          "paused()": {
            "details": "Returns true if the contract is paused, and false otherwise."
          },
          "recoveryAddress(address,address,address)": {
            "details": "Initiates a recovery process to transfer tokens and associated states from a lost wallet to a new wallet for an investor. This function allows an authorized agent to recover tokens from a lost wallet, transferring them to a new wallet while preserving the investor's identity and status within the token ecosystem. The function ensures that all relevant data, including frozen tokens and address freezing status, is accurately transferred to the new wallet.",
            "params": {
              "_investorOnchainID": "The ONCHAINID of the investor whose tokens are being recovered. Requirements: - The caller must be an agent authorized to perform recovery operations, with no restrictions on this capability. - The `_lostWallet` must have a non-zero token balance; otherwise, the recovery is unnecessary and will revert. - Either the `_lostWallet` or the `_newWallet` must be present in the identity registry;   if neither is present, the function will revert. Operations: - Transfers the entire token balance from `_lostWallet` to `_newWallet`. - Transfers any frozen tokens from `_lostWallet` to `_newWallet`, updating the frozen token count accordingly. - Transfers the address freeze status from `_lostWallet` to `_newWallet`,   ensuring the new wallet retains any restrictions if applicable. - Updates the identity registry:   - If `_lostWallet` is listed in the identity registry, it will be removed,     and `_newWallet` will be registered unless already present. Emits the following events: - `TokensUnfrozen` if there are frozen tokens on `_lostWallet` that are transferred. - `TokensFrozen` if frozen tokens are added to `_newWallet`. - `AddressFrozen` if the freeze status of either wallet changes. - `Transfer` to reflect the movement of tokens from `_lostWallet` to `_newWallet`. - `RecoverySuccess` upon successful completion of the recovery process. Reverts if: - The agent calling the function does not have the necessary permissions to perform recovery (`AgentNotAuthorized`). - The `_lostWallet` has no tokens to recover (`NoTokenToRecover`). - Neither `_lostWallet` nor `_newWallet` is present in the identity registry (`RecoveryNotPossible`).",
              "_lostWallet": "The wallet that the investor lost, containing the tokens to be recovered.",
              "_newWallet": "The newly provided wallet to which tokens and associated statuses must be transferred."
            },
            "returns": {
              "_0": "A boolean value indicating whether the recovery process was successful."
            }
          },
          "setAddressFrozen(address,bool)": {
            "details": "Sets an address's frozen status for this token, either freezing or unfreezing the address based on the provided boolean value. This function can be called by an agent of the token, assuming the agent is not restricted from freezing addresses. emits an `AddressFrozen` event upon successful execution.",
            "params": {
              "_freeze": "The frozen status to be applied: `true` to freeze, `false` to unfreeze.",
              "_userAddress": "The address for which to update the frozen status."
            }
          },
          "setCompliance(address)": {
            "details": "sets the compliance contract of the token",
            "params": {
              "_compliance": "the address of the compliance contract to set  Only the owner of the token smart contract can call this function  calls bindToken on the compliance contract  emits a `ComplianceAdded` event"
            }
          },
          "setIdentityRegistry(address)": {
            "details": "sets the Identity Registry for the token",
            "params": {
              "_identityRegistry": "the address of the Identity Registry to set  Only the owner of the token smart contract can call this function  emits an `IdentityRegistryAdded` event"
            }
          },
          "setName(string)": {
            "details": "sets the token name",
            "params": {
              "_name": "the name of token to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event"
            }
          },
          "setOnchainID(address)": {
            "details": "sets the onchain ID of the token",
            "params": {
              "_onchainID": "the address of the onchain ID to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event"
            }
          },
          "setSymbol(string)": {
            "details": "sets the token symbol",
            "params": {
              "_symbol": "the token symbol to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event"
            }
          },
          "symbol()": {
            "details": "Returns the symbol of the token."
          },
          "totalSupply()": {
            "details": "Returns the value of tokens in existence."
          },
          "transfer(address,uint256)": {
            "details": "Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
          },
          "transferFrom(address,address,uint256)": {
            "details": "Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
          },
          "unfreezePartialTokens(address,uint256)": {
            "details": "Unfreezes a specified token amount for a given address, allowing those tokens to be transferred again. This function can be called by an agent of the token, assuming the agent is not restricted from unfreezing tokens. emits a `TokensUnfrozen` event upon successful execution.",
            "params": {
              "_amount": "The amount of tokens to be unfrozen.",
              "_userAddress": "The address for which to unfreeze tokens."
            }
          },
          "unpause()": {
            "details": "Unpauses the token contract, allowing investors to resume token transfers under normal conditions This function can only be called by an agent of the token, provided the agent is not restricted from pausing the token. emits an `Unpaused` event upon successful execution. To unpause token transfers, the calling agent must have pausing capabilities enabled. If the agent is disabled from pausing, the function call will fail. The function can be called only when the contract is currently paused. error AgentNotAuthorized - Thrown if the agent is disabled from pausing the token, indicating they do not have the necessary permissions to execute this function."
          },
          "version()": {
            "details": "Returns the TREX version of the token."
          }
        },
        "version": 1
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "freezePartialTokens(address,uint256)": {
            "notice": "To freeze tokens for an address, the calling agent must have the capability to freeze tokens enabled. If the agent is disabled from freezing tokens, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from freezing tokens, indicating they do not have the necessary permissions to execute this function."
          },
          "setAddressFrozen(address,bool)": {
            "notice": "To change an address's frozen status, the calling agent must have the capability to freeze addresses enabled. If the agent is disabled from freezing addresses, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from freezing addresses, indicating they do not have the necessary permissions to execute this function."
          },
          "unfreezePartialTokens(address,uint256)": {
            "notice": "To unfreeze tokens for an address, the calling agent must have the capability to unfreeze tokens enabled. If the agent is disabled from unfreezing tokens, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from unfreezing tokens, indicating they do not have the necessary permissions to execute this function."
          }
        },
        "version": 1
      }
    },
    "settings": {
      "remappings": [
        "@onchainid-v2.2.1/=dependencies/@onchainid-v2.2.1/contracts/",
        "@onchainid/contracts/=dependencies/@onchainid-v2.2.1/contracts/",
        "@openzeppelin-contracts-5.3.0/=dependencies/@openzeppelin-contracts-5.3.0/",
        "@openzeppelin-contracts-upgradeable-5.3.0/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/",
        "@openzeppelin/contracts-upgradeable/=dependencies/@openzeppelin-contracts-upgradeable-5.3.0/",
        "@openzeppelin/contracts/=dependencies/@openzeppelin-contracts-5.3.0/",
        "forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/",
        "forge-std/=dependencies/forge-std-1.9.7/src/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "metadata": {
        "bytecodeHash": "none"
      },
      "compilationTarget": {
        "contracts/smart/interface/ERC-3643/IERC3643.sol": "IERC3643"
      },
      "evmVersion": "cancun",
      "libraries": {},
      "viaIR": true
    },
    "sources": {
      "contracts/smart/interface/ERC-3643/IERC3643.sol": {
        "keccak256": "0x099776fa1fad2e252662b28361a83edab590f91199705308582d18ac5647294b",
        "urls": [
          "bzz-raw://72ab4565218df61982b12925949efbef16829ff94c7b6cbc8f57985ff11d1bc0",
          "dweb:/ipfs/QmehWa3gD4p7ijEsfrJ6xsYrVVEXvTkQvwxa74quvab5pU"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ERC-3643/IERC3643ClaimTopicsRegistry.sol": {
        "keccak256": "0xb085bf139ab9b7e15dd09374bc112774e068f92601842626e50f36dbd95951fa",
        "urls": [
          "bzz-raw://61eb64cf3dacd25cfc5ccdc62a09ccc6a327691a9e3023007ebf0987803e3d55",
          "dweb:/ipfs/QmTV5trbDvpVrpkU2eGj9r5wxJnnRK26GfGUoRnm4m91De"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ERC-3643/IERC3643Compliance.sol": {
        "keccak256": "0x803db557cae3cdd49ad7c7f668fe9c5583ade2575e24b234224dde54115abef0",
        "urls": [
          "bzz-raw://e44d3e6b2ecfe5f719362edd3b1177926ccc748837361fd4ffd3f8c39dfa25d2",
          "dweb:/ipfs/QmTPQzetHvAj8y8CHC6fB69twDFmpLz371A6uFzb2kiH2T"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ERC-3643/IERC3643IdentityRegistry.sol": {
        "keccak256": "0x5c0cf01862935ea3ce46409b73e362334344acb128af2d53d3ae66dd1d5ebb82",
        "urls": [
          "bzz-raw://c1520768602149d894d6ffb05989cc9a4474d13e996b26c98a80f44a7e440370",
          "dweb:/ipfs/QmZGHa5natSu5LLnyKSi2dkQjafWzX5E5KZYXD4LtqUsFR"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ERC-3643/IERC3643IdentityRegistryStorage.sol": {
        "keccak256": "0x3a8a72df8da5bf4d988bbfb00151b933ff17cdc8d4be47dc121cd9e2083ba86f",
        "urls": [
          "bzz-raw://369250658bf8d3ebb583946820afa494271ce6bfde607d15c7060cdf7a303cf3",
          "dweb:/ipfs/QmSJjaK6vyv8K9RX1k3rwxsoKfVNyMoHEszxyxdTQfDKQG"
        ],
        "license": "CC0-1.0"
      },
      "contracts/smart/interface/ERC-3643/IERC3643TrustedIssuersRegistry.sol": {
        "keccak256": "0x15b72940814cd959b57bf75623f16c51fc6c50eab51fd2420a8b653519ebd76c",
        "urls": [
          "bzz-raw://479f5e24a1b608776d9d5d7da9c76dd3c9b1dd300d8b4eee7a15dcfba4817bee",
          "dweb:/ipfs/QmPhMBfQAqt5NeRcSu3jDTwhoQXnB7nXNEcmoJ7KoWVt7V"
        ],
        "license": "CC0-1.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IClaimIssuer.sol": {
        "keccak256": "0xae785f63b3cb3a94bcb454ef4ad6376aa4848fa29cff1cc8db3bef4a2994a779",
        "urls": [
          "bzz-raw://d8223d2710c51ee39cdfd2cb2f1858b3d64a3222c78ea8ed5eb3e11a93e1222e",
          "dweb:/ipfs/QmYRXPCww7BorScTC6QNMbrRm2zprUmSYFpWomwarJH7Df"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IERC734.sol": {
        "keccak256": "0x35a14a0d1a3ed51689f1a2cb12e26d30601afbcc1cc9b9b288a03cd11e6d049e",
        "urls": [
          "bzz-raw://156aac402e73e6bd2fa8c0ccd85b2add8d1bb505d8a652218173dbc8e7b9a3cb",
          "dweb:/ipfs/QmPzPyc3kKxoNCGqKAooUju6YvMkDN4MCUH198TEXnA82o"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IERC735.sol": {
        "keccak256": "0xeac82c37b16c1c1c83df3e88be987332b1230ed13e1d017f9d2929f978ac0122",
        "urls": [
          "bzz-raw://695a66b789ac417b7b2b78c578981779db374704382921ff499351cccab0323e",
          "dweb:/ipfs/QmeZoogvsEWf688Z849zZ2dLPDnor6YnnNQLMgedY9Tc9D"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@onchainid-v2.2.1/contracts/interface/IIdentity.sol": {
        "keccak256": "0x5ed42ab81b9b734c79e61d1f7e0734baab5479a356ab6bb469414d3c66269862",
        "urls": [
          "bzz-raw://a0863999b1ed334179a43e699e6057815eea011a78ed51e61b6110fc392e26f8",
          "dweb:/ipfs/Qme6hdHZCAy1V4sLgAZ5NxdrEjEf5mYMabf5UDmUDjkuzW"
        ],
        "license": "GPL-3.0"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/IERC20.sol": {
        "keccak256": "0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7",
        "urls": [
          "bzz-raw://df6f0c459663c9858b6cba2cda1d14a7d05a985bed6d2de72bd8e78c25ee79db",
          "dweb:/ipfs/QmeTTxZ7qVk9rjEv2R4CpCwdf8UMCcRqDNMvzNxHc3Fnn9"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "keccak256": "0x70f2f713b13b7ce4610bcd0ac9fec0f3cc43693b043abcb8dc40a42a726eb330",
        "urls": [
          "bzz-raw://c13d13304ac79a83ab1c30168967d19e2203342ebbd6a9bbce4db7550522dcbf",
          "dweb:/ipfs/QmeN5jKMN2vw5bhacr6tkg78afbTTZUeaacNHqjWt4Ew1r"
        ],
        "license": "MIT"
      },
      "dependencies/@openzeppelin-contracts-5.3.0/utils/introspection/IERC165.sol": {
        "keccak256": "0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8",
        "urls": [
          "bzz-raw://f6fda447a62815e8064f47eff0dd1cf58d9207ad69b5d32280f8d7ed1d1e4621",
          "dweb:/ipfs/QmfDRc7pxfaXB2Dh9np5Uf29Na3pQ7tafRS684wd3GLjVL"
        ],
        "license": "MIT"
      }
    },
    "version": 1
  },
  "userdoc": {
    "version": 1,
    "kind": "user",
    "methods": {
      "freezePartialTokens(address,uint256)": {
        "notice": "To freeze tokens for an address, the calling agent must have the capability to freeze tokens enabled. If the agent is disabled from freezing tokens, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from freezing tokens, indicating they do not have the necessary permissions to execute this function."
      },
      "setAddressFrozen(address,bool)": {
        "notice": "To change an address's frozen status, the calling agent must have the capability to freeze addresses enabled. If the agent is disabled from freezing addresses, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from freezing addresses, indicating they do not have the necessary permissions to execute this function."
      },
      "unfreezePartialTokens(address,uint256)": {
        "notice": "To unfreeze tokens for an address, the calling agent must have the capability to unfreeze tokens enabled. If the agent is disabled from unfreezing tokens, the function call will fail. error AgentNotAuthorized - Thrown if the agent is disabled from unfreezing tokens, indicating they do not have the necessary permissions to execute this function."
      }
    }
  },
  "devdoc": {
    "version": 1,
    "kind": "dev",
    "methods": {
      "allowance(address,address)": {
        "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
      },
      "approve(address,uint256)": {
        "details": "Sets a `value` amount of tokens as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
      },
      "balanceOf(address)": {
        "details": "Returns the value of tokens owned by `account`."
      },
      "batchBurn(address[],uint256[])": {
        "details": "Initiates burning of tokens in batch.  Requires that the `_userAddresses` addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
        "params": {
          "_amounts": "The number of tokens to burn from the corresponding wallets.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from burning tokens.  Emits _userAddresses.length `Transfer` events upon successful batch burn.  To execute this function, the calling agent must not be restricted from burning tokens.  If the agent is restricted from this capability, the function call will fail.",
          "_userAddresses": "The addresses of the wallets concerned by the burn."
        }
      },
      "batchForcedTransfer(address[],address[],uint256[])": {
        "details": "Initiates forced transfers in batch.  Requires that each _amounts[i] does not exceed the available balance of _fromList[i].  Requires that the _toList addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF _fromList.length IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
        "params": {
          "_amounts": "The number of tokens to transfer to the corresponding receiver.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from initiating forced transfers in batch.  Emits `TokensUnfrozen` events for each `_amounts[i]` that exceeds the free balance of `_fromList[i]`.  Also emits _fromList.length `Transfer` events upon successful batch transfer.  To execute this function, the calling agent must not be restricted from initiating forced transfer.  If the agent is restricted from this capability, the function call will fail.",
          "_fromList": "The addresses of the senders.",
          "_toList": "The addresses of the receivers."
        }
      },
      "batchFreezePartialTokens(address[],uint256[])": {
        "details": "Initiates partial freezing of tokens in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
        "params": {
          "_amounts": "The amount of tokens to freeze on the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from partially freezing tokens.  Emits _userAddresses.length `TokensFrozen` events upon successful batch partial freezing.  To execute this function, the calling agent must not be restricted from partially freezing tokens.  If the agent is restricted from this capability, the function call will fail.",
          "_userAddresses": "The addresses on which tokens need to be partially frozen."
        }
      },
      "batchMint(address[],uint256[])": {
        "details": "Initiates minting of tokens in batch.  Requires that the `_toList` addresses are all verified and whitelisted addresses.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
        "params": {
          "_amounts": "The number of tokens to mint to the corresponding receiver.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from minting tokens.  Emits _toList.length `Transfer` events upon successful batch minting.  To execute this function, the calling agent must not be restricted from minting tokens.  If the agent is restricted from this capability, the function call will fail.",
          "_toList": "The addresses of the receivers."
        }
      },
      "batchSetAddressFrozen(address[],bool[])": {
        "details": "Initiates setting of frozen status for addresses in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
        "params": {
          "_freeze": "Frozen status of the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from setting frozen addresses.  Emits _userAddresses.length `AddressFrozen` events upon successful batch update of frozen status.  To execute this function, the calling agent must not be restricted from setting frozen addresses.  If the agent is restricted from this capability, the function call will fail.",
          "_userAddresses": "The addresses for which to update frozen status."
        }
      },
      "batchTransfer(address[],uint256[])": {
        "details": "function allowing to issue transfers in batch  Require that the _msgSender() and `to` addresses are not frozen.  Require that the total value should not exceed available balance.  Require that the `to` addresses are all verified addresses,  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION",
        "params": {
          "_amounts": "The number of tokens to transfer to the corresponding receiver  emits _toList.length `Transfer` events",
          "_toList": "The addresses of the receivers"
        }
      },
      "batchUnfreezePartialTokens(address[],uint256[])": {
        "details": "Initiates partial unfreezing of tokens in batch.  IMPORTANT: THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH.  USE WITH CARE TO AVOID \"OUT OF GAS\" TRANSACTIONS AND POTENTIAL LOSS OF TX FEES.",
        "params": {
          "_amounts": "The amount of tokens to unfreeze on the corresponding address.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from partially freezing tokens.  Emits _userAddresses.length `TokensUnfrozen` events upon successful batch partial unfreezing.  To execute this function, the calling agent must not be restricted from partially freezing tokens.  If the agent is restricted from this capability, the function call will fail.",
          "_userAddresses": "The addresses on which tokens need to be partially unfrozen."
        }
      },
      "burn(address,uint256)": {
        "details": "Burns tokens from a specified address.  If the account address does not have sufficient free tokens (unfrozen tokens)  but possesses a total balance equal to or greater than the specified value,  the frozen token amount is reduced to ensure enough free tokens for the burn.  In such cases, the remaining balance in the account consists entirely of frozen tokens post-transaction.",
        "params": {
          "_amount": "Amount of tokens to burn.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from burning tokens.  Emits a `TokensUnfrozen` event if `_amount` exceeds the free balance of `_userAddress`.  Also emits a `Transfer` event.  To execute this function, the calling agent must not be restricted from burning tokens.  If the agent is restricted from this capability, the function call will fail.",
          "_userAddress": "Address to burn the tokens from."
        }
      },
      "compliance()": {
        "details": "Returns the Compliance contract linked to the token"
      },
      "decimals()": {
        "details": "Returns the decimals places of the token."
      },
      "forcedTransfer(address,address,uint256)": {
        "details": "Initiates a forced transfer of tokens between two whitelisted wallets.  If the `from` address does not have sufficient free tokens (unfrozen tokens)  but possesses a total balance equal to or greater than the specified `amount`,  the frozen token amount is reduced to ensure enough free tokens for the transfer.  In such cases, the remaining balance in the `from` account consists entirely of frozen tokens post-transfer.  It is imperative that the `to` address is a verified and whitelisted address.",
        "params": {
          "_amount": "The number of tokens to be transferred.  This function can only be invoked by a wallet designated as an agent of the token,  provided the agent is not restricted from initiating forced transfers of the token.  Emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_from`.  Also emits a `Transfer` event.  To execute this function, the calling agent must not be restricted from initiating forced transfers of the token.  If the agent is restricted from this capability, the function call will fail.  The function can only be called when the contract is not already paused.  error `AgentNotAuthorized` - Thrown if the agent is restricted from initiating forced transfers of the token,  indicating they do not have the necessary permissions to execute this function.",
          "_from": "The address of the sender.",
          "_to": "The address of the receiver."
        }
      },
      "freezePartialTokens(address,uint256)": {
        "details": "Freezes a specified token amount for a given address, preventing those tokens from being transferred. This function can be called by an agent of the token, provided the agent is not restricted from freezing tokens. emits a `TokensFrozen` event upon successful execution.",
        "params": {
          "_amount": "The amount of tokens to be frozen.",
          "_userAddress": "The address for which to freeze tokens."
        }
      },
      "getFrozenTokens(address)": {
        "details": "Returns the amount of tokens that are partially frozen on a wallet  the amount of frozen tokens is always <= to the total balance of the wallet",
        "params": {
          "_userAddress": "the address of the wallet on which getFrozenTokens is called"
        }
      },
      "identityRegistry()": {
        "details": "Returns the Identity Registry linked to the token"
      },
      "isFrozen(address)": {
        "details": "Returns the freezing status of a wallet  if isFrozen returns `true` the wallet is frozen  if isFrozen returns `false` the wallet is not frozen  isFrozen returning `true` doesn't mean that the balance is free, tokens could be blocked by  a partial freeze or the whole token could be blocked by pause",
        "params": {
          "_userAddress": "the address of the wallet on which isFrozen is called"
        }
      },
      "mint(address,uint256)": {
        "details": "Mints tokens to a specified address.  This enhanced version of the default mint method allows tokens to be minted  to an address only if it is a verified and whitelisted address according to the security token.",
        "params": {
          "_amount": "Amount of tokens to mint.  This function can only be called by a wallet designated as an agent of the token,  provided the agent is not restricted from minting tokens.  Emits a `Transfer` event upon successful minting.  To execute this function, the calling agent must not be restricted from minting tokens.  If the agent is restricted from this capability, the function call will fail.",
          "_to": "Address to mint the tokens to."
        }
      },
      "name()": {
        "details": "Returns the name of the token."
      },
      "onchainID()": {
        "details": "Returns the address of the onchainID of the token. the onchainID of the token gives all the information available about the token and is managed by the token issuer or his agent."
      },
      "pause()": {
        "details": "Pauses the token contract. When the contract is paused, investors cannot transfer tokens anymore. This function can only be called by an agent of the token, provided the agent is not restricted from pausing the token. emits a `Paused` event upon successful execution. To pause token transfers, the calling agent must have pausing capabilities enabled. If the agent is disabled from pausing, the function call will fail. The function can be called only when the contract is not already paused. error AgentNotAuthorized - Thrown if the agent is disabled from pausing the token, indicating they do not have the necessary permissions to execute this function."
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "recoveryAddress(address,address,address)": {
        "details": "Initiates a recovery process to transfer tokens and associated states from a lost wallet to a new wallet for an investor. This function allows an authorized agent to recover tokens from a lost wallet, transferring them to a new wallet while preserving the investor's identity and status within the token ecosystem. The function ensures that all relevant data, including frozen tokens and address freezing status, is accurately transferred to the new wallet.",
        "params": {
          "_investorOnchainID": "The ONCHAINID of the investor whose tokens are being recovered. Requirements: - The caller must be an agent authorized to perform recovery operations, with no restrictions on this capability. - The `_lostWallet` must have a non-zero token balance; otherwise, the recovery is unnecessary and will revert. - Either the `_lostWallet` or the `_newWallet` must be present in the identity registry;   if neither is present, the function will revert. Operations: - Transfers the entire token balance from `_lostWallet` to `_newWallet`. - Transfers any frozen tokens from `_lostWallet` to `_newWallet`, updating the frozen token count accordingly. - Transfers the address freeze status from `_lostWallet` to `_newWallet`,   ensuring the new wallet retains any restrictions if applicable. - Updates the identity registry:   - If `_lostWallet` is listed in the identity registry, it will be removed,     and `_newWallet` will be registered unless already present. Emits the following events: - `TokensUnfrozen` if there are frozen tokens on `_lostWallet` that are transferred. - `TokensFrozen` if frozen tokens are added to `_newWallet`. - `AddressFrozen` if the freeze status of either wallet changes. - `Transfer` to reflect the movement of tokens from `_lostWallet` to `_newWallet`. - `RecoverySuccess` upon successful completion of the recovery process. Reverts if: - The agent calling the function does not have the necessary permissions to perform recovery (`AgentNotAuthorized`). - The `_lostWallet` has no tokens to recover (`NoTokenToRecover`). - Neither `_lostWallet` nor `_newWallet` is present in the identity registry (`RecoveryNotPossible`).",
          "_lostWallet": "The wallet that the investor lost, containing the tokens to be recovered.",
          "_newWallet": "The newly provided wallet to which tokens and associated statuses must be transferred."
        },
        "returns": {
          "_0": "A boolean value indicating whether the recovery process was successful."
        }
      },
      "setAddressFrozen(address,bool)": {
        "details": "Sets an address's frozen status for this token, either freezing or unfreezing the address based on the provided boolean value. This function can be called by an agent of the token, assuming the agent is not restricted from freezing addresses. emits an `AddressFrozen` event upon successful execution.",
        "params": {
          "_freeze": "The frozen status to be applied: `true` to freeze, `false` to unfreeze.",
          "_userAddress": "The address for which to update the frozen status."
        }
      },
      "setCompliance(address)": {
        "details": "sets the compliance contract of the token",
        "params": {
          "_compliance": "the address of the compliance contract to set  Only the owner of the token smart contract can call this function  calls bindToken on the compliance contract  emits a `ComplianceAdded` event"
        }
      },
      "setIdentityRegistry(address)": {
        "details": "sets the Identity Registry for the token",
        "params": {
          "_identityRegistry": "the address of the Identity Registry to set  Only the owner of the token smart contract can call this function  emits an `IdentityRegistryAdded` event"
        }
      },
      "setName(string)": {
        "details": "sets the token name",
        "params": {
          "_name": "the name of token to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event"
        }
      },
      "setOnchainID(address)": {
        "details": "sets the onchain ID of the token",
        "params": {
          "_onchainID": "the address of the onchain ID to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event"
        }
      },
      "setSymbol(string)": {
        "details": "sets the token symbol",
        "params": {
          "_symbol": "the token symbol to set  Only the owner of the token smart contract can call this function  emits a `UpdatedTokenInformation` event"
        }
      },
      "symbol()": {
        "details": "Returns the symbol of the token."
      },
      "totalSupply()": {
        "details": "Returns the value of tokens in existence."
      },
      "transfer(address,uint256)": {
        "details": "Moves a `value` amount of tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
      },
      "transferFrom(address,address,uint256)": {
        "details": "Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism. `value` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."
      },
      "unfreezePartialTokens(address,uint256)": {
        "details": "Unfreezes a specified token amount for a given address, allowing those tokens to be transferred again. This function can be called by an agent of the token, assuming the agent is not restricted from unfreezing tokens. emits a `TokensUnfrozen` event upon successful execution.",
        "params": {
          "_amount": "The amount of tokens to be unfrozen.",
          "_userAddress": "The address for which to unfreeze tokens."
        }
      },
      "unpause()": {
        "details": "Unpauses the token contract, allowing investors to resume token transfers under normal conditions This function can only be called by an agent of the token, provided the agent is not restricted from pausing the token. emits an `Unpaused` event upon successful execution. To unpause token transfers, the calling agent must have pausing capabilities enabled. If the agent is disabled from pausing, the function call will fail. The function can be called only when the contract is currently paused. error AgentNotAuthorized - Thrown if the agent is disabled from pausing the token, indicating they do not have the necessary permissions to execute this function."
      },
      "version()": {
        "details": "Returns the TREX version of the token."
      }
    },
    "events": {
      "Approval(address,address,uint256)": {
        "details": "Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."
      }
    }
  },
  "id": 120
}