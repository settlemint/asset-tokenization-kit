# --------------------------------------------------
# Grouping Contracts by Contract Type
# --------------------------------------------------

interface Asset {
  id: Bytes!
  type: String!
  asAccount: Account!
  holders: [AssetBalance!]! @derivedFrom(field: "asset")
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
  lastActivity: BigInt!
  creator: Account!
  totalBurned: BigDecimal!
  totalBurnedExact: BigInt!
  totalHolders: Int!
  # Access Control
  admins: [Account!]!
  supplyManagers: [Account!]!
  userManagers: [Account!]!
  blocklist: [BlockedUser!]! @derivedFrom(field: "asset")
  allowlist: [AllowedUser!]! @derivedFrom(field: "asset")
  deployedOn: BigInt!
  # Concentration
  concentration: BigDecimal!
}

type Factory @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
}

# --------------------------------------------------
# Assets
# --------------------------------------------------

type Bond implements Asset @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
  holders: [AssetBalance!]! @derivedFrom(field: "asset")
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
  lastActivity: BigInt!
  creator: Account!
  totalBurned: BigDecimal!
  totalBurnedExact: BigInt!
  totalHolders: Int!
  deployedOn: BigInt!
  # Access Control
  admins: [Account!]!
  supplyManagers: [Account!]!
  userManagers: [Account!]!
  blocklist: [BlockedUser!]! @derivedFrom(field: "asset")
  allowlist: [AllowedUser!]! @derivedFrom(field: "asset")
  # Concentration
  concentration: BigDecimal!
  # Bond-Specific Fields
  cap: BigDecimal!
  capExact: BigInt!
  maturityDate: BigInt!
  isMatured: Boolean!
  paused: Boolean!
  faceValue: BigInt!
  underlyingAsset: Asset!
  underlyingAssetDecimals: Int! # Storing decimals directly to avoid having to always query the underlying asset
  redeemedAmount: BigInt!
  underlyingBalance: BigDecimal!
  underlyingBalanceExact: BigInt!
  yieldSchedule: FixedYield
  totalUnderlyingNeeded: BigDecimal!
  totalUnderlyingNeededExact: BigInt!
  hasSufficientUnderlying: Boolean!
}

type Equity implements Asset @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
  holders: [AssetBalance!]! @derivedFrom(field: "asset")
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
  lastActivity: BigInt!
  creator: Account!
  totalBurned: BigDecimal!
  totalBurnedExact: BigInt!
  totalHolders: Int!
  deployedOn: BigInt!
  # Access Control
  admins: [Account!]!
  supplyManagers: [Account!]!
  userManagers: [Account!]!
  blocklist: [BlockedUser!]! @derivedFrom(field: "asset")
  allowlist: [AllowedUser!]! @derivedFrom(field: "asset")
  # Concentration
  concentration: BigDecimal!
  # Equity-Specific Fields
  equityClass: String!
  equityCategory: String!
  paused: Boolean!
}

type Fund implements Asset @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
  holders: [AssetBalance!]! @derivedFrom(field: "asset")
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
  lastActivity: BigInt!
  creator: Account!
  totalBurned: BigDecimal!
  totalBurnedExact: BigInt!
  totalHolders: Int!
  deployedOn: BigInt!
  # Access Control
  admins: [Account!]!
  supplyManagers: [Account!]!
  userManagers: [Account!]!
  blocklist: [BlockedUser!]! @derivedFrom(field: "asset")
  allowlist: [AllowedUser!]! @derivedFrom(field: "asset")
  # Concentration
  concentration: BigDecimal!
  # Fund-Specific Fields
  fundClass: String!
  fundCategory: String!
  paused: Boolean!
  managementFeeBps: Int!
  lastFeeCollection: BigInt!
}

type StableCoin implements Asset @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
  holders: [AssetBalance!]! @derivedFrom(field: "asset")
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
  lastActivity: BigInt!
  creator: Account!
  totalBurned: BigDecimal!
  totalBurnedExact: BigInt!
  totalHolders: Int!
  deployedOn: BigInt!
  # Access Control
  admins: [Account!]!
  supplyManagers: [Account!]!
  userManagers: [Account!]!
  auditors: [Account!]!
  blocklist: [BlockedUser!]! @derivedFrom(field: "asset")
  allowlist: [AllowedUser!]! @derivedFrom(field: "asset")
  # Concentration
  concentration: BigDecimal!
  # StableCoin-Specific Fields
  collateral: BigDecimal!
  collateralExact: BigInt!
  collateralRatio: BigDecimal!
  freeCollateral: BigDecimal!
  freeCollateralExact: BigInt!
  liveness: BigInt!
  lastCollateralUpdate: BigInt!
  paused: Boolean!
}

type CryptoCurrency implements Asset @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
  holders: [AssetBalance!]! @derivedFrom(field: "asset")
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
  lastActivity: BigInt!
  creator: Account!
  totalBurned: BigDecimal!
  totalBurnedExact: BigInt!
  totalHolders: Int!
  deployedOn: BigInt!
  # Access Control
  admins: [Account!]!
  supplyManagers: [Account!]!
  userManagers: [Account!]!
  blocklist: [BlockedUser!]! @derivedFrom(field: "asset")
  allowlist: [AllowedUser!]! @derivedFrom(field: "asset")
  # Concentration
  concentration: BigDecimal!
  # CryptoCurrency-Specific Fields
}

type Deposit implements Asset @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
  holders: [AssetBalance!]! @derivedFrom(field: "asset")
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
  lastActivity: BigInt!
  creator: Account!
  totalBurned: BigDecimal!
  totalBurnedExact: BigInt!
  totalHolders: Int!
  deployedOn: BigInt!
  # Access Control
  admins: [Account!]!
  supplyManagers: [Account!]!
  userManagers: [Account!]!
  auditors: [Account!]!
  blocklist: [BlockedUser!]! @derivedFrom(field: "asset")
  allowlist: [AllowedUser!]! @derivedFrom(field: "asset")
  # Concentration
  concentration: BigDecimal!
  # Deposit-Specific Fields
  paused: Boolean!
  # Collateral Fields
  collateral: BigDecimal!
  collateralExact: BigInt!
  collateralRatio: BigDecimal!
  freeCollateral: BigDecimal!
  freeCollateralExact: BigInt!
  liveness: BigInt!
  lastCollateralUpdate: BigInt!
}

# --------------------------------------------------
# DvPSwap Contract
# --------------------------------------------------

type DvPSwap @entity(immutable: false) {
  id: Bytes!
  creator: Account!
  createdAt: BigInt!
  active: Boolean!
  dvpSwapCount: Int!
  totalValueLocked: BigDecimal!
  totalValueLockedExact: BigInt!
}

# --------------------------------------------------
# DvPSwap Factory
# --------------------------------------------------

type DvPSwapFactory @entity(immutable: false) {
  id: Bytes!
  type: String!
  asAccount: Account!
  dvpSwapContractsCount: Int!
}

type DvPSwapEntity @entity(immutable: false) {
  id: Bytes!
  contract: DvPSwap!
  factory: Factory
  creator: Account!
  sender: Account!
  receiver: Account!
  tokenToSend: Bytes!
  tokenToReceive: Bytes!
  amountToSend: BigDecimal!
  amountToSendExact: BigInt!
  amountToReceive: BigDecimal!
  amountToReceiveExact: BigInt!
  timelock: BigInt!
  hashlock: Bytes!
  status: String!
  createdAt: BigInt!
  maxDuration: BigInt!
  updatedAt: BigInt!
}

# --------------------------------------------------
# Accounts
# --------------------------------------------------

type Account @entity(immutable: false) {
  id: Bytes!
  isContract: Boolean!
  asAsset: Asset
  balancesCount: Int!
  totalBalanceExact: BigInt!
  totalBalance: BigDecimal!
  pausedBalancesCount: Int!
  pausedBalanceExact: BigInt!
  pausedBalance: BigDecimal!
  balances: [AssetBalance!]! @derivedFrom(field: "account")
  nativeBalance: BigDecimal!
  nativeBalanceExact: BigInt!
  lastActivity: BigInt!
  activityEvents: [AccountActivityEvent!]! @derivedFrom(field: "account")
  activityEventsCount: Int!
}

type AssetBalance @entity(immutable: false) {
  id: Bytes!
  asset: Asset!
  account: Account!
  value: BigDecimal!
  valueExact: BigInt!
  approved: BigDecimal!
  approvedExact: BigInt!
  blocked: Boolean!
  frozen: BigDecimal!
  frozenExact: BigInt!
  lastActivity: BigInt!
}

# --------------------------------------------------
# Yields
# --------------------------------------------------

type FixedYield @entity(immutable: false) {
  id: Bytes!
  token: Asset!
  underlyingAsset: Asset! # The underlying asset used for yield payments
  underlyingAssetDecimals: Int! # Storing decimals directly to avoid having to always query the underlying asset
  startDate: BigInt!
  endDate: BigInt!
  rate: BigInt!
  interval: BigInt!
  periods: [YieldPeriod!]! @derivedFrom(field: "schedule")
  totalClaimed: BigDecimal!
  totalClaimedExact: BigInt!
  underlyingBalance: BigDecimal!
  underlyingBalanceExact: BigInt!
  yieldForNextPeriod: BigDecimal!
  yieldForNextPeriodExact: BigInt!
}

type YieldPeriod @entity(immutable: false) {
  id: Bytes!
  schedule: FixedYield!
  periodId: BigInt!
  startDate: BigInt!
  endDate: BigInt!
  totalClaimed: BigDecimal!
  totalClaimedExact: BigInt!
  totalYield: BigDecimal!
  totalYieldExact: BigInt!
}

# --------------------------------------------------
# Grouping Events by Contract Type
# --------------------------------------------------

interface AssetEvent {
  id: Bytes! # Unique identifier for the event
  eventName: String! # Name of the event
  timestamp: BigInt! # Timestamp of the event
  emitter: Asset! # The contract that emitted the event
  sender: Account! # The account that sent the transaction
  assetType: String! # The type of asset that was affected
}

# --------------------------------------------------
# Activity Events
# --------------------------------------------------

type AccountActivityEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  assetType: String!
  timestamp: BigInt!
  asset: Asset
  account: Account!
}

# --------------------------------------------------
# Common Events for All Tokens (StableCoin, Fund, Equity, CryptoCurrency, Bond)
# --------------------------------------------------

"""
Entity for ERC20 Transfer events.
Emitted on every token transfer (excluding minting and burning).
"""
type TransferEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  from: Account! # Sender address
  to: Account! # Recipient address
  value: BigDecimal! # Amount transferred
  valueExact: BigInt! # Amount transferred in exact precision
}

"""
Entity for ERC20 Mint events.
Emitted on every token mint (transfer from zero address).
"""
type MintEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  to: Account! # Recipient address
  value: BigDecimal! # Amount transferred
  valueExact: BigInt! # Amount transferred in exact precision
}

"""
Entity for ERC20 Burn events.
Emitted on every token burn (transfer to zero address).
"""
type BurnEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  from: Account!
  value: BigDecimal! # Amount transferred
  valueExact: BigInt! # Amount transferred in exact precision
}

"""
Entity for ERC20 Approval events.
Emitted when an approval is set for a spender.
"""
type ApprovalEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  owner: Account! # Token owner
  spender: Account! # Approved spender
  value: BigDecimal! # Approved amount
  valueExact: BigInt! # Approved amount in exact precision
}

"""
Entity for pause events.
Emitted when a token is paused.
"""
type PausedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
}

"""
Entity for unpause events.
Emitted when a token is unpaused.
"""
type UnpausedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
}

"""
Entity for tokens frozen events.
Emitted when tokens are frozen (a custodian operation).
"""
type TokensFrozenEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  user: Account! # The user whose tokens were frozen
  amount: BigDecimal! # The amount frozen
  amountExact: BigInt! # The amount frozen in exact precision
}

"""
Entity for role granted events.
Emitted when a role is granted.
"""
type RoleGrantedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  role: Bytes! # Role identifier (e.g. SUPPLY_MANAGEMENT_ROLE)
  account: Account! # The account that received the role
}

"""
Entity for role revoked events.
Emitted when a role is revoked.
"""
type RoleRevokedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  role: Bytes!
  account: Account! # The account that lost the role
}

"""
Entity for role admin changed events.
Emitted when a role's admin role is changed.
"""
type RoleAdminChangedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  role: Bytes! # The role being modified
  previousAdminRole: Bytes! # The old admin role
  newAdminRole: Bytes! # The new admin role
}

"""
Entity for blocklist events.
Emitted when a user is blocked from token operations.
"""
type UserBlockedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  user: Account! # The blocked user's address
}

"""
Entity for blocklist events.
Emitted when a user is unblocked from token operations.
"""
type UserUnblockedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  user: Account! # The unblocked user's address
}

"""
Entity for allowlist events.
Emitted when a user is allowed for token operations.
"""
type UserAllowedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  user: Account! # The allowed user's address
}

"""
Entity for allowlist events.
Emitted when a user is disallowed from token operations.
"""
type UserDisallowedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  user: Account! # The disallowed user's address
}

"""
Entity for blocklist events.
Emitted when a user is unblocked from token operations.
"""
type AssetCreatedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
}

"""
Entity for clawback events.
Emitted when tokens are forcibly transferred from one address to another.
"""
type ClawbackEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  from: Account! # The address tokens are taken from
  to: Account! # The address tokens are sent to
  amount: BigDecimal! # The amount of tokens transferred
  amountExact: BigInt! # The amount of tokens transferred in exact precision
}

# --------------------------------------------------
# StableCoin-Specific Custom Event
# --------------------------------------------------

"""
Entity for collateral update events in StableCoin.
Emitted when the collateral is updated via updateCollateral.
"""
type CollateralUpdatedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  oldAmount: BigDecimal! # Previous collateral amount
  oldAmountExact: BigInt! # Previous collateral amount in exact precision
  newAmount: BigDecimal! # New collateral amount
  newAmountExact: BigInt! # New collateral amount in exact precision
}

# --------------------------------------------------
# Fund-Specific Custom Events
# --------------------------------------------------

"""
Entity for management fee collection events in Fund.
Emitted when the management fee is collected.
"""
type ManagementFeeCollectedEvent implements AssetEvent
  @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  amount: BigDecimal! # Fee amount collected
  amountExact: BigInt! # Fee amount collected in exact precision
}

"""
Entity for performance fee collection events in Fund.
Emitted when the performance fee is collected.
"""
type PerformanceFeeCollectedEvent implements AssetEvent
  @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  amount: BigDecimal! # Fee amount collected
  amountExact: BigInt! # Fee amount collected in exact precision
}

"""
Entity for token withdrawal events in Fund.
Emitted when tokens are withdrawn from the fund.
"""
type TokenWithdrawnEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  token: Asset!
  to: Account! # Recipient address
  amount: BigDecimal! # Amount withdrawn
  amountExact: BigInt! # Amount withdrawn in exact precision
}

# --------------------------------------------------
# CryptoCurrency-Specific Custom Events
# --------------------------------------------------

# --------------------------------------------------
# Equity-Specific Custom Events
# --------------------------------------------------

# --------------------------------------------------
# Bond-Specific Custom Events
# --------------------------------------------------

"""
Entity for bond maturity events.
Emitted when the bond reaches maturity and is closed.
"""
type BondMaturedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
}

"""
Entity for bond redemption events.
Emitted when a bond is redeemed for underlying assets.
"""
type BondRedeemedEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  holder: Account! # The address redeeming the bond
  bondAmount: BigDecimal! # The number of bonds redeemed
  bondAmountExact: BigInt! # The number of bonds redeemed in exact precision
  underlyingAmount: BigDecimal! # The amount of underlying assets received
  underlyingAmountExact: BigInt! # The amount of underlying assets received in exact precision
}

# --------------------------------------------------
# Bond/Yield-Specific Custom Events
# --------------------------------------------------

"""
Entity for underlying asset top-up events.
Emitted when underlying assets are added (topped up) to the Bond contract.
"""
type UnderlyingAssetTopUpEvent implements AssetEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  from: Account! # The address providing the top-up
  amount: BigDecimal! # The amount of underlying assets added
  amountExact: BigInt! # The amount of underlying assets added in exact precision
}

"""
Entity for underlying asset withdrawal events.
Emitted when underlying assets are withdrawn from the Bond contract.
"""
type UnderlyingAssetWithdrawnEvent implements AssetEvent
  @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  assetType: String!
  to: Account! # The recipient address for the withdrawn assets
  amount: BigDecimal! # The amount withdrawn
  amountExact: BigInt! # The amount withdrawn in exact precision
}

# --------------------------------------------------
# FixedYield-Specific Custom Event
# --------------------------------------------------

type FixedYieldCreatedEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Factory!
  sender: Account!
  fixedYield: FixedYield!
}

"""
Entity for yield claimed events in FixedYield.
Emitted when yield is claimed.
"""
type YieldClaimedEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  emitter: Asset!
  sender: Account!
  holder: Account! # The address claiming the yield
  totalAmount: BigDecimal! # The total yield claimed
  totalAmountExact: BigInt! # The total yield claimed in exact precision
  fromPeriod: BigInt! # The first period being claimed
  toPeriod: BigInt! # The last period being claimed
  periodAmounts: [BigInt!]! # Array of yield amounts claimed for each period
  unclaimedYield: BigDecimal! # Total unclaimed yield remaining after this claim
  unclaimedYieldExact: BigInt! # Total unclaimed yield remaining after this claim in exact precision
}

# --------------------------------------------------
# DvPSwap-Specific Events
# --------------------------------------------------

"""
Entity for DvP Swap contract creation events.
Emitted when a new DvP Swap contract is deployed via the factory.
"""
type DvPSwapContractCreatedEvent @entity(immutable: true) {
  id: String!
  eventName: String!
  timestamp: BigInt!
  factory: Bytes!
  sender: Bytes!
  dvpSwapContract: Bytes!
  creator: Bytes!
}

"""
Entity for DvP Swap creation events.
Emitted when a new atomic swap is created.
"""
type DvPSwapCreatedEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  contract: DvPSwap!
  sender: Account!
  swap: DvPSwapEntity!
  receiver: Account!
  tokenToSend: Bytes!
  tokenToReceive: Bytes!
  amountToSend: BigDecimal!
  amountToSendExact: BigInt!
  amountToReceive: BigDecimal!
  amountToReceiveExact: BigInt!
  timelock: BigInt!
  hashlock: Bytes!
}

"""
Entity for DvP Swap status change events.
Emitted when a swap's status changes.
"""
type DvPSwapStatusChangedEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  contract: DvPSwap!
  sender: Account!
  swap: DvPSwapEntity!
  status: String!
}

"""
Entity for DvP Swap claim events.
Emitted when tokens are claimed from a swap.
"""
type DvPSwapClaimedEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  contract: DvPSwap!
  sender: Account!
  swap: DvPSwapEntity!
  receiver: Account!
  secret: Bytes!
}

"""
Entity for DvP Swap refund events.
Emitted when a swap is refunded.
"""
type DvPSwapRefundedEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  contract: DvPSwap!
  sender: Account!
  swap: DvPSwapEntity!
  refundedTo: Account!
}

"""
Entity for token locking events in DvP Swap.
Emitted when tokens are locked in a swap contract.
"""
type TokensLockedEvent @entity(immutable: true) {
  id: Bytes!
  eventName: String!
  timestamp: BigInt!
  contract: DvPSwap!
  sender: Account!
  swap: DvPSwapEntity!
  tokenAddress: Bytes!
  amount: BigDecimal!
  amountExact: BigInt!
  lockTimestamp: BigInt!
}

# --------------------------------------------------
# Asset Statistics
# --------------------------------------------------

type AssetStatsData @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  ## Filters
  asset: Asset!
  assetType: String!
  assetCategory: String!
  assetClass: String!
  ## Transfers
  transfers: Int!
  volume: BigDecimal!
  volumeExact: BigInt!
  ## Supply
  supply: BigDecimal!
  supplyExact: BigInt!
  minted: BigDecimal!
  mintedExact: BigInt!
  burned: BigDecimal!
  burnedExact: BigInt!
  ## Frozen
  locked: BigDecimal!
  lockedExact: BigInt!
  frozen: BigDecimal!
  frozenExact: BigInt!
  unfrozen: BigDecimal!
  unfrozenExact: BigInt!
  ## Collateral
  collateral: BigDecimal!
  collateralExact: BigInt!
  collateralRatio: BigDecimal!
  freeCollateral: BigDecimal!
  freeCollateralExact: BigInt!
}

type AssetStats
  @aggregation(intervals: ["hour", "day"], source: "AssetStatsData") {
  id: Int8!
  timestamp: Timestamp!
  ## Filters
  asset: Asset!
  assetType: String!
  assetCategory: String!
  assetClass: String!
  ## Amounts
  count: Int8! @aggregate(fn: "count", cumulative: true)
  ## Transfers
  totalTransfers: Int! @aggregate(fn: "sum", arg: "transfers")
  totalVolume: BigDecimal! @aggregate(fn: "sum", arg: "volume")
  totalVolumeExact: BigInt! @aggregate(fn: "sum", arg: "volumeExact")
  ## Supply
  totalSupply: BigDecimal! @aggregate(fn: "last", arg: "supply")
  totalSupplyExact: BigInt! @aggregate(fn: "last", arg: "supplyExact")
  totalMinted: BigDecimal! @aggregate(fn: "sum", arg: "minted")
  totalMintedExact: BigInt! @aggregate(fn: "sum", arg: "mintedExact")
  totalBurned: BigDecimal! @aggregate(fn: "sum", arg: "burned")
  totalBurnedExact: BigInt! @aggregate(fn: "sum", arg: "burnedExact")
  ## Frozen
  totalLocked: BigDecimal! @aggregate(fn: "last", arg: "locked")
  totalLockedExact: BigInt! @aggregate(fn: "last", arg: "lockedExact")
  totalFrozen: BigDecimal! @aggregate(fn: "sum", arg: "frozen")
  totalFrozenExact: BigInt! @aggregate(fn: "sum", arg: "frozenExact")
  totalUnfrozen: BigDecimal! @aggregate(fn: "sum", arg: "unfrozen")
  totalUnfrozenExact: BigInt! @aggregate(fn: "sum", arg: "unfrozenExact")
  ## Collateral
  totalCollateral: BigDecimal! @aggregate(fn: "last", arg: "collateral")
  totalCollateralExact: BigInt! @aggregate(fn: "last", arg: "collateralExact")
}

# --------------------------------------------------
# DvPSwap Statistics
# --------------------------------------------------

type DvPSwapStatsData @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  ## Filters
  dvpSwap: DvPSwap!
  ## Activity
  dvpSwapsCreated: Int!
  dvpSwapsClaimed: Int!
  dvpSwapsRefunded: Int!
  dvpSwapsExpired: Int!
  dvpSwapsFailed: Int!
  ## Value
  valueLocked: BigDecimal!
  valueLockedExact: BigInt!
  valueUnlocked: BigDecimal!
  valueUnlockedExact: BigInt!
}

type DvPSwapStats
  @aggregation(intervals: ["hour", "day"], source: "DvPSwapStatsData") {
  id: Int8!
  timestamp: Timestamp!
  ## Filters
  dvpSwap: DvPSwap!
  ## Activity
  count: Int8! @aggregate(fn: "count", cumulative: true)
  totalDvpSwapsCreated: Int! @aggregate(fn: "sum", arg: "dvpSwapsCreated")
  totalDvpSwapsClaimed: Int! @aggregate(fn: "sum", arg: "dvpSwapsClaimed")
  totalDvpSwapsRefunded: Int! @aggregate(fn: "sum", arg: "dvpSwapsRefunded")
  totalDvpSwapsExpired: Int! @aggregate(fn: "sum", arg: "dvpSwapsExpired")
  totalDvpSwapsFailed: Int! @aggregate(fn: "sum", arg: "dvpSwapsFailed")
  ## Value
  totalValueLocked: BigDecimal! @aggregate(fn: "last", arg: "valueLocked")
  totalValueLockedExact: BigInt! @aggregate(fn: "last", arg: "valueLockedExact")
  totalValueUnlocked: BigDecimal! @aggregate(fn: "sum", arg: "valueUnlocked")
  totalValueUnlockedExact: BigInt!
    @aggregate(fn: "sum", arg: "valueUnlockedExact")
}

# --------------------------------------------------
# Asset Activity
# --------------------------------------------------

type AssetActivityData @entity(immutable: false) {
  id: String!
  assetType: String! @unique

  ## Activity
  transferEventCount: Int!
  mintEventCount: Int!
  burnEventCount: Int!
  frozenEventCount: Int!
  unfrozenEventCount: Int!
  clawbackEventCount: Int!

  ## Supply
  totalSupply: BigDecimal!
  totalSupplyExact: BigInt!
}

# --------------------------------------------------
# Asset count
# --------------------------------------------------

type AssetCount @entity(immutable: false) {
  id: String!
  assetType: String! @unique
  count: Int!
  countPaused: Int!
}

# --------------------------------------------------
# Portfolio Statistics
# --------------------------------------------------

type PortfolioStatsData @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  ## Filters
  account: Account!
  assetType: String!
  asset: Asset!
  ## Balances
  balance: BigDecimal!
  balanceExact: BigInt!
  ## Frozen
  locked: BigDecimal!
  lockedExact: BigInt!
}

type PortfolioStats
  @aggregation(intervals: ["hour", "day"], source: "PortfolioStatsData") {
  id: Int8!
  timestamp: Timestamp!
  ## Filters
  account: Account!
  asset: Asset!
  assetType: String!
  ## Balances
  totalBalance: BigDecimal! @aggregate(fn: "last", arg: "balance")
  totalBalanceExact: BigInt! @aggregate(fn: "last", arg: "balanceExact")
  ## Frozen
  totalLocked: BigDecimal! @aggregate(fn: "last", arg: "locked")
  totalLockedExact: BigInt! @aggregate(fn: "last", arg: "lockedExact")
}

# --------------------------------------------------
# Blocked and Allowed Users
# --------------------------------------------------

type BlockedUser @entity(immutable: false) {
  id: Bytes!
  asset: Asset!
  user: Account!
  blockedAt: BigInt!
}

type AllowedUser @entity(immutable: false) {
  id: Bytes!
  asset: Asset!
  user: Account!
  allowedAt: BigInt!
}

# --------------------------------------------------
# Airdrop Contracts
# --------------------------------------------------

type AirdropFactory @entity(immutable: false) {
  id: Bytes! # Contract address
  airdrops: [Airdrop!]! @derivedFrom(field: "factory")
  totalAirdropsDeployed: Int!
}

interface Airdrop {
  id: Bytes! # Contract address
  factory: AirdropFactory!
  token: Bytes! # Changed from Asset! to Bytes!
  merkleRoot: Bytes!
  owner: Account!
  deployedOn: BigInt!
  deploymentTx: Bytes!
  totalClaimed: BigDecimal!
  totalClaimedExact: BigInt!
  totalRecipients: Int! # Count of unique addresses that have claimed
  totalClaims: Int! # Count of claim events
  isWithdrawn: Boolean!
  trustedForwarder: Account!
  claims: [AirdropClaim!]! @derivedFrom(field: "airdrop")
}

type StandardAirdrop implements Airdrop @entity(immutable: false) {
  id: Bytes! # Contract address
  factory: AirdropFactory!
  token: Bytes! # Matches interface
  merkleRoot: Bytes!
  owner: Account!
  deployedOn: BigInt!
  deploymentTx: Bytes!
  totalClaimed: BigDecimal!
  totalClaimedExact: BigInt!
  totalRecipients: Int!
  totalClaims: Int!
  isWithdrawn: Boolean!
  trustedForwarder: Account!
  claims: [AirdropClaim!]! @derivedFrom(field: "airdrop")
  # Standard specific
  startTime: BigInt!
  endTime: BigInt!
}

type VestingAirdrop implements Airdrop @entity(immutable: false) {
  id: Bytes! # Contract address
  factory: AirdropFactory!
  token: Bytes! # Matches interface
  merkleRoot: Bytes!
  owner: Account!
  deployedOn: BigInt!
  deploymentTx: Bytes!
  totalClaimed: BigDecimal!
  totalClaimedExact: BigInt!
  totalRecipients: Int!
  totalClaims: Int!
  isWithdrawn: Boolean!
  trustedForwarder: Account!
  claims: [AirdropClaim!]! @derivedFrom(field: "airdrop")
  # Vesting specific
  claimPeriodEnd: BigInt!
  strategy: VestingStrategy!
}

type PushAirdrop implements Airdrop @entity(immutable: false) {
  id: Bytes! # Contract address
  factory: AirdropFactory!
  token: Bytes! # Matches interface
  merkleRoot: Bytes!
  owner: Account!
  deployedOn: BigInt!
  deploymentTx: Bytes!
  totalClaimed: BigDecimal!
  totalClaimedExact: BigInt!
  totalRecipients: Int!
  totalClaims: Int!
  isWithdrawn: Boolean!
  trustedForwarder: Account!
  claims: [AirdropClaim!]! @derivedFrom(field: "airdrop")
  # PushAirdrop specific
  distributionCap: BigInt!
  totalDistributed: BigInt!
  distributions: [PushDistribution!]! @derivedFrom(field: "airdrop")
  merkleRootUpdates: [MerkleRootUpdate!]! @derivedFrom(field: "airdrop")
}

interface VestingStrategy {
  id: Bytes! # Strategy contract address
  type: String! # e.g., "Linear", "Custom"
  airdrop: VestingAirdrop! # The airdrop using this strategy
  owner: Account!
}

type LinearVestingStrategy implements VestingStrategy
  @entity(immutable: false) {
  id: Bytes! # Strategy contract address
  type: String! # = "Linear"
  airdrop: VestingAirdrop! @derivedFrom(field: "strategy") # Derived from VestingAirdrop linking
  airdropRef: Bytes! # Direct reference to airdrop address
  owner: Account!
  # Linear specific
  vestingDuration: BigInt!
  cliffDuration: BigInt!
  vestingData: [UserVestingData!]! @derivedFrom(field: "strategy")
}

# Represents a potential recipient listed in the Merkle tree
# Primarily created/updated upon claim events
type AirdropRecipient @entity(immutable: false) {
  id: String! # airdropId-recipientAddress
  airdrop: Airdrop!
  recipient: Account!
  firstClaimedTimestamp: BigInt # Timestamp of the first claim event for this recipient
  lastClaimedTimestamp: BigInt # Timestamp of the most recent claim event
  totalClaimedByRecipient: BigDecimal! # Sum of all claims by this recipient for this airdrop
  totalClaimedByRecipientExact: BigInt!
  claimIndices: [AirdropClaimIndex!]! @derivedFrom(field: "recipient") # Track individual claimed indices
}

# Represents a specific index claimed by a recipient
type AirdropClaimIndex @entity(immutable: true) {
  id: String! # airdropId-index
  index: BigInt!
  airdrop: Airdrop!
  recipient: AirdropRecipient! # Who claimed this index
  amount: BigDecimal! # Amount associated with this index (from claim event)
  amountExact: BigInt!
  claim: AirdropClaim! # The claim event that processed this index
  timestamp: BigInt!
}

# Records an individual claim event (can be single or batch)
type AirdropClaim @entity(immutable: true) {
  id: String! # txHash-logIndex
  airdrop: Airdrop!
  claimant: Account! # The _msgSender() who initiated the claim
  totalAmount: BigDecimal! # Total amount in this claim event
  totalAmountExact: BigInt!
  indices: [AirdropClaimIndex!]! @derivedFrom(field: "claim") # Link to specific indices claimed
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# Specific vesting data per user for a LinearVestingStrategy
type UserVestingData @entity(immutable: false) {
  id: String! # strategyId-userAddress
  strategy: LinearVestingStrategy!
  user: Account!
  totalAmountAggregated: BigDecimal! # Total allocated amount across all indices for this user
  totalAmountAggregatedExact: BigInt!
  claimedAmountTrackedByStrategy: BigDecimal! # Internal tracking by strategy via recordClaim
  claimedAmountTrackedByStrategyExact: BigInt!
  vestingStart: BigInt!
  initialized: Boolean!
  lastUpdated: BigInt!
}

# Records a distribution event from PushAirdrop
type PushDistribution @entity(immutable: true) {
  id: String! # txHash-logIndex
  airdrop: PushAirdrop!
  distributor: Account! # The admin who performed the distribution
  recipient: Account! # The recipient who received tokens
  amount: BigDecimal! # Amount distributed
  amountExact: BigInt!
  batchDistribution: PushBatchDistribution
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# Records a batch distribution event from PushAirdrop
type PushBatchDistribution @entity(immutable: true) {
  id: String! # txHash-logIndex
  airdrop: PushAirdrop!
  distributor: Account! # The admin who performed the distribution
  recipientCount: Int! # Number of recipients in this batch
  totalAmount: BigDecimal! # Total amount distributed in this batch
  totalAmountExact: BigInt!
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
  distributions: [PushDistribution!]! @derivedFrom(field: "batchDistribution")
}

# Records a merkle root update event from PushAirdrop
type MerkleRootUpdate @entity(immutable: true) {
  id: String! # txHash-logIndex
  airdrop: PushAirdrop!
  updater: Account! # The admin who updated the merkle root
  oldRoot: Bytes! # The previous merkle root (indexed in contract)
  newRoot: Bytes! # The new merkle root (indexed in contract)
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# --------------------------------------------------
# Airdrop Analytics and Statistics
# --------------------------------------------------

# Time-series data for airdrop activity
type AirdropStatsData @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  # Filters
  airdrop: Airdrop!
  airdropType: String! # "Standard", "Vesting", or "Push"
  # Activity
  claims: Int!
  claimVolume: BigDecimal!
  claimVolumeExact: BigInt!
  uniqueClaimants: Int! # New claimants in this period
  # For PushAirdrop
  distributions: Int!
  distributionVolume: BigDecimal!
  distributionVolumeExact: BigInt!
}

# Aggregation entities for time-based analysis
type AirdropStats
  @aggregation(intervals: ["hour", "day"], source: "AirdropStatsData") {
  id: Int8!
  timestamp: Timestamp!
  # Filters
  airdrop: Airdrop!
  airdropType: String!
  # Metrics
  count: Int8! @aggregate(fn: "count", cumulative: true)
  # Claims
  totalClaims: Int! @aggregate(fn: "sum", arg: "claims")
  totalClaimVolume: BigDecimal! @aggregate(fn: "sum", arg: "claimVolume")
  totalClaimVolumeExact: BigInt! @aggregate(fn: "sum", arg: "claimVolumeExact")
  totalUniqueClaimants: Int! @aggregate(fn: "sum", arg: "uniqueClaimants")
  # Distributions (for PushAirdrop)
  totalDistributions: Int! @aggregate(fn: "sum", arg: "distributions")
  totalDistributionVolume: BigDecimal!
    @aggregate(fn: "sum", arg: "distributionVolume")
  totalDistributionVolumeExact: BigInt!
    @aggregate(fn: "sum", arg: "distributionVolumeExact")
}

# Special statistics for vesting airdrops
type VestingStatsData @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  # Filters
  airdrop: VestingAirdrop!
  # Vesting metrics
  vestedAmount: BigDecimal!
  vestedAmountExact: BigInt!
  unlockedAmount: BigDecimal! # Amount that has vested and can be claimed
  unlockedAmountExact: BigInt!
  claimedVestedAmount: BigDecimal! # Portion of vested amount that has been claimed
  claimedVestedAmountExact: BigInt!
  activeVestingStreams: Int! # Number of active vesting schedules
  completedVestingStreams: Int! # Number of completed vesting schedules
}

# Aggregation entity for vesting statistics
type VestingStats
  @aggregation(intervals: ["hour", "day"], source: "VestingStatsData") {
  id: Int8!
  timestamp: Timestamp!
  # Filters
  airdrop: VestingAirdrop!
  # Metrics
  count: Int8! @aggregate(fn: "count", cumulative: true)
  # Vesting progress
  totalVestedAmount: BigDecimal! @aggregate(fn: "last", arg: "vestedAmount")
  totalVestedAmountExact: BigInt!
    @aggregate(fn: "last", arg: "vestedAmountExact")
  totalUnlockedAmount: BigDecimal! @aggregate(fn: "last", arg: "unlockedAmount")
  totalUnlockedAmountExact: BigInt!
    @aggregate(fn: "last", arg: "unlockedAmountExact")
  totalClaimedVestedAmount: BigDecimal!
    @aggregate(fn: "sum", arg: "claimedVestedAmount")
  totalClaimedVestedAmountExact: BigInt!
    @aggregate(fn: "sum", arg: "claimedVestedAmountExact")
  activeVestingStreams: Int! @aggregate(fn: "last", arg: "activeVestingStreams")
  completedVestingStreams: Int!
    @aggregate(fn: "last", arg: "completedVestingStreams")
}

# Daily and weekly summary of airdrop performance
type AirdropPerformanceSummary @entity(immutable: false) {
  id: String! # airdropId-timeframe (e.g., "0x123-daily", "0x123-weekly")
  airdrop: Airdrop!
  timeframe: String! # "daily", "weekly"
  startTime: BigInt!
  endTime: BigInt!
  newClaimants: Int!
  totalClaims: Int!
  claimVolume: BigDecimal!
  claimVolumeExact: BigInt!
  claimRatePercentage: BigDecimal! # Percentage of eligible recipients who claimed
  # Distribution metrics for PushAirdrop
  newDistributions: Int!
  distributionVolume: BigDecimal!
  distributionVolumeExact: BigInt!
  # Time metrics
  avgClaimResponseTime: BigInt! # Average time between eligibility and claim
  peakClaimHour: Int! # Hour of day with most claims (0-23)
  lastUpdated: BigInt!
}
