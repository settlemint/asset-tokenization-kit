schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "account"
"""
type account {
  accessToken: String
  accessTokenExpiresAt: timestamp
  accountId: String!
  createdAt: timestamp!
  id: String!
  idToken: String
  password: String
  providerId: String!
  refreshToken: String
  refreshTokenExpiresAt: timestamp
  scope: String
  updatedAt: timestamp!
  userId: String!
}

"""
aggregated selection of "account"
"""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

"""
aggregate fields of "account"
"""
type account_aggregate_fields {
  count(columns: [account_select_column!], distinct: Boolean): Int!
  max: account_max_fields
  min: account_min_fields
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input account_bool_exp {
  _and: [account_bool_exp!]
  _not: account_bool_exp
  _or: [account_bool_exp!]
  accessToken: String_comparison_exp
  accessTokenExpiresAt: timestamp_comparison_exp
  accountId: String_comparison_exp
  createdAt: timestamp_comparison_exp
  id: String_comparison_exp
  idToken: String_comparison_exp
  password: String_comparison_exp
  providerId: String_comparison_exp
  refreshToken: String_comparison_exp
  refreshTokenExpiresAt: timestamp_comparison_exp
  scope: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "account"
"""
enum account_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  account_pkey
}

"""
input type for inserting data into table "account"
"""
input account_insert_input {
  accessToken: String
  accessTokenExpiresAt: timestamp
  accountId: String
  createdAt: timestamp
  id: String
  idToken: String
  password: String
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamp
  scope: String
  updatedAt: timestamp
  userId: String
}

"""aggregate max on columns"""
type account_max_fields {
  accessToken: String
  accessTokenExpiresAt: timestamp
  accountId: String
  createdAt: timestamp
  id: String
  idToken: String
  password: String
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamp
  scope: String
  updatedAt: timestamp
  userId: String
}

"""aggregate min on columns"""
type account_min_fields {
  accessToken: String
  accessTokenExpiresAt: timestamp
  accountId: String
  createdAt: timestamp
  id: String
  idToken: String
  password: String
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamp
  scope: String
  updatedAt: timestamp
  userId: String
}

"""
response of any mutation on the table "account"
"""
type account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [account!]!
}

"""
on_conflict condition type for table "account"
"""
input account_on_conflict {
  constraint: account_constraint!
  update_columns: [account_update_column!]! = []
  where: account_bool_exp
}

"""Ordering options when selecting data from "account"."""
input account_order_by {
  accessToken: order_by
  accessTokenExpiresAt: order_by
  accountId: order_by
  createdAt: order_by
  id: order_by
  idToken: order_by
  password: order_by
  providerId: order_by
  refreshToken: order_by
  refreshTokenExpiresAt: order_by
  scope: order_by
  updatedAt: order_by
  userId: order_by
}

"""primary key columns input for table: account"""
input account_pk_columns_input {
  id: String!
}

"""
select columns of table "account"
"""
enum account_select_column {
  """column name"""
  accessToken

  """column name"""
  accessTokenExpiresAt

  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  idToken

  """column name"""
  password

  """column name"""
  providerId

  """column name"""
  refreshToken

  """column name"""
  refreshTokenExpiresAt

  """column name"""
  scope

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "account"
"""
input account_set_input {
  accessToken: String
  accessTokenExpiresAt: timestamp
  accountId: String
  createdAt: timestamp
  id: String
  idToken: String
  password: String
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamp
  scope: String
  updatedAt: timestamp
  userId: String
}

"""
Streaming cursor of the table "account"
"""
input account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input account_stream_cursor_value_input {
  accessToken: String
  accessTokenExpiresAt: timestamp
  accountId: String
  createdAt: timestamp
  id: String
  idToken: String
  password: String
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamp
  scope: String
  updatedAt: timestamp
  userId: String
}

"""
update columns of table "account"
"""
enum account_update_column {
  """column name"""
  accessToken

  """column name"""
  accessTokenExpiresAt

  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  idToken

  """column name"""
  password

  """column name"""
  providerId

  """column name"""
  refreshToken

  """column name"""
  refreshTokenExpiresAt

  """column name"""
  scope

  """column name"""
  updatedAt

  """column name"""
  userId
}

input account_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: account_set_input

  """filter the rows which have to be updated"""
  where: account_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "account"
  """
  delete_account(
    """filter the rows which have to be deleted"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  delete single row from the table: "account"
  """
  delete_account_by_pk(id: String!): account

  """
  delete data from the table: "passkey"
  """
  delete_passkey(
    """filter the rows which have to be deleted"""
    where: passkey_bool_exp!
  ): passkey_mutation_response

  """
  delete single row from the table: "passkey"
  """
  delete_passkey_by_pk(id: String!): passkey

  """
  delete data from the table: "session"
  """
  delete_session(
    """filter the rows which have to be deleted"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  delete single row from the table: "session"
  """
  delete_session_by_pk(id: String!): session

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: String!): user

  """
  delete data from the table: "verification"
  """
  delete_verification(
    """filter the rows which have to be deleted"""
    where: verification_bool_exp!
  ): verification_mutation_response

  """
  delete single row from the table: "verification"
  """
  delete_verification_by_pk(id: String!): verification

  """
  insert data into the table: "account"
  """
  insert_account(
    """the rows to be inserted"""
    objects: [account_insert_input!]!

    """upsert condition"""
    on_conflict: account_on_conflict
  ): account_mutation_response

  """
  insert a single row into the table: "account"
  """
  insert_account_one(
    """the row to be inserted"""
    object: account_insert_input!

    """upsert condition"""
    on_conflict: account_on_conflict
  ): account

  """
  insert data into the table: "passkey"
  """
  insert_passkey(
    """the rows to be inserted"""
    objects: [passkey_insert_input!]!

    """upsert condition"""
    on_conflict: passkey_on_conflict
  ): passkey_mutation_response

  """
  insert a single row into the table: "passkey"
  """
  insert_passkey_one(
    """the row to be inserted"""
    object: passkey_insert_input!

    """upsert condition"""
    on_conflict: passkey_on_conflict
  ): passkey

  """
  insert data into the table: "session"
  """
  insert_session(
    """the rows to be inserted"""
    objects: [session_insert_input!]!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session_mutation_response

  """
  insert a single row into the table: "session"
  """
  insert_session_one(
    """the row to be inserted"""
    object: session_insert_input!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  insert data into the table: "verification"
  """
  insert_verification(
    """the rows to be inserted"""
    objects: [verification_insert_input!]!

    """upsert condition"""
    on_conflict: verification_on_conflict
  ): verification_mutation_response

  """
  insert a single row into the table: "verification"
  """
  insert_verification_one(
    """the row to be inserted"""
    object: verification_insert_input!

    """upsert condition"""
    on_conflict: verification_on_conflict
  ): verification

  """
  update data of the table: "account"
  """
  update_account(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input

    """filter the rows which have to be updated"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  update single row of the table: "account"
  """
  update_account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input
    pk_columns: account_pk_columns_input!
  ): account

  """
  update multiples rows of table: "account"
  """
  update_account_many(
    """updates to execute, in order"""
    updates: [account_updates!]!
  ): [account_mutation_response]

  """
  update data of the table: "passkey"
  """
  update_passkey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: passkey_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: passkey_set_input

    """filter the rows which have to be updated"""
    where: passkey_bool_exp!
  ): passkey_mutation_response

  """
  update single row of the table: "passkey"
  """
  update_passkey_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: passkey_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: passkey_set_input
    pk_columns: passkey_pk_columns_input!
  ): passkey

  """
  update multiples rows of table: "passkey"
  """
  update_passkey_many(
    """updates to execute, in order"""
    updates: [passkey_updates!]!
  ): [passkey_mutation_response]

  """
  update data of the table: "session"
  """
  update_session(
    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input

    """filter the rows which have to be updated"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  update single row of the table: "session"
  """
  update_session_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input
    pk_columns: session_pk_columns_input!
  ): session

  """
  update multiples rows of table: "session"
  """
  update_session_many(
    """updates to execute, in order"""
    updates: [session_updates!]!
  ): [session_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]

  """
  update data of the table: "verification"
  """
  update_verification(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_set_input

    """filter the rows which have to be updated"""
    where: verification_bool_exp!
  ): verification_mutation_response

  """
  update single row of the table: "verification"
  """
  update_verification_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_set_input
    pk_columns: verification_pk_columns_input!
  ): verification

  """
  update multiples rows of table: "verification"
  """
  update_verification_many(
    """updates to execute, in order"""
    updates: [verification_updates!]!
  ): [verification_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "passkey"
"""
type passkey {
  backedUp: Boolean!
  counter: Int!
  createdAt: timestamp
  deviceType: String!
  id: String!
  name: String
  publicKey: String!
  transports: String
  userId: String!
  webauthnUserID: String!
}

"""
aggregated selection of "passkey"
"""
type passkey_aggregate {
  aggregate: passkey_aggregate_fields
  nodes: [passkey!]!
}

"""
aggregate fields of "passkey"
"""
type passkey_aggregate_fields {
  avg: passkey_avg_fields
  count(columns: [passkey_select_column!], distinct: Boolean): Int!
  max: passkey_max_fields
  min: passkey_min_fields
  stddev: passkey_stddev_fields
  stddev_pop: passkey_stddev_pop_fields
  stddev_samp: passkey_stddev_samp_fields
  sum: passkey_sum_fields
  var_pop: passkey_var_pop_fields
  var_samp: passkey_var_samp_fields
  variance: passkey_variance_fields
}

"""aggregate avg on columns"""
type passkey_avg_fields {
  counter: Float
}

"""
Boolean expression to filter rows from the table "passkey". All fields are combined with a logical 'AND'.
"""
input passkey_bool_exp {
  _and: [passkey_bool_exp!]
  _not: passkey_bool_exp
  _or: [passkey_bool_exp!]
  backedUp: Boolean_comparison_exp
  counter: Int_comparison_exp
  createdAt: timestamp_comparison_exp
  deviceType: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  publicKey: String_comparison_exp
  transports: String_comparison_exp
  userId: String_comparison_exp
  webauthnUserID: String_comparison_exp
}

"""
unique or primary key constraints on table "passkey"
"""
enum passkey_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  passkey_pkey
}

"""
input type for incrementing numeric columns in table "passkey"
"""
input passkey_inc_input {
  counter: Int
}

"""
input type for inserting data into table "passkey"
"""
input passkey_insert_input {
  backedUp: Boolean
  counter: Int
  createdAt: timestamp
  deviceType: String
  id: String
  name: String
  publicKey: String
  transports: String
  userId: String
  webauthnUserID: String
}

"""aggregate max on columns"""
type passkey_max_fields {
  counter: Int
  createdAt: timestamp
  deviceType: String
  id: String
  name: String
  publicKey: String
  transports: String
  userId: String
  webauthnUserID: String
}

"""aggregate min on columns"""
type passkey_min_fields {
  counter: Int
  createdAt: timestamp
  deviceType: String
  id: String
  name: String
  publicKey: String
  transports: String
  userId: String
  webauthnUserID: String
}

"""
response of any mutation on the table "passkey"
"""
type passkey_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [passkey!]!
}

"""
on_conflict condition type for table "passkey"
"""
input passkey_on_conflict {
  constraint: passkey_constraint!
  update_columns: [passkey_update_column!]! = []
  where: passkey_bool_exp
}

"""Ordering options when selecting data from "passkey"."""
input passkey_order_by {
  backedUp: order_by
  counter: order_by
  createdAt: order_by
  deviceType: order_by
  id: order_by
  name: order_by
  publicKey: order_by
  transports: order_by
  userId: order_by
  webauthnUserID: order_by
}

"""primary key columns input for table: passkey"""
input passkey_pk_columns_input {
  id: String!
}

"""
select columns of table "passkey"
"""
enum passkey_select_column {
  """column name"""
  backedUp

  """column name"""
  counter

  """column name"""
  createdAt

  """column name"""
  deviceType

  """column name"""
  id

  """column name"""
  name

  """column name"""
  publicKey

  """column name"""
  transports

  """column name"""
  userId

  """column name"""
  webauthnUserID
}

"""
input type for updating data in table "passkey"
"""
input passkey_set_input {
  backedUp: Boolean
  counter: Int
  createdAt: timestamp
  deviceType: String
  id: String
  name: String
  publicKey: String
  transports: String
  userId: String
  webauthnUserID: String
}

"""aggregate stddev on columns"""
type passkey_stddev_fields {
  counter: Float
}

"""aggregate stddev_pop on columns"""
type passkey_stddev_pop_fields {
  counter: Float
}

"""aggregate stddev_samp on columns"""
type passkey_stddev_samp_fields {
  counter: Float
}

"""
Streaming cursor of the table "passkey"
"""
input passkey_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: passkey_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input passkey_stream_cursor_value_input {
  backedUp: Boolean
  counter: Int
  createdAt: timestamp
  deviceType: String
  id: String
  name: String
  publicKey: String
  transports: String
  userId: String
  webauthnUserID: String
}

"""aggregate sum on columns"""
type passkey_sum_fields {
  counter: Int
}

"""
update columns of table "passkey"
"""
enum passkey_update_column {
  """column name"""
  backedUp

  """column name"""
  counter

  """column name"""
  createdAt

  """column name"""
  deviceType

  """column name"""
  id

  """column name"""
  name

  """column name"""
  publicKey

  """column name"""
  transports

  """column name"""
  userId

  """column name"""
  webauthnUserID
}

input passkey_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: passkey_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: passkey_set_input

  """filter the rows which have to be updated"""
  where: passkey_bool_exp!
}

"""aggregate var_pop on columns"""
type passkey_var_pop_fields {
  counter: Float
}

"""aggregate var_samp on columns"""
type passkey_var_samp_fields {
  counter: Float
}

"""aggregate variance on columns"""
type passkey_variance_fields {
  counter: Float
}

type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(id: String!): account

  """
  fetch data from the table: "passkey"
  """
  passkey(
    """distinct select on columns"""
    distinct_on: [passkey_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [passkey_order_by!]

    """filter the rows returned"""
    where: passkey_bool_exp
  ): [passkey!]!

  """
  fetch aggregated fields from the table: "passkey"
  """
  passkey_aggregate(
    """distinct select on columns"""
    distinct_on: [passkey_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [passkey_order_by!]

    """filter the rows returned"""
    where: passkey_bool_exp
  ): passkey_aggregate!

  """fetch data from the table: "passkey" using primary key columns"""
  passkey_by_pk(id: String!): passkey

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(id: String!): session

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user

  """
  fetch data from the table: "verification"
  """
  verification(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): [verification!]!

  """
  fetch aggregated fields from the table: "verification"
  """
  verification_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): verification_aggregate!

  """fetch data from the table: "verification" using primary key columns"""
  verification_by_pk(id: String!): verification
}

"""
columns and relationships of "session"
"""
type session {
  createdAt: timestamp!
  expiresAt: timestamp!
  id: String!
  impersonatedBy: String
  ipAddress: String
  token: String!
  updatedAt: timestamp!
  userAgent: String
  userId: String!
}

"""
aggregated selection of "session"
"""
type session_aggregate {
  aggregate: session_aggregate_fields
  nodes: [session!]!
}

"""
aggregate fields of "session"
"""
type session_aggregate_fields {
  count(columns: [session_select_column!], distinct: Boolean): Int!
  max: session_max_fields
  min: session_min_fields
}

"""
Boolean expression to filter rows from the table "session". All fields are combined with a logical 'AND'.
"""
input session_bool_exp {
  _and: [session_bool_exp!]
  _not: session_bool_exp
  _or: [session_bool_exp!]
  createdAt: timestamp_comparison_exp
  expiresAt: timestamp_comparison_exp
  id: String_comparison_exp
  impersonatedBy: String_comparison_exp
  ipAddress: String_comparison_exp
  token: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  userAgent: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "session"
"""
enum session_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  session_pkey

  """
  unique or primary key constraint on columns "token"
  """
  session_token_unique
}

"""
input type for inserting data into table "session"
"""
input session_insert_input {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  impersonatedBy: String
  ipAddress: String
  token: String
  updatedAt: timestamp
  userAgent: String
  userId: String
}

"""aggregate max on columns"""
type session_max_fields {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  impersonatedBy: String
  ipAddress: String
  token: String
  updatedAt: timestamp
  userAgent: String
  userId: String
}

"""aggregate min on columns"""
type session_min_fields {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  impersonatedBy: String
  ipAddress: String
  token: String
  updatedAt: timestamp
  userAgent: String
  userId: String
}

"""
response of any mutation on the table "session"
"""
type session_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [session!]!
}

"""
on_conflict condition type for table "session"
"""
input session_on_conflict {
  constraint: session_constraint!
  update_columns: [session_update_column!]! = []
  where: session_bool_exp
}

"""Ordering options when selecting data from "session"."""
input session_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  impersonatedBy: order_by
  ipAddress: order_by
  token: order_by
  updatedAt: order_by
  userAgent: order_by
  userId: order_by
}

"""primary key columns input for table: session"""
input session_pk_columns_input {
  id: String!
}

"""
select columns of table "session"
"""
enum session_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  impersonatedBy

  """column name"""
  ipAddress

  """column name"""
  token

  """column name"""
  updatedAt

  """column name"""
  userAgent

  """column name"""
  userId
}

"""
input type for updating data in table "session"
"""
input session_set_input {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  impersonatedBy: String
  ipAddress: String
  token: String
  updatedAt: timestamp
  userAgent: String
  userId: String
}

"""
Streaming cursor of the table "session"
"""
input session_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: session_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input session_stream_cursor_value_input {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  impersonatedBy: String
  ipAddress: String
  token: String
  updatedAt: timestamp
  userAgent: String
  userId: String
}

"""
update columns of table "session"
"""
enum session_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  impersonatedBy

  """column name"""
  ipAddress

  """column name"""
  token

  """column name"""
  updatedAt

  """column name"""
  userAgent

  """column name"""
  userId
}

input session_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: session_set_input

  """filter the rows which have to be updated"""
  where: session_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(id: String!): account

  """
  fetch data from the table in a streaming manner: "account"
  """
  account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [account_stream_cursor_input]!

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch data from the table: "passkey"
  """
  passkey(
    """distinct select on columns"""
    distinct_on: [passkey_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [passkey_order_by!]

    """filter the rows returned"""
    where: passkey_bool_exp
  ): [passkey!]!

  """
  fetch aggregated fields from the table: "passkey"
  """
  passkey_aggregate(
    """distinct select on columns"""
    distinct_on: [passkey_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [passkey_order_by!]

    """filter the rows returned"""
    where: passkey_bool_exp
  ): passkey_aggregate!

  """fetch data from the table: "passkey" using primary key columns"""
  passkey_by_pk(id: String!): passkey

  """
  fetch data from the table in a streaming manner: "passkey"
  """
  passkey_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [passkey_stream_cursor_input]!

    """filter the rows returned"""
    where: passkey_bool_exp
  ): [passkey!]!

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(id: String!): session

  """
  fetch data from the table in a streaming manner: "session"
  """
  session_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [session_stream_cursor_input]!

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "verification"
  """
  verification(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): [verification!]!

  """
  fetch aggregated fields from the table: "verification"
  """
  verification_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_order_by!]

    """filter the rows returned"""
    where: verification_bool_exp
  ): verification_aggregate!

  """fetch data from the table: "verification" using primary key columns"""
  verification_by_pk(id: String!): verification

  """
  fetch data from the table in a streaming manner: "verification"
  """
  verification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [verification_stream_cursor_input]!

    """filter the rows returned"""
    where: verification_bool_exp
  ): [verification!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "user"
"""
type user {
  banExpires: timestamp
  banReason: String
  banned: Boolean
  createdAt: timestamp!
  email: String!
  emailVerified: Boolean!
  id: String!
  image: String
  name: String!
  normalizedEmail: String
  role: String
  updatedAt: timestamp!
  wallet: String!
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  banExpires: timestamp_comparison_exp
  banReason: String_comparison_exp
  banned: Boolean_comparison_exp
  createdAt: timestamp_comparison_exp
  email: String_comparison_exp
  emailVerified: Boolean_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  name: String_comparison_exp
  normalizedEmail: String_comparison_exp
  role: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  wallet: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_unique

  """
  unique or primary key constraint on columns "normalizedEmail"
  """
  user_normalizedEmail_unique

  """
  unique or primary key constraint on columns "id"
  """
  user_pkey

  """
  unique or primary key constraint on columns "wallet"
  """
  user_wallet_unique
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  banExpires: timestamp
  banReason: String
  banned: Boolean
  createdAt: timestamp
  email: String
  emailVerified: Boolean
  id: String
  image: String
  name: String
  normalizedEmail: String
  role: String
  updatedAt: timestamp
  wallet: String
}

"""aggregate max on columns"""
type user_max_fields {
  banExpires: timestamp
  banReason: String
  createdAt: timestamp
  email: String
  id: String
  image: String
  name: String
  normalizedEmail: String
  role: String
  updatedAt: timestamp
  wallet: String
}

"""aggregate min on columns"""
type user_min_fields {
  banExpires: timestamp
  banReason: String
  createdAt: timestamp
  email: String
  id: String
  image: String
  name: String
  normalizedEmail: String
  role: String
  updatedAt: timestamp
  wallet: String
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  banExpires: order_by
  banReason: order_by
  banned: order_by
  createdAt: order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  image: order_by
  name: order_by
  normalizedEmail: order_by
  role: order_by
  updatedAt: order_by
  wallet: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: String!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  banExpires

  """column name"""
  banReason

  """column name"""
  banned

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  normalizedEmail

  """column name"""
  role

  """column name"""
  updatedAt

  """column name"""
  wallet
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  banExpires: timestamp
  banReason: String
  banned: Boolean
  createdAt: timestamp
  email: String
  emailVerified: Boolean
  id: String
  image: String
  name: String
  normalizedEmail: String
  role: String
  updatedAt: timestamp
  wallet: String
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  banExpires: timestamp
  banReason: String
  banned: Boolean
  createdAt: timestamp
  email: String
  emailVerified: Boolean
  id: String
  image: String
  name: String
  normalizedEmail: String
  role: String
  updatedAt: timestamp
  wallet: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  banExpires

  """column name"""
  banReason

  """column name"""
  banned

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  normalizedEmail

  """column name"""
  role

  """column name"""
  updatedAt

  """column name"""
  wallet
}

input user_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

"""
columns and relationships of "verification"
"""
type verification {
  createdAt: timestamp
  expiresAt: timestamp!
  id: String!
  identifier: String!
  updatedAt: timestamp
  value: String!
}

"""
aggregated selection of "verification"
"""
type verification_aggregate {
  aggregate: verification_aggregate_fields
  nodes: [verification!]!
}

"""
aggregate fields of "verification"
"""
type verification_aggregate_fields {
  count(columns: [verification_select_column!], distinct: Boolean): Int!
  max: verification_max_fields
  min: verification_min_fields
}

"""
Boolean expression to filter rows from the table "verification". All fields are combined with a logical 'AND'.
"""
input verification_bool_exp {
  _and: [verification_bool_exp!]
  _not: verification_bool_exp
  _or: [verification_bool_exp!]
  createdAt: timestamp_comparison_exp
  expiresAt: timestamp_comparison_exp
  id: String_comparison_exp
  identifier: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "verification"
"""
enum verification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  verification_pkey
}

"""
input type for inserting data into table "verification"
"""
input verification_insert_input {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  identifier: String
  updatedAt: timestamp
  value: String
}

"""aggregate max on columns"""
type verification_max_fields {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  identifier: String
  updatedAt: timestamp
  value: String
}

"""aggregate min on columns"""
type verification_min_fields {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  identifier: String
  updatedAt: timestamp
  value: String
}

"""
response of any mutation on the table "verification"
"""
type verification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [verification!]!
}

"""
on_conflict condition type for table "verification"
"""
input verification_on_conflict {
  constraint: verification_constraint!
  update_columns: [verification_update_column!]! = []
  where: verification_bool_exp
}

"""Ordering options when selecting data from "verification"."""
input verification_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  identifier: order_by
  updatedAt: order_by
  value: order_by
}

"""primary key columns input for table: verification"""
input verification_pk_columns_input {
  id: String!
}

"""
select columns of table "verification"
"""
enum verification_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  identifier

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "verification"
"""
input verification_set_input {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  identifier: String
  updatedAt: timestamp
  value: String
}

"""
Streaming cursor of the table "verification"
"""
input verification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: verification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input verification_stream_cursor_value_input {
  createdAt: timestamp
  expiresAt: timestamp
  id: String
  identifier: String
  updatedAt: timestamp
  value: String
}

"""
update columns of table "verification"
"""
enum verification_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  identifier

  """column name"""
  updatedAt

  """column name"""
  value
}

input verification_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: verification_set_input

  """filter the rows which have to be updated"""
  where: verification_bool_exp!
}