---
title: API based cross border FX
description:
  Execute cross-border foreign exchange settlements and bond investments using
  REST API calls with curl. This runbook demonstrates how to orchestrate stablecoin
  minting, XvP settlement swaps, and bond coupon distributions with automated
  offchain FX transaction reconciliation via blockchain event monitoring.
pageTitle: API-based cross-border FX settlement runbook
tags: [runbook, api, fx, cross-border, settlement, xvp, stablecoin, bonds, curl, rest]
---

**Primary audience:** Integration developers, treasury operations engineers  
**Secondary audience:** Payment processors, settlement coordinators

## Overview

This runbook guides you through automating cross-border foreign exchange
settlements using ATK's XvP (Cross-Value Proposition) settlement system and
stablecoin infrastructure. You'll learn how to execute FX transactions
between different currency jurisdictions, handle bond investments with coupon
payments, and automatically reconcile offchain banking transactions by listening
to on-chain events.

The workflow demonstrates a real-world scenario where Maybank customers in
Malaysia and Singapore transact across borders. When User A sends MYR to User B
(who receives SGD), the system orchestrates:

1. **Tokenization** ? User A's MYR deposit becomes an EUR stablecoin
   liability from GM Malaysia Entity
2. **Cross-border swap** ? XvP settlement burns EUR stablecoin and mints SGD
   stablecoin, transferring liability from GM Malaysia to GM Singapore
3. **Settlement** ? User B withdraws SGD stablecoin, triggering offchain SGD
   transfer from GM Singapore Entity

For bond investments, the system handles coupon payments across currencies,
converting bond yields from EUR to SGD using FX swaps.

<Mermaid
  chart={`flowchart TB
    Start(Cross-Border FX Workflow) --> Setup(Setup Phase)
    Setup --> Scenario1(Cross-Border Settlement)
    Setup --> Scenario2(Bond Investment)
    
    Scenario1 --> Mint1(Mint EUR Stablecoin<br/>to User A)
    Mint1 --> Swap1(XvP Swap: Burn EUR<br/>Mint SGD)
    Swap1 --> Withdraw1(User B Withdraws<br/>SGD Stablecoin)
    
    Scenario2 --> MintBond(Mint Bond<br/>in GM Wallet)
    MintBond --> MintSGD(Mint SGD Stablecoin<br/>to User B)
    MintSGD --> SwapBond(XvP Swap: SGD<br/>for Bond)
    SwapBond --> Coupon(Coupon Payment<br/>EUR Stablecoin)
    Coupon --> SwapCoupon(XvP Swap: EUR<br/>to SGD)
    
    style Start fill:#5fc9bf,stroke:#3a9d96,stroke-width:2px,color:#fff
    style Swap1 fill:#8571d9,stroke:#654bad,stroke-width:2px,color:#fff
    style SwapBond fill:#8571d9,stroke:#654bad,stroke-width:2px,color:#fff
    style SwapCoupon fill:#8571d9,stroke:#654bad,stroke-width:2px,color:#fff
`}
/>

## Prerequisites

**Required setup:**

- Platform deployed with XvP settlement addon enabled
- Admin access to create asset types, users, and wallets
- API base URL configured (default: `http://localhost:3000/api/rpc`)
- Session authentication cookie for API requests
- Access to observability dashboards for event monitoring
- Banking integration for offchain FX transaction execution

**Time estimate:** Initial setup 1-2 hours; API workflow execution varies by
transaction volume

**Required knowledge:**

- REST API usage with curl or HTTP clients
- Session-based authentication and cookie management
- Blockchain event listening and WebSocket subscriptions
- Cross-border settlement operations
- Treasury operations and FX transaction processing

## API authentication

All API requests require session authentication via cookies. First, authenticate
through the web interface or login endpoint to obtain a session cookie.

**Base URL:** `http://localhost:3000/api/rpc` (development)  
**Production:** Configure via your deployment's API base URL

**Session cookie:** After logging in through the web interface, extract the
session cookie from your browser's developer tools and include it in curl
requests:

```bash
# Set your session cookie (replace with actual cookie value)
export SESSION_COOKIE="your-session-cookie-value"

# Use in curl requests
curl -X POST http://localhost:3000/api/rpc/token.list \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{"input": {"typeId": "stablecoin", "limit": 20}}'
```

## Setup phase: Create infrastructure

Before executing cross-border FX workflows, establish the foundational
infrastructure: stablecoins, test users, bond assets, and entity wallets.

### Step 1: Create stablecoins

Create EUR and SGD stablecoins to represent liabilities from GM Malaysia and GM
Singapore entities. These stablecoins will participate in XvP settlement swaps.

**Create EUR stablecoin:**

```bash
curl -X POST http://localhost:3000/api/rpc/token.create \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "name": "EUR Stablecoin",
      "symbol": "EURST",
      "typeId": "stablecoin",
      "decimals": 18,
      "initialSupply": "0"
    }
  }'
```

**Response:**

```json
{
  "transactionHash": "0x1234...",
  "address": "0xEUR_STABLECOIN_ADDRESS",
  "name": "EUR Stablecoin",
  "symbol": "EURST"
}
```

**Create SGD stablecoin:**

```bash
curl -X POST http://localhost:3000/api/rpc/token.create \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "name": "SGD Stablecoin",
      "symbol": "SGDST",
      "typeId": "stablecoin",
      "decimals": 18,
      "initialSupply": "0"
    }
  }'
```

**Response:**

```json
{
  "transactionHash": "0x5678...",
  "address": "0xSGD_STABLECOIN_ADDRESS",
  "name": "SGD Stablecoin",
  "symbol": "SGDST"
}
```

**Save addresses for later use:**

```bash
export EUR_STABLECOIN="0xEUR_STABLECOIN_ADDRESS"
export SGD_STABLECOIN="0xSGD_STABLECOIN_ADDRESS"
```

**Offchain accounting:** Each stablecoin represents a liability from the
respective GM entity. When EUR stablecoin is minted to User A, GM Malaysia
Entity's liability to User A increases. The stablecoin balance reflects this
liability on-chain.

### Step 2: Create test users

Create User A and User B to represent Maybank customers in different
jurisdictions.

**Create User A (Malaysia):**

```bash
curl -X POST http://localhost:3000/api/rpc/user.create \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "email": "user-a@example.com",
      "name": "User A"
    }
  }'
```

**Create User B (Singapore):**

```bash
curl -X POST http://localhost:3000/api/rpc/user.create \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "email": "user-b@example.com",
      "name": "User B"
    }
  }'
```

**Note:** Ensure both users complete KYC verification before executing
settlement operations. Compliance checks are enforced at the smart contract
level during XvP swaps.

### Step 3: Create bond asset

Create a bond token that will be exchanged for SGD stablecoin in the investment
workflow.

```bash
curl -X POST http://localhost:3000/api/rpc/token.create \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "name": "Corporate Bond 2025",
      "symbol": "BOND25",
      "typeId": "bond",
      "decimals": 18,
      "initialSupply": "0",
      "maturityDate": "2025-12-31",
      "couponRate": "5.0",
      "denominationAsset": "'${EUR_STABLECOIN}'"
    }
  }'
```

**Response:**

```json
{
  "transactionHash": "0xABCD...",
  "address": "0xBOND_TOKEN_ADDRESS",
  "name": "Corporate Bond 2025",
  "symbol": "BOND25"
}
```

**Save bond address:**

```bash
export BOND_TOKEN="0xBOND_TOKEN_ADDRESS"
```

### Step 4: Create entity wallets

Create wallets representing GM Malaysia Entity and GM Singapore Entity. These
wallets hold assets and execute XvP settlements on behalf of their respective
entities.

**Get user IDs first (if needed):**

```bash
# List users to find entity user IDs
curl -X POST http://localhost:3000/api/rpc/user.list \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{"input": {"limit": 100}}'
```

**Create GM Malaysia Entity wallet:**

```bash
curl -X POST http://localhost:3000/api/rpc/user.createWallet \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "userId": "GM_MALAYSIA_USER_ID",
      "name": "GM Malaysia Entity Wallet"
    }
  }'
```

**Create GM Singapore Entity wallet:**

```bash
curl -X POST http://localhost:3000/api/rpc/user.createWallet \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "userId": "GM_SINGAPORE_USER_ID",
      "name": "GM Singapore Entity Wallet"
    }
  }'
```

**Save wallet addresses:**

```bash
export GM_MALAYSIA_WALLET="0xGM_MALAYSIA_WALLET_ADDRESS"
export GM_SINGAPORE_WALLET="0xGM_SINGAPORE_WALLET_ADDRESS"
export USER_A_WALLET="0xUSER_A_WALLET_ADDRESS"
export USER_B_WALLET="0xUSER_B_WALLET_ADDRESS"
```

**Offchain accounting:** These wallets represent the on-chain presence of GM
entities. When liabilities transfer between entities (via XvP swaps), the
wallets reflect the liability shift on-chain.

## Cross-border settlement workflow

This workflow simulates User A sending MYR to User B, who receives SGD. The
system orchestrates the cross-border transfer through stablecoin tokenization
and XvP settlement.

### Step 1: Mint EUR stablecoin to User A

Tokenize User A's MYR deposit by minting EUR stablecoin to their wallet. This
represents GM Malaysia Entity's liability to User A.

**API call:**

```bash
curl -X POST http://localhost:3000/api/rpc/token.mint \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "address": "'${EUR_STABLECOIN}'",
      "recipients": [
        {
          "to": "'${USER_A_WALLET}'",
          "amount": "1000000000000000000000"
        }
      ]
    }
  }'
```

**Amount explanation:** `1000000000000000000000` represents 1000 EUR stablecoin
(18 decimals: 1000 ? 10^18).

**Response:**

```json
{
  "transactionHash": "0xMINT_TX_HASH",
  "recipients": [
    {
      "to": "0xUSER_A_WALLET_ADDRESS",
      "amount": "1000000000000000000000"
    }
  ]
}
```

**Offchain reconciliation:**

- User A's MYR deposit is transferred from their account to GM Malaysia Entity
- GM Malaysia Entity's liability to User A increases by 1000 EUR equivalent
- The stablecoin balance on-chain represents this liability

**Event monitoring:** Listen for `Transfer` events from the zero address to
confirm minting. See the [Event listening architecture](#event-listening-architecture)
section for implementation details.

### Step 2: Create XvP swap contract

Create an XvP settlement that burns User A's EUR stablecoin and mints SGD
stablecoin to User B using the current FX rate.

**FX rate calculation:** Determine the EUR-to-SGD exchange rate (e.g., 1 EUR =
1.5 SGD).

**API call (XvP settlement creation):**

```bash
# Note: XvP API endpoints will be available when fully integrated
# This is the expected structure
curl -X POST http://localhost:3000/api/rpc/xvp.createSettlement \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "participants": [
        {
          "address": "'${USER_A_WALLET}'",
          "token": "'${EUR_STABLECOIN}'",
          "amount": "1000000000000000000000",
          "action": "burn"
        },
        {
          "address": "'${USER_B_WALLET}'",
          "token": "'${SGD_STABLECOIN}'",
          "amount": "1500000000000000000000",
          "action": "mint"
        }
      ],
      "fxRate": "1.5",
      "expiresAt": '$(($(date +%s) + 3600))'
    }
  }'
```

**Amount explanation:** `1500000000000000000000` represents 1500 SGD (1000 EUR
? 1.5 FX rate).

**Response:**

```json
{
  "settlementId": "12345",
  "transactionHash": "0xSWAP_TX_HASH",
  "status": "pending"
}
```

**Offchain reconciliation:**

- GM Malaysia Entity's liability to User A decreases (EUR stablecoin burned)
- GM Singapore Entity's liability to User B increases (SGD stablecoin minted)
- Official FX transaction executed between GM Malaysia Entity and GM Singapore
  Entity: MYR to SGD conversion at the specified rate

**Event monitoring:** Listen for XvP settlement events. See the [Event listening
architecture](#event-listening-architecture) section for implementation details.

### Step 3: User B withdraws SGD stablecoin

User B burns their SGD stablecoin, triggering an offchain SGD transfer from GM
Singapore Entity to User B's account.

**API call:**

```bash
curl -X POST http://localhost:3000/api/rpc/token.burn \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "address": "'${SGD_STABLECOIN}'",
      "from": "'${USER_B_WALLET}'",
      "amount": "1500000000000000000000"
    }
  }'
```

**Response:**

```json
{
  "transactionHash": "0xBURN_TX_HASH",
  "amount": "1500000000000000000000"
}
```

**Offchain reconciliation:**

- SGD stablecoin is burned, reducing GM Singapore Entity's liability to User
  B
- SGD is transferred from GM Singapore Entity to User B's account
- Cross-border settlement completes

**Event monitoring:** Listen for burn events (Transfer to zero address). See
the [Event listening architecture](#event-listening-architecture) section for
implementation details.

## Bond investment workflow

This workflow demonstrates how User B invests SGD in a bond, receives coupon
payments in EUR, and converts them to SGD through XvP swaps.

### Step 1: Mint bond in GM wallet

Mint the bond token to GM Malaysia Entity's wallet, representing the bond
inventory available for investment.

```bash
curl -X POST http://localhost:3000/api/rpc/token.mint \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "address": "'${BOND_TOKEN}'",
      "recipients": [
        {
          "to": "'${GM_MALAYSIA_WALLET}'",
          "amount": "100000000000000000000"
        }
      ]
    }
  }'
```

**Amount explanation:** `100000000000000000000` represents 100 bond tokens
(18 decimals: 100 ? 10^18).

### Step 2: Mint SGD stablecoin to User B

Simulate User B's SGD deposit by minting SGD stablecoin to their wallet. This
represents GM Singapore Entity's liability to User B.

```bash
curl -X POST http://localhost:3000/api/rpc/token.mint \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "address": "'${SGD_STABLECOIN}'",
      "recipients": [
        {
          "to": "'${USER_B_WALLET}'",
          "amount": "1000000000000000000000"
        }
      ]
    }
  }'
```

**Offchain reconciliation:**

- User B's SGD deposit transfers to GM Singapore Entity
- GM Singapore Entity's liability to User B increases by 1000 SGD
- Stablecoin balance reflects this liability on-chain

### Step 3: Create XvP swap: SGD for bond

Execute an XvP settlement that swaps User B's SGD stablecoin for GM Malaysia
Entity's bond tokens.

```bash
curl -X POST http://localhost:3000/api/rpc/xvp.createSettlement \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "participants": [
        {
          "address": "'${USER_B_WALLET}'",
          "token": "'${SGD_STABLECOIN}'",
          "amount": "1000000000000000000000",
          "action": "burn"
        },
        {
          "address": "'${GM_MALAYSIA_WALLET}'",
          "token": "'${BOND_TOKEN}'",
          "amount": "100000000000000000000",
          "action": "transfer"
        }
      ],
      "expiresAt": '$(($(date +%s) + 3600))'
    }
  }'
```

**Offchain reconciliation:**

- GM Singapore Entity's liability to User B decreases (SGD stablecoin burned)
- GM Malaysia Entity now holds liability for the bond investment
- Official FX transaction: GM Singapore Entity to GM Malaysia Entity, SGD to
  MYR conversion

**Event monitoring:** Listen for settlement execution events to trigger offchain
FX transaction creation.

### Step 4: Coupon payment distribution

At the coupon date, the bond's yield management system distributes EUR
stablecoin to bond holders (User B).

**Note:** The yield management system automatically distributes coupon payments
based on the bond's `denominationAsset` (EUR stablecoin). User B receives EUR
stablecoin in their wallet. This is typically handled by scheduled yield
distribution procedures.

**Query bond yield schedule:**

```bash
curl -X POST http://localhost:3000/api/rpc/fixedYieldSchedule.read \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "tokenAddress": "'${BOND_TOKEN}'"
    }
  }'
```

**Event monitoring for coupon payment:** Listen for yield distribution events
to detect when User B receives EUR stablecoin:

```bash
# Listen for yield distribution events via TheGraph subgraph
curl -X POST http://localhost:8000/subgraphs/name/atk/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query YieldDistributions($token: String!, $recipient: String!) { yieldDistributions(where: { token: $token, recipient: $recipient }) { id amount timestamp } }",
    "variables": {
      "token": "'${BOND_TOKEN}'",
      "recipient": "'${USER_B_WALLET}'"
    }
  }'
```

### Step 5: Convert coupon EUR to SGD

User B wants to receive SGD instead of EUR for the coupon payment. Create an
XvP swap to burn EUR stablecoin and mint SGD stablecoin.

**First, check User B's EUR balance:**

```bash
curl -X POST http://localhost:3000/api/rpc/token.read \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "address": "'${EUR_STABLECOIN}'"
    }
  }'
```

**Create coupon conversion swap:**

```bash
# Calculate coupon amount (example: 50 EUR)
COUPON_AMOUNT="50000000000000000000"  # 50 EUR (18 decimals)
SGD_AMOUNT="75000000000000000000"     # 75 SGD (50 EUR ? 1.5 rate)

curl -X POST http://localhost:3000/api/rpc/xvp.createSettlement \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "participants": [
        {
          "address": "'${USER_B_WALLET}'",
          "token": "'${EUR_STABLECOIN}'",
          "amount": "'${COUPON_AMOUNT}'",
          "action": "burn"
        },
        {
          "address": "'${USER_B_WALLET}'",
          "token": "'${SGD_STABLECOIN}'",
          "amount": "'${SGD_AMOUNT}'",
          "action": "mint"
        }
      ],
      "fxRate": "1.5",
      "expiresAt": '$(($(date +%s) + 3600))'
    }
  }'
```

**Offchain reconciliation:**

- GM Malaysia Entity's liability to User B (interest payment) transfers to GM
  Singapore Entity in SGD
- Official FX transaction: GM Malaysia Entity to GM Singapore Entity, MYR to
  SGD conversion for the coupon interest amount

## Event listening architecture

To automate offchain FX transaction creation, implement a robust event
listening system that monitors blockchain events and triggers reconciliation
workflows.

### WebSocket subscription pattern

Subscribe to blockchain events using WebSocket connections to your blockchain
node:

```bash
# Example: Connect to Besu WebSocket endpoint
wscat -c ws://localhost:8546

# Subscribe to Transfer events for stablecoin mints/burns
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "eth_subscribe",
  "params": [
    "logs",
    {
      "address": ["'${EUR_STABLECOIN}'", "'${SGD_STABLECOIN}'"],
      "topics": [
        "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"  # Transfer event signature
      ]
    }
  ]
}
```

### TheGraph subgraph queries

Query indexed events from TheGraph subgraph for reliable event processing:

**Transfer events (mints/burns):**

```bash
curl -X POST http://localhost:8000/subgraphs/name/atk/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query Transfers($token: String!, $from: String, $to: String) { transfers(where: { token: $token, from: $from, to: $to }, orderBy: timestamp, orderDirection: desc, first: 100) { id from to amount timestamp transactionHash } }",
    "variables": {
      "token": "'${EUR_STABLECOIN}'",
      "from": "0x0000000000000000000000000000000000000000"
    }
  }'
```

**XvP settlement events:**

```bash
curl -X POST http://localhost:8000/subgraphs/name/atk/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query Settlements($status: String) { settlements(where: { status: $status }, orderBy: executedAt, orderDirection: desc) { id participants { address token amount action } fxRate executedAt transactionHash } }",
    "variables": {
      "status": "executed"
    }
  }'
```

### Event handler implementation

Process events and trigger offchain FX transactions:

```bash
#!/bin/bash

# Process settlement event and create offchain FX transaction
process_settlement() {
  local SETTLEMENT_ID=$1
  
  # Query settlement details
  SETTLEMENT_DATA=$(curl -s -X POST http://localhost:8000/subgraphs/name/atk/graphql \
    -H "Content-Type: application/json" \
    -d "{
      \"query\": \"query GetSettlement(\$id: ID!) { settlement(id: \$id) { id participants { address token amount action } fxRate executedAt } }\",
      \"variables\": {\"id\": \"$SETTLEMENT_ID\"}
    }")
  
  # Extract settlement details (simplified - use jq for production)
  FROM_ENTITY=$(echo $SETTLEMENT_DATA | jq -r '.data.settlement.participants[0].address')
  TO_ENTITY=$(echo $SETTLEMENT_DATA | jq -r '.data.settlement.participants[1].address')
  FX_RATE=$(echo $SETTLEMENT_DATA | jq -r '.data.settlement.fxRate')
  
  # Determine FX transaction details
  if [[ "$FROM_ENTITY" == "$GM_MALAYSIA_WALLET" ]]; then
    FROM_CURRENCY="MYR"
    TO_CURRENCY="SGD"
  else
    FROM_CURRENCY="SGD"
    TO_CURRENCY="MYR"
  fi
  
  # Create offchain FX transaction record via your banking API
  curl -X POST https://your-banking-api.com/fx-transactions \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $BANKING_API_TOKEN" \
    -d "{
      \"settlementId\": \"$SETTLEMENT_ID\",
      \"fromEntity\": \"GM $(echo $FROM_ENTITY | cut -c1-8)\",
      \"toEntity\": \"GM $(echo $TO_ENTITY | cut -c1-8)\",
      \"fromCurrency\": \"$FROM_CURRENCY\",
      \"toCurrency\": \"$TO_CURRENCY\",
      \"fxRate\": \"$FX_RATE\",
      \"executedAt\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
    }"
}

# Monitor for new settlements (polling example)
while true; do
  # Query for new settlements
  NEW_SETTLEMENTS=$(curl -s -X POST http://localhost:8000/subgraphs/name/atk/graphql \
    -H "Content-Type: application/json" \
    -d '{
      "query": "query NewSettlements { settlements(where: { status: executed, processed: false }, first: 10) { id } }"
    }')
  
  # Process each settlement
  echo $NEW_SETTLEMENTS | jq -r '.data.settlements[].id' | while read settlement_id; do
    process_settlement "$settlement_id"
  done
  
  sleep 30  # Poll every 30 seconds
done
```

### Error handling and retry logic

Implement resilient error handling for API calls:

```bash
# Retry function with exponential backoff
retry_api_call() {
  local MAX_RETRIES=3
  local DELAY=1
  local RETRY_COUNT=0
  
  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if "$@"; then
      return 0
    fi
    
    RETRY_COUNT=$((RETRY_COUNT + 1))
    if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
      sleep $((DELAY * RETRY_COUNT))
    fi
  done
  
  echo "API call failed after $MAX_RETRIES retries" >&2
  return 1
}

# Usage
retry_api_call curl -X POST http://localhost:3000/api/rpc/token.mint \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{"input": {...}}'
```

## Observability integration

Monitor cross-border FX operations through the observability dashboards:

- **Transaction latency** ? Track API response times for mint, burn, and XvP
  settlement operations via Prometheus metrics
- **Settlement success rate** ? Monitor XvP settlement execution success/failure
  rates in Grafana dashboards
- **Event processing lag** ? Measure time between on-chain events and offchain
  reconciliation
- **FX transaction volume** ? Track total FX transaction value processed
  through the system

**Query Prometheus metrics:**

```bash
# API request duration
curl "http://localhost:9090/api/v1/query?query=orpc_request_duration_seconds"

# Settlement success rate
curl "http://localhost:9090/api/v1/query?query=rate(xvp_settlements_executed_total[5m])"
```

Access these metrics through the **Settlement Operations** dashboard in your
observability stack.

## Workflow validation

After executing workflows, validate correct operation:

1. **On-chain verification:**
   - Query token balances to confirm stablecoin balances match expected
     liabilities
   - Verify XvP settlements executed atomically
   - Check bond token ownership transferred correctly

**Check token balance:**

```bash
curl -X POST http://localhost:3000/api/rpc/token.read \
  -H "Content-Type: application/json" \
  -H "Cookie: ${SESSION_COOKIE}" \
  -d '{
    "input": {
      "address": "'${EUR_STABLECOIN}'"
    }
  }'
```

2. **Offchain reconciliation:**
   - Verify FX transactions created in banking system
   - Confirm entity liability records updated
   - Validate currency conversion amounts match FX rates

3. **Event processing:**
   - Confirm all expected events were captured via subgraph queries
   - Verify offchain transactions triggered correctly
   - Check for any missed events or processing delays

## Common issues and troubleshooting

**Issue: API returns 401 Unauthorized**

- **Solution:** Verify session cookie is valid and included in requests. Re-authenticate
  through web interface if cookie expired.

**Issue: XvP settlement fails due to insufficient balance**

- **Solution:** Verify both participants have sufficient token balances before
  creating the settlement. Check token balances via `token.read` endpoint.

**Issue: Events not triggering offchain reconciliation**

- **Solution:** Verify WebSocket connection stability, check event filter
  addresses match deployed contracts, and ensure event handlers are registered
  before transactions execute. Use TheGraph subgraph for reliable event querying.

**Issue: FX rate mismatch between on-chain and offchain**

- **Solution:** Implement FX rate synchronization from a trusted oracle before
  creating XvP settlements. Use `exchangeRates.sync` endpoint to update rates.

For additional troubleshooting guidance, see the
[Troubleshooting guide](/docs/user-guides/troubleshooting/transactions).

## Next steps

- Review [XvP settlement architecture](/docs/architecture/smart-contracts/addon-modules#xvp-settlement-atomic-cross-chain-delivery)
  for deeper technical understanding
- Explore [API reference](/docs/developer-guides/api-integration/api-reference)
  for complete endpoint documentation
- Configure [Observability dashboards](/docs/developer-guides/deployment-ops/observability-monitoring)
  for production monitoring
