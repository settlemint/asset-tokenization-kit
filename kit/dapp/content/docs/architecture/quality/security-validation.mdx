---
title: Security & validation
description:
  Security vulnerabilities that expose private keys end the business. ATK treats
  security validation as a continuous discipline, not a one-time audit before
  launch. Automated scanning runs on every commit. Manual reviews catch subtle
  issues. Penetration testing validates defenses. Incident response minimizes
  impact when things go wrong.
pageTitle: Security and validation
tags: [architecture, security, validation, testing, incident-response, concept]
---

Related topics:
[Testing and quality gates](/docs/architecture/quality/testing-quality),
[Compliance certification](/docs/architecture/quality/compliance-certification)

## Security validation cadence

Security validation operates across multiple time scales, creating overlapping
defense layers that feed into incident response. Continuous automated scans
catch common vulnerabilities immediately. Daily checks monitor dependencies and
secrets. Weekly manual reviews identify logic errors. Quarterly penetration
tests validate defenses under adversarial conditions. Annual comprehensive
audits provide third-party assurance for regulators and stakeholders.

<Mermaid
  chart={`flowchart TB
    Continuous(Continuous<br/>Automated Scans<br/>Every Commit)
    Daily(Daily<br/>Secret Scanning<br/>Dependency Checks)
    Weekly(Weekly<br/>Manual Code Reviews<br/>Security-Focused Reviews)
    Quarterly(Quarterly<br/>External Penetration Tests<br/>Bug Bounty Program)
    Annual(Annual<br/>Comprehensive Security Audits<br/>Regulatory Compliance)
    
    Incident(Incident Response<br/>Detection &amp; Resolution)
    Metrics(Security Metrics<br/>Dashboard &amp; Observability)
    
    Continuous --> Daily
    Daily --> Weekly
    Weekly --> Quarterly
    Quarterly --> Annual
    
    Continuous -.-> Incident
    Daily -.-> Incident
    Weekly -.-> Incident
    Quarterly -.-> Incident
    Annual -.-> Incident
    
    Continuous --> Metrics
    Daily --> Metrics
    Weekly --> Metrics
    Quarterly --> Metrics
    Annual --> Metrics
    
    Incident --> Metrics
    
    classDef primary fill:#5fc9bf,stroke:#3a9d96,stroke-width:2px,color:#fff
    classDef secondary fill:#6ba4d4,stroke:#4a7ba8,stroke-width:2px,color:#fff
    classDef tertiary fill:#8571d9,stroke:#654bad,stroke-width:2px,color:#fff
    classDef quaternary fill:#b661d9,stroke:#8a3fb3,stroke-width:2px,color:#fff
    
    class Continuous,Daily primary
    class Weekly,Quarterly secondary
    class Annual tertiary
    class Incident,Metrics quaternary
`}
/>

This layered validation model implements defense-in-depth security controls
required by audit frameworks including SOC 2 Type II and ISO 27001. Each
validation layer operates independently while feeding findings into centralized
security metrics dashboards. The observability stack surfaces vulnerability
trends, mean-time-to-remediation, and coverage statistics, providing audit
evidence of effective vulnerability management. When validation layers detect
issues, findings route through the incident response system for systematic
triage and remediation according to severity-based SLAs.

## Automated security scanning

Automated security scanning forms the first defense layer, executing on every
commit to detect vulnerabilities before code reaches production environments.
This continuous validation model aligns with regulatory requirements for secure
software development lifecycle (SSDLC) practices mandated by frameworks such as
SOC 2 Type II and ISO 27001. The observability stack surfaces scan results
through dedicated security metrics panels, allowing teams to track vulnerability
trends, mean-time-to-remediation, and coverage statistics across the codebase.

### Secret scanning

Accidentally committed secrets represent catastrophic security failures in
regulated financial systems. A single exposed private key grants attackers
complete control over token minting, burning, and compliance rule modifications.
Gitleaks ([GitHub](https://github.com/gitleaks/gitleaks)) scans every commit for
private keys, API tokens, and database credentials before the commit reaches the
remote repository. This pre-commit validation prevents even temporary exposure
in repository history, which matters because attackers continuously scan public
and private repositories for credential leaks.

The `.gitleaksignore` file permits known false positives such as test keys and
example configuration values, preventing alert fatigue while maintaining zero
tolerance for actual secrets. Pre-commit hooks execute Gitleaks locally before
developers push changes, creating defense-in-depth that protects even when
developers work in private repositories or feature branches. Security dashboards
display secret scan coverage metrics and alert on any detection failures,
ensuring the scanning infrastructure itself remains operational.

### Dependency scanning

Third-party dependencies introduce supply chain risk that regulatory frameworks
explicitly address. Trivy ([GitHub](https://github.com/aquasecurity/trivy))
scans Docker images and npm dependencies for known vulnerabilities (CVEs)
cataloged in the National Vulnerability Database. High and critical severity
findings block deployment pipelines until teams either patch the vulnerable
dependency or document risk acceptance with compensating controls. This aligns
with audit requirements for vulnerability management programs that demonstrate
timely remediation of security findings.

Renovate creates automated pull requests when dependency updates address
security vulnerabilities, reducing mean-time-to-patch through automation.
Security-classified updates merge within 24 hours after automated testing
passes, meeting regulatory expectations for rapid response to disclosed
vulnerabilities. The observability stack tracks dependency vulnerability metrics
including time-to-remediation histograms and percentage of dependencies with
known CVEs, providing audit evidence of effective vulnerability management.

All dependencies verify via cryptographic checksums and signatures during
installation. Unexpected changes to dependency hashes trigger security alerts
routed through the incident response system, detecting potential supply chain
attacks where malicious actors compromise package repositories. This validation
implements SLSA (Supply-chain Levels for Software Artifacts) framework
recommendations for verifying artifact integrity.

### Smart contract static analysis

Smart contract vulnerabilities enable direct theft of funds, making static
analysis non-negotiable for financial blockchain applications. Slither
([GitHub](https://github.com/crytic/slither)) analyzes Solidity contracts for
common vulnerability patterns including re-entrancy, unprotected self-destruct,
missing access control, and integer overflows. Unlike manual code review, static
analysis provides deterministic coverage of all code paths, meeting audit
requirements for systematic security analysis.

ATK implements custom Slither detectors targeting domain-specific risks inherent
to regulated security tokens. These detectors identify missing compliance checks
before token transfers, unvalidated identity claims that bypass KYC
requirements, and incorrect event emissions that break audit trail completeness.
Custom detectors encode organizational security policies as enforceable rules,
transforming compliance requirements into automated validation.

Slither executes on every pull request through GitHub Actions, with new findings
blocking merge approval until reviewed and resolved. Suppressed findings require
documented justification reviewed by security-focused engineers, creating an
audit trail demonstrating that security decisions receive appropriate oversight.
The security metrics dashboard displays Slither finding trends, resolution
velocity, and suppression rates, providing visibility into contract security
posture evolution over time.

## Manual security reviews

Automated tools excel at detecting known vulnerability patterns but fail to
identify logic errors, business rule violations, and context-dependent security
issues. Manual code review by experienced engineers catches subtle
vulnerabilities that require understanding system architecture, threat models,
and regulatory requirements. This layered approach—automated scanning plus
manual review—implements defense-in-depth security controls required by audit
frameworks.

### Code review process

Every pull request requires approval from at least one senior engineer before
merging. Reviewers examine code changes for correct usage of cryptographic
primitives, proper input validation and sanitization, safe handling of user
funds and private data, and adherence to the principle of least privilege. This
process catches security issues that static analysis tools miss, such as
authorization logic errors where code is syntactically correct but semantically
insecure.

Code review serves as knowledge transfer, ensuring multiple engineers understand
security-critical code paths. This redundancy protects against key person risk
where a single engineer's departure leaves security vulnerabilities
undiscovered. Review discussions documented in pull request comments create a
decision history explaining why specific security approaches were chosen,
valuable context for future modifications and security audits.

### Security-focused reviews

Changes to smart contracts, authentication logic, or cryptographic operations
trigger additional review by engineers with security audit experience. These
specialized reviews apply deeper threat modeling and consider attack vectors
beyond common vulnerability checklists. The elevated review threshold recognizes
that these code paths directly protect user assets and regulatory compliance,
where failures have severe consequences.

Contract modifications undergo validation for access control on privileged
functions, correct modifier usage and inheritance chains, safe external calls
with re-entrancy protection, and complete event emissions for audit trails.
Reviewers verify that role-based access control (RBAC) correctly restricts
functions such as `mint()`, `burn()`, and `freezeAccount()` to authorized
addresses, preventing unauthorized token manipulation. Event emission validation
ensures that off-chain indexers and audit systems can reconstruct complete
transaction histories from blockchain event logs.

Authentication and authorization changes receive security team approval before
merging. Reviewers validate correct session lifecycle management, secure token
generation and validation using cryptographically strong random number
generators, appropriate rate limiting and abuse prevention mechanisms, and
proper CSRF and XSS protection. These controls protect against account takeover
attacks that would allow attackers to bypass identity verification and
compliance restrictions. The authentication review dashboard tracks review
velocity and finding severity distributions, providing metrics for security team
capacity planning.

Cryptographic operations undergo expert review by engineers with cryptography
backgrounds. Reviewers validate correct algorithm selection for specific use
cases (e.g., ECDSA for signatures, AES-256-GCM for encryption), proper key
generation and storage following NIST recommendations, safe nonce generation and
signature verification that prevents replay attacks, and timing attack
prevention in comparison operations. Cryptography errors are notoriously
difficult to detect through testing and often remain dormant until exploited,
making expert review essential.

## Penetration testing

Penetration testing validates that implemented security controls function
correctly under adversarial conditions. Unlike automated scanning that checks
for known vulnerability patterns, penetration testing simulates real-world
attacks to discover unknown vulnerabilities and test incident detection and
response capabilities. Regulatory frameworks including SOC 2 and PCI DSS mandate
periodic penetration testing by qualified security assessors, making this
validation both security best practice and compliance requirement.

### Periodic security audits

External security firms conduct comprehensive penetration tests quarterly,
receiving full access to the codebase and test environments. This third-party
validation provides independent assessment of security posture, reducing bias
inherent in internal testing where developers subconsciously avoid testing their
own code's weaknesses. Quarterly frequency balances thorough testing depth with
manageable remediation workload, allowing teams to address findings before the
next audit cycle.

Audit scope encompasses smart contract security examining re-entrancy
vulnerabilities, access control bypasses, and economic exploits such as flash
loan attacks. API security testing targets injection attacks, authorization
bypasses, and business logic flaws. Frontend security assessment identifies XSS,
CSRF, and session hijacking vulnerabilities. Infrastructure security evaluation
validates network segmentation, secrets management, and defense-in-depth
controls. This comprehensive scope ensures that attackers cannot compromise the
platform through overlooked attack surfaces.

Finding remediation follows severity-based SLAs that balance security risk
against operational constraints. Critical findings enabling theft of funds
require remediation within 24 hours, potentially through emergency hotfixes and
contract pause mechanisms. High severity findings with significant impact demand
resolution within 7 days. Medium impact findings receive 30-day remediation
windows, while informational findings allow 90-day resolution. These SLAs align
with industry standards and regulatory expectations while remaining
operationally achievable. The incident metrics dashboard displays remediation
velocity trends and SLA compliance rates, providing audit evidence of effective
vulnerability management.

### Bug bounty program

Public bug bounty programs incentivize responsible disclosure by external
security researchers, effectively crowdsourcing security testing across a global
researcher community. Researchers receive financial rewards for discovering and
responsibly reporting vulnerabilities, aligning their incentives with platform
security rather than exploit development. This approach discovers
vulnerabilities that internal teams and external auditors miss due to different
perspectives and testing methodologies.

Reward structures scale with vulnerability severity and potential impact.
Critical vulnerabilities enabling theft of funds warrant rewards from $10,000 to
$50,000, reflecting the severity and potential damage. High severity findings
yield $2,500 to $10,000. Medium severity issues receive $500 to $2,500. Low
severity and informational findings earn $100 to $500. These reward levels
attract skilled researchers while remaining financially sustainable for the
organization.

Program scope covers production smart contracts, APIs, and infrastructure while
prohibiting activities that harm users or operations. Researchers must avoid
accessing user data beyond their own accounts, performing denial-of-service
attacks, social engineering employees or users, and physical attacks on
infrastructure. These boundaries protect legitimate users while allowing
thorough security testing.

Researchers receive acknowledgment within 24 hours of submission and initial
triage within 48 hours, demonstrating respect for researcher time and
encouraging continued participation. Valid findings progress through remediation
according to severity-based SLAs. Public disclosure occurs after fixes deploy
and affected users receive notification, balancing transparency with responsible
disclosure that prevents exploit window expansion. The security dashboard tracks
bug bounty program metrics including submission volumes, payout totals, and
time-to-resolution, demonstrating effective vulnerability management to auditors
and regulators.

## Regulatory compliance testing

Financial regulations impose strict requirements that automated testing
validates continuously. Transfer restrictions, identity verification, audit
trail completeness, and role-based access control represent compliance controls
where failures trigger regulatory sanctions, fines, and potential license
revocation. Comprehensive test suites provide audit evidence demonstrating that
compliance controls function correctly and consistently. See
[Compliance certification](/docs/architecture/quality/compliance-certification)
for certification details covering regulatory frameworks and audit procedures.

### Transfer restriction enforcement

ERC-3643 compliance tests validate that every asset type correctly enforces
regulatory transfer restrictions. Identity verification tests confirm that
non-verified addresses cannot receive tokens, preventing transfers to
individuals who have not completed KYC processes. Country restriction tests
verify that transfers to blocked jurisdictions revert with descriptive error
messages, implementing sanctions and geographic limitations. Investor limit
tests ensure that transfers exceeding regulatory caps (e.g., maximum 2,000
investors per Regulation D offering) revert before state changes occur. Lock-up
period tests validate that time-locked tokens cannot transfer until unlock
dates, enforcing contractual and regulatory holding periods. Frozen address
tests confirm that compliance officers can freeze addresses and that frozen
addresses cannot send or receive tokens, enabling regulatory enforcement
actions.

Compliance modules test independently and in combination, verifying that
multiple restrictions compose correctly. For example, tests confirm that country
restrictions AND investor limits both apply when evaluating transfer
eligibility, preventing bypasses through partial validation. This combinatorial
testing reflects real-world regulatory environments where multiple restrictions
simultaneously govern token transfers. The compliance metrics dashboard displays
rule evaluation statistics, including rejection rates by rule type and
performance characteristics, demonstrating that compliance enforcement operates
efficiently at scale.

Negative testing explicitly attempts to bypass restrictions using various attack
vectors including direct contract calls that skip frontend validation, multicall
batching that combines operations to exploit race conditions, flash loans that
temporarily manipulate balances or state, and re-entrancy attacks that re-enter
contracts during external calls. All bypass attempts must fail with appropriate
error messages. These adversarial tests validate that security controls function
correctly even when attackers deliberately attempt circumvention, providing high
confidence in compliance enforcement robustness.

### Identity and KYC validation

OnchainID integration tests verify the complete identity verification flow from
initial registration through claim validation during transfers. Tests simulate
creating identity contracts for new investors, compliance officers adding KYC
claims to identities, trusted issuers signing claims cryptographically, identity
registries validating claim signatures and issuer trust relationships, and token
transfers succeeding only after complete claim validation passes. This
end-to-end validation ensures that the complex multi-party identity verification
process functions correctly in production.

Claim expiration handling tests validate that expired claims trigger
re-verification requirements. An investor verified in January cannot transfer
tokens in December if their KYC claim expired in June, ensuring that identity
verification remains current. This addresses regulatory requirements for
periodic re-verification of customer identities. Tests confirm that the system
correctly detects expiration, blocks transfers, and guides investors through
re-verification processes.

Claim revocation tests verify that compliance officers can revoke claims when
circumstances change, such as an investor moving to a sanctioned country. Tests
confirm that revoked claims immediately prevent transfers without requiring
contract upgrades or manual intervention. This real-time enforcement capability
meets regulatory expectations for immediate response to compliance status
changes. The identity metrics dashboard displays claim lifecycle statistics
including issuance rates, expiration frequencies, and revocation reasons,
providing audit evidence of effective identity management.

### Audit trail completeness

Event emission tests validate that every state-changing operation emits events
capturing the operation details. Mint operations emit
`Transfer(address(0), recipient, amount)` events documenting token creation.
Burn operations emit `Transfer(account, address(0), amount)` events recording
token destruction. Compliance updates emit `ComplianceModuleUpdated` or similar
events tracking rule changes. Identity updates emit `IdentityRegistryUpdated`
events documenting verification status modifications. Complete event coverage
enables audit reconstruction of all platform activities from blockchain event
logs.

Event parameter accuracy tests validate that events include all necessary data
for audit reconstruction including token IDs, amounts, addresses, timestamps,
and transaction hashes. Incomplete events break audit trails, preventing
investigators from understanding what occurred during specific transactions.
Tests confirm that event parameters accurately reflect operation semantics,
enabling reliable audit analysis. The audit metrics dashboard displays event
emission statistics and coverage percentages, demonstrating comprehensive
logging to auditors.

Subgraph integration tests verify that the indexing layer correctly processes
all events and reconstructs complete transaction histories. Auditors can query
the subgraph to generate compliance reports without parsing raw blockchain data,
simplifying audit procedures and reducing analysis time. Tests confirm that
complex multi-step transactions index correctly and that the subgraph maintains
consistency with on-chain state. This validation ensures that the audit
infrastructure functions reliably in production environments.

### Role-based access control

Permission boundary tests validate that each role—investor, compliance officer,
issuer, administrator—possesses only authorized permissions. Investors can
transfer tokens but cannot mint, burn, or freeze accounts, preventing
unauthorized token manipulation. Compliance officers can freeze accounts but
cannot mint or burn tokens, separating enforcement from issuance. Issuers can
mint and burn tokens but cannot modify compliance rules, preventing
self-interested rule changes. Administrators can modify compliance rules but
must follow governance timelock delays, ensuring that critical changes receive
appropriate oversight.

Permission escalation prevention tests attempt to escalate privileges using
various attack techniques including front-running transactions to exploit race
conditions, re-entrancy attacks to manipulate call contexts, and signature
replay to reuse authorization credentials. All escalation attempts must fail,
demonstrating that access control enforcement remains robust under adversarial
conditions. These tests validate that the role-based access control
implementation prevents real-world attack patterns.

Multi-signature enforcement tests verify that critical operations including
contract upgrades and compliance rule changes require multiple signature
approvals before execution. Tests confirm that operations revert until the
required signature threshold accumulates and that signatures cannot be replayed
or manipulated. Multi-signature requirements implement separation of duties
controls mandated by regulatory frameworks, preventing single individuals from
unilaterally executing high-impact operations. The RBAC metrics dashboard
displays permission usage patterns and access denial statistics, demonstrating
that least-privilege principles operate effectively in production.

## Incident response

Production security incidents occur despite comprehensive preventive measures,
making structured incident response processes essential for minimizing impact.
Rapid detection, systematic triage, effective remediation, and clear
communication distinguish professional incident management from chaotic crisis
response. Regulatory frameworks mandate documented incident response
capabilities, making this operational discipline both security best practice and
compliance requirement.

### Incident detection

Automated alerting through Prometheus monitors platform metrics continuously,
triggering notifications when thresholds indicate potential security incidents.
Error rate alerts fire when failures exceed 1%, indicating potential attacks or
system compromise. Response time alerts trigger when P95 latency exceeds 500ms,
potentially signaling resource exhaustion attacks. Database connection pool
saturation alerts activate above 80% utilization, warning of connection
exhaustion. These operational metrics provide early warning of security
incidents manifesting as performance degradation or service failures. The
security operations dashboard displays alert firing rates, escalation paths, and
acknowledgment times, enabling incident response optimization.

User-reported issues flow through dedicated support channels where triage teams
prioritize by severity. P0 incidents involve funds at risk, triggering immediate
escalation to on-call engineers. P1 incidents describe broken features affecting
functionality, receiving rapid but non-emergency response. P2 incidents report
cosmetic issues warranting resolution in normal development cycles. This
severity classification ensures that security-critical incidents receive
appropriate urgency while preventing alert fatigue from low-severity issues.

Security-specific monitoring tracks indicators of potential compromise including
failed authentication attempts exceeding rate limits (potential credential
stuffing attacks), unusual transaction patterns such as high values or rapid
succession (potential automated exploitation), smart contract function calls
from unexpected addresses (potential unauthorized access), and administrative
interface access attempts from unknown sources (potential intrusion). These
behavioral signals detect attacks that operational metrics miss, providing
defense-in-depth for incident detection. Security event correlation panels
aggregate these signals, enabling security operations centers to identify attack
campaigns targeting the platform.

### Incident resolution

Documented runbooks provide step-by-step procedures for resolving common
incidents including database failover, API rollback, and blockchain
re-organization handling. Runbooks specify expected outcomes at each step,
enabling responders to verify correct progress. Rollback procedures ensure that
failed remediation attempts can be reversed safely. This documentation reduces
resolution time and minimizes mistakes during high-stress incident response when
improvisation leads to errors.

Security-specific runbooks cover smart contract pause and upgrade procedures
enabling rapid threat containment, private key compromise response including key
rotation and transaction revocation, unauthorized access containment through
session termination and permission revocation, and data breach notification and
mitigation following regulatory disclosure requirements. These procedures
translate security policies into executable action plans, ensuring consistent
response regardless of which team members respond. The incident response
dashboard tracks runbook execution frequency and effectiveness metrics,
identifying gaps requiring improved procedures or automation.

Communication protocols designate personnel responsible for stakeholder
communication during incidents. Internal teams including engineering, legal, and
compliance receive technical updates enabling coordinated response. External
stakeholders including customers and regulators receive timely notifications
meeting legal disclosure requirements. Security researchers involved in
responsible disclosure receive coordinated updates throughout remediation.
Structured communication prevents information gaps that lead to stakeholder
confusion and regulatory sanctions.

### Blameless postmortems

Blameless postmortem analysis following incident resolution identifies root
causes and implements preventive measures without assigning individual blame.
The goal is understanding system failures and improving defenses, not punishing
individuals. This approach encourages honest reporting and thorough analysis,
improving organizational learning from incidents. Regulatory frameworks value
demonstrated continuous improvement, making postmortem processes audit evidence
of effective security culture.

Postmortem documentation follows structured formats capturing timeline of events
with timestamps and actor identities, root cause analysis using techniques such
as five-whys or fishbone diagrams, impact assessment quantifying affected users
and financial damage, positive aspects including effective detection or response
activities, negative aspects identifying gaps in monitoring, tooling, or
documentation, and concrete action items implementing preventive measures. This
systematic analysis produces actionable insights rather than narrative
descriptions.

Preventive measures derived from postmortems add new test cases covering
discovered vulnerabilities, improve monitoring and alerting to detect similar
issues faster, update documentation removing ambiguity that contributed to
failures, and redesign systems eliminating root cause vulnerabilities. Action
items receive tracking and prioritization equivalent to feature development,
ensuring that lessons learned translate into actual security improvements. The
postmortem metrics dashboard displays incident recurrence rates and action item
completion velocity, demonstrating that the organization systematically improves
security posture over time.

Knowledge sharing distributes postmortem findings across the engineering
organization with sensitive details redacted to protect privacy. Teams learn
from incidents affecting other systems, applying lessons to their own
architectures. This cross-team learning multiplies incident value by preventing
similar failures in different components. The culture of transparency and
continuous improvement that postmortems create represents a maturity indicator
that auditors and regulators value when assessing organizational security
capabilities.

## Conclusion

Security validation in ATK operates as a continuous discipline integrating
automated scanning, manual review, penetration testing, compliance verification,
and incident response into a comprehensive defense-in-depth strategy. Automated
tools catch common vulnerabilities efficiently. Manual reviews identify subtle
logic errors and context-dependent risks. Penetration testing validates that
defensive controls function under adversarial conditions. Compliance testing
provides audit evidence of regulatory control effectiveness. Incident response
minimizes impact when prevention inevitably fails.

This multi-layered approach enables ATK to operate in regulated financial
markets where security failures trigger severe consequences including financial
loss, regulatory sanctions, and reputation damage. Security teams trust that
vulnerabilities are detected and patched systematically. Operations teams trust
that incidents receive professional handling following documented procedures.
Auditors trust that comprehensive validation evidence demonstrates control
effectiveness. This trust enables organizations to confidently deploy
blockchain-based financial platforms that meet stringent regulatory
requirements.

For broader quality assurance practices, see
[Testing and quality gates](/docs/architecture/quality/testing-quality). For
compliance certification requirements and audit procedures, see
[Compliance certification](/docs/architecture/quality/compliance-certification).
