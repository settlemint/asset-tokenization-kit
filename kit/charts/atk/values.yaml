# Default values for atk.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext:
  {}
  # fsGroup: 2000

securityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 80

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources:
  {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /
    port: http
readinessProbe:
  httpGet:
    path: /
    port: http

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

besu-validator-1:
  enabled: true
  fullnameOverride: besu-node-validator-1

besu-validator-2:
  enabled: true
  fullnameOverride: besu-node-validator-2

besu-validator-3:
  enabled: true
  fullnameOverride: besu-node-validator-3

besu-validator-4:
  enabled: true
  fullnameOverride: besu-node-validator-4

besu-rpc-1:
  enabled: true
  fullnameOverride: besu-node-rpc-1
  node:
    besu:
      account:
        password: "password"

besu-rpc-2:
  enabled: true
  fullnameOverride: besu-node-rpc-2
  node:
    besu:
      account:
        password: "password"

erpc:
  enabled: true
  fullnameOverride: besu-loadbalancer

postgresql-ha:
  enabled: true
  fullnameOverride: postgresql
  postgresql:
    username: "postgres"
    password: "atk"
    repmgrUsername: repmgr
    repmgrPassword: "atk"
    initdbScripts:
      create_blockscout_db.sql: |
        CREATE DATABASE blockscout;
        CREATE USER blockscout WITH PASSWORD 'atk' SUPERUSER;
        GRANT ALL PRIVILEGES ON DATABASE blockscout TO blockscout;
        \c blockscout;
        GRANT ALL ON SCHEMA public TO blockscout;
        CREATE DATABASE thegraph WITH ENCODING 'UTF8' LC_COLLATE='C' LC_CTYPE='C' TEMPLATE template0;
        CREATE USER thegraph WITH PASSWORD 'atk' SUPERUSER;
        GRANT ALL PRIVILEGES ON DATABASE thegraph TO thegraph;
        \c thegraph;
        GRANT ALL ON SCHEMA public TO thegraph;
        CREATE DATABASE hasura;
        CREATE USER hasura WITH PASSWORD 'atk' SUPERUSER;
        GRANT ALL PRIVILEGES ON DATABASE hasura TO hasura;
        \c hasura;
        GRANT ALL ON SCHEMA public TO hasura;
        CREATE DATABASE portal;
        CREATE USER portal WITH PASSWORD 'atk' SUPERUSER;
        GRANT ALL PRIVILEGES ON DATABASE portal TO portal;
        \c portal;
        GRANT ALL ON SCHEMA public TO portal;
  pgpool:
    adminUsername: "pgpool"
    adminPassword: "atk"
    customUsers:
      usernames: "blockscout,hasura,thegraph,portal"
      passwords: "atk,atk,atk,atk"
    maxPool: 100
    numInitChildren: 100
    resourcesPreset: medium

blockscout-stack:
  enabled: true
  fullnameOverride: blockscout
  config:
    prometheus:
      enabled: false
      blackbox:
        enabled: false
    network:
      id: 53771311147
      name: Asset Tokenization Kit
      shortname: ATK
      currency:
        name: Native Token
        symbol: NT
        decimals: 18
  blockscout:
    image:
      repository: blockscout/blockscout
      tag: "7.0.2"
    ingress:
      enabled: true
      className: "settlemint-nginx"
      hostname: explorer.k8s.orb.local
    env:
      NETWORK: "mainnet"
      SUBNETWORK: "ATK"
      ETHEREUM_JSONRPC_VARIANT: besu
      ETHEREUM_JSONRPC_HTTP_INSECURE: 'true'
      ETHEREUM_JSONRPC_HTTP_GZIP_ENABLED: 'true'
      SHOW_TXS_CHART: 'true'
      TXS_STATS_ENABLED: 'true'
      OTHER_EXPLORERS: '{}'
      SUPPORTED_CHAINS: '{}'
      ADMIN_PANEL_ENABLED: 'true'
      EMISSION_FORMAT: 'DEFAULT'
      FETCH_REWARDS_WAY: 'trace_block'
      DISABLE_EXCHANGE_RATES: 'true'
      ECTO_USE_SSL: 'false'
      POOL_SIZE: '10'
      POOL_SIZE_API: '10'
      POOL_TIMEOUT: '30000'
      POOL_MAX_OVERFLOW: '40'
      ECTO_ADAPTER_TIMEOUT: '60000'
      DATABASE_TIMEOUT: '60000'
      QUEUE_TARGET: '5000'
      QUEUE_INTERVAL: '1000'
      MIX_ENV: 'prod'
      API_GRAPHQL_MAX_COMPLEXITY: '1000'
      INDEXER_DISABLE_INTERNAL_TRANSACTIONS_FETCHER: 'false'
      IPFS_GATEWAY_URL: 'https://ipfs.io/ipfs'
      IPFS_PUBLIC_GATEWAY_URL: 'https://ipfs.io/ipfs'
      INDEXER_TOKEN_INSTANCE_RETRY_MAX_REFETCH_INTERVAL: '1h'
      INDEXER_TOKEN_INSTANCE_USE_BASE_URI_RETRY: 'true'
      API_URL: https://explorer.k8s.orb.local
      WEBAPP_URL: https://explorer.k8s.orb.local
      BLOCKSCOUT_PROTOCOL: 'https'
    envFromSecret:
      DATABASE_URL: postgresql://blockscout:atk@postgresql-pgpool:5432/blockscout?sslmode=disable
      ETHEREUM_JSONRPC_HTTP_URL: http://besu-loadbalancer:4000
      ETHEREUM_JSONRPC_TRACE_URL: http://besu-loadbalancer:4000
      SECRET_KEY_BASE: atk
  frontend:
    image:
      repository: ghcr.io/blockscout/frontend
      tag: "v1.38.2"
    replicaCount: 1
    env:
      NEXT_PUBLIC_IS_ACCOUNT_SUPPORTED: 'false'
      NEXT_PUBLIC_IS_TESTNET: 'false'
      NEXT_PUBLIC_AD_BANNER_PROVIDER: 'none'
      NEXT_PUBLIC_AD_TEXT_PROVIDER: 'none'
      NEXT_PUBLIC_HAS_BEACON_CHAIN: 'false'
      NEXT_PUBLIC_TRANSACTION_INTERPRETATION_PROVIDER: 'blockscout'
      NEXT_PUBLIC_HOMEPAGE_CHARTS: '["daily_txs"]'
      NEXT_PUBLIC_HOMEPAGE_STATS: '["total_blocks","average_block_time","total_txs","wallet_addresses","gas_tracker"]'
      NEXT_PUBLIC_PROMOTE_BLOCKSCOUT_IN_TITLE: 'false'
      NEXT_PUBLIC_OG_ENHANCED_DATA_ENABLED: 'true'
      NEXT_PUBLIC_SEO_ENHANCED_DATA_ENABLED: 'true'
      NEXT_PUBLIC_HAS_CONTRACT_AUDIT_REPORTS: 'true'
      NEXT_PUBLIC_FONT_FAMILY_HEADING: "{'name':'Figtree','url':'https://fonts.googleapis.com/css2?family=Figtree:ital,wght@0,300..900;1,300..900&display=swap'}"
      NEXT_PUBLIC_FONT_FAMILY_BODY: "{'name':'Figtree','url':'https://fonts.googleapis.com/css2?family=Figtree:ital,wght@0,300..900;1,300..900&display=swap'}"
    ingress:
      enabled: true
      className: "settlemint-nginx"
      hostname: explorer.k8s.orb.local

# https://github.com/kubernetes/ingress-nginx/blob/main/charts/ingress-nginx/values.yaml
ingress-nginx:
  enabled: true
  fullnameOverride: 'ingress-nginx'
  defaultBackend:
    enabled: false
  controller:
    allowSnippetAnnotations: true
    runAsUser: 2016
    admissionWebhooks:
      enabled: false
    replicaCount: 1
    autoscaling:
      enabled: true
      minReplicas: 1
      maxReplicas: 10
      targetCPUUtilizationPercentage: 80
      targetMemoryUtilizationPercentage: 80
      behaviour:
        scaleDown:
          stabilizationWindowSeconds: 300
          policies:
            - type: Pods
              value: 1
              periodSeconds: 180
        scaleUp:
          stabilizationWindowSeconds: 0
          policies:
            - type: Pods
              value: 2
              periodSeconds: 60
    updateStrategy:
      type: RollingUpdate
      rollingUpdate:
        maxSurge: "100%"
        maxUnavailable: "0%"
    resources:
      requests:
        cpu: 250m
        memory: 768Mi
    podLabels:
      kots.io/app-slug: settlemint-platform
    podAnnotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "10254"
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                  - key: app.kubernetes.io/component
                    operator: In
                    values:
                      - controller
                  - key: app.kubernetes.io/name
                    operator: In
                    values:
                      - ingress-nginx
              topologyKey: kubernetes.io/hostname
    config:
      proxy-body-size: '500M'
      http2-push-preload: 'true'
      proxy-send-timeout: '3600'
      proxy-read-timeout: '3600'
      proxy-buffering: 'on'
      proxy-buffer-size: '128k'
      proxy-buffers-number: '4'
      proxy-max-temp-file-size: '1024m'
      client-body-buffer-size: '128k'
      tcp-fast-open: '3000'
      worker-processes: auto
      max-worker-connections: '65536'
      upstream-keepalive-connections: '64'
      upstream-keepalive-timeout: '120'
      limit-req-status-code: '429'
      use-http2: 'true'
      use-forwarded-headers: 'false'
      log-format-escape-json: 'true'
      log-format-upstream: '{"proxyUpstreamName": "$proxy_upstream_name", "httpRequest":{"requestMethod": "$request_method", "requestUrl": "$host$request_uri", "status": $status, "requestBody": "${request_body_filtered}"}, "cloudflare": {"cfConnectingIp": "$http_cf_connecting_ip", "cfIpCountry": "$http_cf_ipcountry", "cfRay": "$http_cf_ray", "trueClientIp": "$http_true_client_ip"}, "meta": {"timestamp": "$time_iso8601", "latency": "$upstream_response_time s", "requestID": "$req_id", "requestSize": "$request_length", "responseSize": "$upstream_response_length", "userAgent": "$http_user_agent", "referer": "$http_referer", "protocol":"$server_protocol", "proxyAlternativeUpstreamName": "$proxy_alternative_upstream_name", "upstreamStatus": "$upstream_status", "upstreamAddr": "$upstream_addr", "cfVisitor": "$http_cf_visitor", "cfRequestId": "$http_cf_request_id"}}'
      ignore-invalid-headers: 'false'
      enable-underscores-in-headers: 'true'
      annotations-risk-level: Critical
      ssl-ciphers: 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:AES128-GCM-SHA256:AES128-GCM-SHA384'
      nginx-status-ipv4-whitelist: '0.0.0.0'
      http-snippet: |
        lua_need_request_body on;

        map $status $request_body_filtered {
            204     "";
            default $request_body_binary_check;
        }

        map $request_body $request_body_binary_check {
            ~[^[:print:]]  "[binary data]";
            default       $request_body;
        }

        server {
            listen 18080;

            location /nginx_status {
                allow all;
                stub_status on;
            }
            location / {
                return 404;
            }
        }
      ssl-redirect: 'false'
      enable-opentelemetry: 'true'
      enable-access-log-for-default-backend: 'true'
      otlp-collector-host: 'o11y-alloy'
      otlp-collector-port: '4317'
      otel-sampler: AlwaysOn
      otel-sampler-ratio: '1.0'
      otel-sampler-parent-based: 'false'
      opentelemetry-trust-incoming-span: 'true'
      otel-max-queuesize: '2048'
      otel-schedule-delay-millis: '5000'
      otel-max-export-batch-size: '512'
      enable-brotli: 'true'
      proxy_next_upstream: 'error timeout http_500 http_502 http_503 http_504'
      proxy_next_upstream_timeout: '30'
      proxy_next_upstream_tries: '3'
    extraArgs:
      enable-ssl-passthrough: 'true'
    service:
      externalTrafficPolicy: "Local" # Use if not ClusterIP
      type: LoadBalancer # Or ClusterIP if there is an external LB
      annotations:
        external-dns.alpha.kubernetes.io/hostname: 'settlemint.local, *.settlemint.local'
        external-dns.alpha.kubernetes.io/cloudflare-proxied: 'true'
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: 'tcp'
        service.beta.kubernetes.io/aws-load-balancer-type: 'external'
        service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: 'ip'
        service.beta.kubernetes.io/aws-load-balancer-scheme: 'internet-facing'
        service.beta.kubernetes.io/azure-load-balancer-disable-tcp-reset: 'true'
        service.beta.kubernetes.io/azure-load-balancer-tcp-idle-timeout: '30'
        service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path: '/healthz'
    ingressClassResource:
      # -- If you run more than one platform versions on a single cluster, you need to make sure these are unique
      name: settlemint-nginx
      enabled: true
      default: false
      controllerValue: 'k8s.io/settlemint-nginx'
    ingressClass: settlemint-nginx
    opentelemetry:
      enabled: true
      image:
        registry: registry.k8s.io
    patch:
      image:
        registry: registry.k8s.io
    metrics:
      enabled: true
      service:
        labels:
          kots.io/app-slug: settlemint-platform
        annotations:
          prometheus.io/scrape: 'true'
          prometheus.io/port: '10254'

# https://github.com/stakater/Reloader/blob/master/deployments/kubernetes/chart/reloader/values.yaml
reloader:
  enabled: false
  fullnameOverride: 'reloader'
  reloader:
    autoReloadAll: true
    watchGlobally: false
    readOnlyRootFileSystem: true
    reloadOnCreate: true
    syncAfterRestart: true
    securityContext:
      # -- Specifies the security capabilities for the container. Here, all capabilities are dropped.
      capabilities:
        drop:
          - ALL
      # -- If true, the root filesystem of the container is read-only.
      readOnlyRootFilesystem: false
      # -- Ensures the container runs as a non-root user.
      runAsNonRoot: true
      # -- The user ID to run the container as. Change this for OpenShift or specific requirements.
      runAsUser: 2016
      allowPrivilegeEscalation: false
    containerSecurityContext:
      capabilities:
        drop:
          - ALL
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
    deployment:
      labels:
        kots.io/app-slug: settlemint-platform

# https://github.com/cert-manager/cert-manager/blob/master/deploy/charts/cert-manager/values.yaml
cert-manager:
  enabled: false
  fullnameOverride: 'cert-manager'
  crds:
    enabled: true
  resources:
    limits:
      memory: 100Mi
    requests:
      memory: 100Mi
      cpu: 10m
  webhook:
    resources:
      limits:
        memory: 50Mi
      requests:
        memory: 10Mi
        cpu: 10m
  cainjector:
    resources:
      limits:
        memory: 128Mi
      requests:
        memory: 128Mi
        cpu: 10m
  prometheus:
    enabled: true


graph-node:
  enabled: true
  fullnameOverride: graph-node
  customSecret:
    PGUSER: thegraph
    PGPASSWORD: atk
  graphNodeDefaults:
    # -- Environment variable defaults for all Graph Node groups
    env:
      # -- Hostname of the primary shard PostgreSQL server
      PRIMARY_SUBGRAPH_DATA_PGHOST: postgresql-pgpool
      # -- Port for the primary shard PostgreSQL server
      PRIMARY_SUBGRAPH_DATA_PGPORT: 5432
      # -- Name of the primary shard database to use
      PRIMARY_SUBGRAPH_DATA_PGDATABASE: "thegraph"
      # -- The URL for your IPFS node
      IPFS: "https://ipfs.console.settlemint.com"
    secretEnv:
      PRIMARY_SUBGRAPH_DATA_PGUSER:
        # -- Name of the secret that contains your PG username
        secretName: thegraph-pg-secret
        # -- Name of the data key in the secret that contains your PG username
        key: PGUSER
      PRIMARY_SUBGRAPH_DATA_PGPASSWORD:
        # -- Name of the secret that contains your PG password
        secretName: thegraph-pg-secret
        # -- Name of the data key in the secret that contains your PG password
        key: PGPASSWORD
  graphNodeGroups:
    query:
      enabled: true
      replicaCount: 1
      env:
        node_role: query-node # this key must be lowercase

  # -- Blockchain configuration for Graph Node
  chains:
    # -- Ethereum Mainnet
    settlemint:
      # -- Enable this configuring graph-node with this chain
      enabled: true
      # -- The database shard to use for this chain
      shard: primary
      ## -- A list of JSON-RPC endpoints for this node (you should override this list with your own configuration)
      provider:
        -
          # -- Label for a JSON-RPC endpoint
          label: erpc
          details:
            # -- Type of Provider: web3
            type: web3
            # -- URL for JSON-RPC endpoint
            url: http://besu-loadbalancer:4000
            # -- Data capabilities this node has
            features: [archive, traces]
  ingress:
    enabled: true
    className: "settlemint-nginx"
    annotations:
      nginx.ingress.kubernetes.io/use-regex: 'true'
      nginx.ingress.kubernetes.io/rewrite-target: /$1
    hosts:
      - host: thegraph.k8s.orb.local
        paths:
          - path: /(.*)
            pathType: ImplementationSpecific
            port: 8000
            serviceName: graph-node-query
          - path: /ws/?(.*)
            pathType: ImplementationSpecific
            port: 8001
            serviceName: graph-node-query
          - path: /admin/?(.*)
            pathType: ImplementationSpecific
            port: 8020
            serviceName: graph-node-query
          - path: /indexer/?(.*)
            pathType: ImplementationSpecific
            port: 8030
            serviceName: graph-node-index
          - path: /graphman/?(.*)
            pathType: ImplementationSpecific
            port: 8050
            serviceName: graph-node-index
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

redis:
  enabled: true
  fullnameOverride: redis
  auth:
    password: "atk"
  replica:
    replicaCount: 2
