---
description: Rules for Subgraphs
globs: kit/subgraph/*
---
# Subgraph Design & Architecture

## 1. Model Your Data in a Clear Schema

### 1.1 Leverage GraphQL Relationships
- **Use GraphQL’s reference types:**  
  Instead of storing arrays of IDs in an entity, define relationships using reference types. For example:
  ```graphql
  type A {
    bEntities: [B!] @derivedFrom(field: "aEntity")
  }
  ```
  This avoids manual index management, simplifies mappings, and improves query performance.

### 1.2 Use Derived Fields
- **Derived Fields:**  
  A `@derivedFrom` field automatically creates a reverse lookup from the related entity, minimizing duplication (e.g., no need to manually maintain a list of references).

### 1.3 Avoid Overly Large Arrays
- **Large Arrays:**  
  Storing large arrays in entity fields can balloon index sizes and slow queries. Instead, maintain references between entities and rely on GraphQL for querying.

---

## 2. Keep Data Structures Simple & Focused

### 2.1 Only Store What You Need
- **Minimize Storage:**  
  If a piece of data isn’t queried or used downstream, don’t store it. This keeps indexing costs and query response times low.

### 2.2 Balance Granularity
- **Granularity Considerations:**  
  - Overly granular entities (storing each small piece of data separately) may lead to unnecessary complexity.  
  - Conversely, putting everything into one entity can create large, unwieldy objects.  
  Strive for a logical data breakdown that is intuitive to query.

---

## 3. Consider Future Maintenance

- **Version & Update Your Schema:**  
  Use semantic versioning or a clear naming scheme (e.g., v1, v2) for major schema updates. Be mindful that drastic changes might require re-deployment or re-indexing.

---

# Mapping & Handlers

## 1. Event Handlers
- **Primary Mechanism:**  
  Use event handlers to capture smart contract events, which are ideal for discrete state changes. Avoid block or call handlers unless absolutely necessary.
- **Minimize Complex Logic:**  
  Offload heavy computations off-chain; subgraphs excel at reacting to events rather than performing intensive data transformations.
- **Optimize for Fewer Handlers:**  
  Combine logic for multiple events if they contain similar or related data to reduce overhead.

## 2. Call Handlers
- **Use Sparingly:**  
  Call handlers trigger on every function call—even if no event is emitted. Ensure you actually need the call data; often, events suffice.

## 3. Block Handlers
- **Avoid “Every Block” Handlers:**  
  Running code on every block is expensive. If you need time-based triggers, consider using events from a block-based oracle or reduce the frequency of execution.

---

# Coding Tips in AssemblyScript Mappings

## 1. Efficient AssemblyScript
- **Typed Mappings for Entity Fields:**  
  Parse an event parameter once, store it in a local variable, and then reuse it.
- **Safe Casting & Conversion:**  
  Understand your integer ranges. For instance, casting a BigInt to an i32 can overflow if the value is large. Choose appropriate types (BigInt, BigDecimal, etc.) for storing numerical values.
- **Minimize External Calls:**  
  Each call via the ethereum namespace slows indexing and can complicate reorg handling. Cache data if a call is required multiple times or rely purely on events when possible.

## 2. Error Handling & Defensive Checks
- **Check for Null/Undefined:**  
  Smart contract events might return unexpected data if contract logic changes. Defensive coding prevents runtime errors in your mapping.
- **Defensive Checks Instead of Try/Catch:**  
  While AssemblyScript doesn’t support try/catch like JavaScript, always check for null or reverted calls.
- **Validate Data:**  
  Confirm data integrity before storing it in an entity.

---

# Performance & Scalability

## 1. Minimize Reorg Complexity
- **Idempotent Handlers:**  
  Write event handlers so that re-running them produces consistent results. The Graph node will rollback to a safe state and re-run mappings in case of chain reorganization.

## 2. Use DataSource Templates Wisely
- **Dynamic Contract Indexing:**  
  DataSource templates are useful for indexing dynamic contract addresses (e.g., factories that spawn new instances).  
- **Prune Unused Templates:**  
  Remove or comment out templates that are no longer needed to prevent indexing overhead from ballooning.

## 3. Limit Expensive Operations
- **Index Only the Necessities:**  
  Review your schema and mappings to identify and omit any expensive calls or transformations.  
  _Example:_ Instead of calling `balanceOf` on every block, compute or cache it at the time of relevant events.

---

# Testing & Validation

## 1. Local Testing
- **Test Against a Local Graph Node:**  
  Use `graph-cli` to spin up a local environment. Replay known events from a local blockchain (Ganache, Hardhat, Foundry, etc.) to verify correctness before deploying.

## 2. Automated Testing & CI
- **Set Up CI:**  
  Integrate a continuous integration pipeline (e.g., GitHub Actions) to run `graph test` or custom tests on every commit to catch regressions early.

## 3. Reproducible Results
- **Pin to Specific Block Numbers:**  
  During development, specify a start block or a deterministic set of blocks for consistent test results.

---

# Deployment & Maintenance

## 1. Monitoring & Logging
- **Use Logs for Debugging:**  
  In your mappings, utilize `log.info` or `log.debug` to track state changes and diagnose indexing issues.
- **Zero Compilation or Linting Errors:**  
  Ensure that your code is free from any compilation or linting errors or warnings—fix them all.

---

# Security & Reliability

## 1. Handle Unexpected Data
- **Defensive Field Assignments:**  
  Validate that data exists before storing it, as on-chain upgrades or contract changes might alter or remove expected event data.

## 2. Re-Entrant Data & Front-running
- **Smart Contract Patterns:**  
  If the indexed contract is prone to re-entrancy or front-running, your subgraph may see multiple event sequences. Ensure your logic can handle these scenarios, or rely on the final chain state as the source of truth.

---

# Documentation & Collaboration

## 1. Inline Comments & README
- **Document Entities & Fields:**  
  Include concise comments explaining what each entity and field represents to help future collaborators or open-source contributors understand your schema quickly.

## 2. Publish a Usage Guide
- **Example Queries:**  
  Provide sample GraphQL queries in your subgraph’s README to help users get started and verify that you’re indexing data in a useful format.

---

# Practical Workflow Overview

1. **Draft a Schema:**
   - Identify the necessary entities and how they interrelate.
   - Keep the entities minimal yet sufficient for all anticipated queries.
2. **Configure `subgraph.yaml`:**
   - Set up data sources, contract addresses, ABIs, the start block, and event/call/block handlers.
3. **Write Your Mappings:**
   - Implement event handlers in AssemblyScript (or use generated code from graph codegen).
   - Focus on transforming raw event data into entities with minimal logic.
4. **Local Testing:**
   - Spin up a local Graph Node.
   - Replay events from a local or testnet blockchain to ensure the indexing works as expected.
5. **Deploy to Hosted Service:**
   - Once stable locally, deploy to the Hosted Service for testing with live chain data.
   - Monitor indexing progress and resolve any failures.
6. **Optimize & Document:**
   - Profile subgraph performance, remove unneeded fields and calls.
   - Write a clear README and usage documentation.
7. **Production Deployment:**
   - Deploy to the decentralized Graph network (via Subgraph Studio).
   - Monitor indexing costs, query usage, and gather user feedback.
