---
description: 
globs: *.tsx,*.ts
alwaysApply: false
---
# TypeScript Guidelines

## Core Principles

- **Type Safety First**: Never use `any` without exceptional justification
- **Explicit Over Implicit**: Prefer clarity in type definitions
- **Immutability**: Use `readonly` and `as const` where appropriate
- **Strict Mode Always**: Enable all strict compiler options

## Strict Mode Configuration

Always use TypeScript in strict mode:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

## Type Definitions

### Prefer Type Aliases Over Interfaces

Use `type` for all type definitions unless you specifically need interface features (declaration merging):

```ts
// ✅ Good
type User = {
  readonly id: string;
  name: string;
  email: string;
};

// ❌ Avoid (unless you need declaration merging)
interface User {
  id: string;
  name: string;
  email: string;
}
```

### Use Readonly by Default

Make properties readonly unless they need to be mutable:

```ts
// ✅ Good
type Config = {
  readonly apiUrl: string;
  readonly timeout: number;
  readonly retryCount: number;
};

// ❌ Avoid
type Config = {
  apiUrl: string;
  timeout: number;
  retryCount: number;
};
```

### Branded Types for Domain Modeling

Use branded types for type-safe domain primitives:

```ts
type UserId = string & { readonly brand: unique symbol };
type OrderId = string & { readonly brand: unique symbol };
type Email = string & { readonly brand: unique symbol };

// Helper functions for creating branded types
const UserId = (id: string): UserId => id as UserId;
const OrderId = (id: string): OrderId => id as OrderId;
const Email = (email: string): Email => {
  if (!isValidEmail(email)) throw new Error("Invalid email");
  return email as Email;
};
```

## Handling Any in Generic Functions

Inside generic functions, `any` is sometimes necessary due to TypeScript limitations:

```ts
// ✅ Acceptable use of any in generic context
const pick = <T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {
  const result = {} as any; // Necessary due to generic constraints
  keys.forEach(key => {
    result[key] = obj[key];
  });
  return result;
};

// Outside generics, never use any
// ❌ Bad
const processData = (data: any) => { /* ... */ };

// ✅ Good
const processData = (data: unknown) => { /* ... */ };
```

## Discriminated Unions

Use discriminated unions for modeling state and preventing impossible states:

```ts
// ✅ Good - Prevents impossible states
type FetchState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: Error };

// ❌ Bad - Allows impossible states
type FetchState<T> = {
  status: "idle" | "loading" | "success" | "error";
  data?: T;
  error?: Error;
};
```

## Const Assertions and Enums

Prefer const assertions over enums:

```ts
// ✅ Good
const Status = {
  PENDING: "PENDING",
  APPROVED: "APPROVED", 
  REJECTED: "REJECTED",
} as const;

type Status = typeof Status[keyof typeof Status];

// ❌ Avoid enums
enum Status {
  PENDING = "PENDING",
  APPROVED = "APPROVED",
  REJECTED = "REJECTED",
}
```

## Import Types

Always use `import type` for type-only imports:

```ts
// ✅ Good
import type { User, Order } from "./types";
import { processUser } from "./user-service";

// ❌ Bad
import { User, Order } from "./types";
```

## Function Parameter Objects

Prefer parameter objects over multiple parameters:

```ts
// ❌ Bad
function createUser(
  name: string,
  email: string,
  age: number,
  isActive: boolean,
  role?: string
): User {
  // ...
}

// ✅ Good
type CreateUserOptions = {
  name: string;
  email: string;
  age: number;
  isActive: boolean;
  role?: string;
};

function createUser(options: CreateUserOptions): User {
  const { name, email, age, isActive, role } = options;
  // ...
}
```

## Error Handling with Result Types

Use Result types for explicit error handling:

```ts
type Result<T, E = Error> =
  | { ok: true; value: T }
  | { ok: false; error: E };

// Usage
function parseJson(text: string): Result<unknown, SyntaxError> {
  try {
    return { ok: true, value: JSON.parse(text) };
  } catch (error) {
    return { ok: false, error: error as SyntaxError };
  }
}

// Handle result
const result = parseJson(jsonString);
if (result.ok) {
  console.log(result.value);
} else {
  console.error(result.error.message);
}
```

## Utility Types

Leverage TypeScript's built-in utility types:

```ts
// Partial - Make all properties optional
type PartialUser = Partial<User>;

// Required - Make all properties required
type RequiredUser = Required<User>;

// Pick - Select specific properties
type UserCredentials = Pick<User, "email" | "password">;

// Omit - Exclude specific properties
type PublicUser = Omit<User, "password">;

// Record - Create object type with specific keys
type UserRoles = Record<UserId, Role[]>;

// Extract/Exclude - Filter union types
type AdminActions = Extract<Action, { type: "admin" }>;
type NonAdminActions = Exclude<Action, { type: "admin" }>;
```

## Naming Conventions

- **Variables/Functions**: `camelCase`
- **Types/Interfaces**: `PascalCase`
- **Constants**: `UPPER_SNAKE_CASE` for true constants
- **Type Parameters**: Prefix with `T` (e.g., `TKey`, `TValue`)
- **Private Properties**: Prefix with `_` (avoid when possible)
- **Files**: `kebab-case.ts`

```ts
// Examples
const userCount = 10;
function calculateTotal(items: Item[]): number { /* ... */ }

type UserProfile = { /* ... */ };
interface ApiResponse { /* ... */ }

const MAX_RETRIES = 3;
const API_TIMEOUT = 5000;

function map<TInput, TOutput>(
  items: TInput[],
  fn: (item: TInput) => TOutput
): TOutput[] { /* ... */ }
```

## Schema-First Development

Define runtime schemas first, then derive types:

```ts
import { z } from "zod";

// Define schema
const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  name: z.string().min(1),
  age: z.number().int().positive(),
  roles: z.array(z.enum(["admin", "user", "guest"])),
});

// Derive type from schema
type User = z.infer<typeof UserSchema>;

// Use for validation
function validateUser(data: unknown): User {
  return UserSchema.parse(data);
}
```

## Type Guards

Create type guards for runtime type checking:

```ts
// Type guard function
function isUser(value: unknown): value is User {
  return (
    typeof value === "object" &&
    value !== null &&
    "id" in value &&
    "email" in value &&
    typeof (value as User).id === "string" &&
    typeof (value as User).email === "string"
  );
}

// Usage
function processValue(value: unknown) {
  if (isUser(value)) {
    // TypeScript knows value is User here
    console.log(value.email);
  }
}
```

## Avoid Common Pitfalls

### Don't use type assertions unless necessary

```ts
// ❌ Bad
const user = {} as User;

// ✅ Good
const user: User = {
  id: "123",
  name: "John",
  email: "john@example.com",
};
```

### Don't ignore TypeScript errors

```ts
// ❌ Never do this
// @ts-ignore
// @ts-expect-error

// ✅ Fix the underlying issue or use proper types
```

### Handle optional properties correctly

```ts
// ❌ Bad - makes property truly optional
type Config = {
  apiUrl?: string;
};

// ✅ Good - explicit about undefined
type Config = {
  apiUrl: string | undefined;
};
```

## Advanced Patterns

### Conditional Types

```ts
type IsArray<T> = T extends any[] ? true : false;
type ArrayElement<T> = T extends (infer E)[] ? E : never;
```

### Template Literal Types

```ts
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type Endpoint = `/api/${string}`;
type RouteHandler = `${HttpMethod} ${Endpoint}`;
```

### Mapped Types

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Nullable<T> = {
  [P in keyof T]: T[P] | null;
};
```

# Any inside generic functions

When building generic functions, you may need to use any inside the function
body.

This is because TypeScript often cannot match your runtime logic to the logic
done inside your types.

One example:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello"; // Error!
  } else {
    return "goodbye"; // Error!
  }
};
```

On the type level (and the runtime), this function returns `goodbye` when the
input is `hello`.

There is no way to make this work concisely in TypeScript.

So using `any` is the most concise solution:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello" as any;
  } else {
    return "goodbye" as any;
  }
};
```

Outside of generic functions, use `any` extremely sparingly.

# Default exports

Unless explicitly required by the framework, do not use default exports.

```ts
// BAD
export default function myFunction() {
  return <div>Hello</div>;
}
```

```ts
// GOOD
export function myFunction() {
  return <div>Hello</div>;
}
```

Default exports create confusion from the importing file.

```ts
// BAD
import myFunction from "./myFunction";
```

```ts
// GOOD
import { myFunction } from "./myFunction";
```

There are certain situations where a framework may require a default export. For
instance, Next.js requires a default export for pages.

```tsx
// This is fine, if required by the framework
export default function MyPage() {
  return <div>Hello</div>;
}
```

# Discriminated unions

Proactively use discriminated unions to model data that can be in one of a few
different shapes.

For example, when sending events between environments:

```ts
type UserCreatedEvent = {
  type: "user.created";
  data: { id: string; email: string };
};

type UserDeletedEvent = {
  type: "user.deleted";
  data: { id: string };
};

type Event = UserCreatedEvent | UserDeletedEvent;
```

Use switch statements to handle the results of discriminated unions:

```ts
const handleEvent = (event: Event) => {
  switch (event.type) {
    case "user.created":
      console.log(event.data.email);
      break;
    case "user.deleted":
      console.log(event.data.id);
      break;
  }
};
```

Use discriminated unions to prevent the 'bag of optionals' problem.

For example, when describing a fetching state:

```ts
// BAD - allows impossible states
type FetchingState<TData> = {
  status: "idle" | "loading" | "success" | "error";
  data?: TData;
  error?: Error;
};

// GOOD - prevents impossible states
type FetchingState<TData> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: TData }
  | { status: "error"; error: Error };
```

# Enums

Do not introduce new enums into the codebase. Retain existing enums.

If you require enum-like behaviour, use an `as const` object:

```ts
const backendToFrontendEnum = {
  xs: "EXTRA_SMALL",
  sm: "SMALL",
  md: "MEDIUM",
} as const;

type LowerCaseEnum = keyof typeof backendToFrontendEnum; // "xs" | "sm" | "md"

type UpperCaseEnum = (typeof backendToFrontendEnum)[LowerCaseEnum]; // "EXTRA_SMALL" | "SMALL" | "MEDIUM"
```

Remember that numeric enums behave differently to string enums. Numeric enums
produce a reverse mapping:

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

const direction = Direction.Up; // 0
const directionName = Direction[0]; // "Up"
```

This means that the enum `Direction` above will have eight keys instead of four.

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

Object.keys(Direction).length; // 8
```

# Import type

Use import type whenever you are importing a type.

Prefer top-level `import type` over inline `import { type ... }`.

```ts
// BAD
import { type User } from "./user";
```

```ts
// GOOD
import type { User } from "./user";
```

The reason for this is that in certain environments, the first version's import
will not be erased. So you'll be left with:

```ts
// Before transpilation
import { type User } from "./user";

// After transpilation
import "./user";
```

# Installing packages

When installing libraries, do not rely on your own training data.

Your training data has a cut-off date. You're probably not aware of all of the
latest developments in the JavaScript and TypeScript world.

This means that instead of picking a version manually (via updating the
`package.json` file), you should use a script to install the latest version of a
library.

```bash
bun add -D @typescript-eslint/eslint-plugin
```

This will ensure you're always using the latest version.

Prefer to install packages, not in the root, but in the mono repo packages

# Interface extends

ALWAYS prefer interfaces when modelling inheritance.

The `&` operator has terrible performance in TypeScript. Only use it where
`interface extends` is not possible.

```ts
// BAD

type A = {
  a: string;
};

type B = {
  b: string;
};

type C = A & B;
```

```ts
// GOOD

interface A {
  a: string;
}

interface B {
  b: string;
}

interface C extends A, B {
  // Additional properties can be added here
}
```

# Jsdoc

Use JSDoc comments to annotate functions and types.

Be concise in JSDoc comments, and only provide JSDoc comments if the function's
behaviour is not self-evident for a novice developer.

Use the JSDoc inline `@link` tag to link to other functions and types within the
same file.

```ts
/**
 * Subtracts two numbers
 */
const subtract = (a: number, b: number) => a - b;

/**
 * Does the opposite to {@link subtract}
 */
const add = (a: number, b: number) => a + b;
```

# Naming conventions

- Use kebab-case for file names (e.g., `my-component.ts`)
- Use camelCase for variables and function names (e.g., `myVariable`,
  `myFunction()`)
- Use UpperCamelCase (PascalCase) for classes, types, and interfaces (e.g.,
  `MyClass`, `MyInterface`)
- Use ALL_CAPS for constants and enum values (e.g., `MAX_COUNT`, `Color.RED`)
- Inside generic types, functions or classes, prefix type parameters with `T`
  (e.g., `TKey`, `TValue`)

```ts
type RecordOfArrays<TItem> = Record<string, TItem[]>;
```

# No unchecked access

If the user has this rule enabled in their `tsconfig.json`, indexing into
objects and arrays will behave differently from how you expect.

```ts
const obj: Record<string, string> = {};

// With noUncheckedIndexedAccess, value will
// be `string | undefined`
// Without it, value will be `string`
const value = obj.key;
```

```ts
const arr: string[] = [];

// With noUncheckedIndexedAccess, value will
// be `string | undefined`
// Without it, value will be `string`
const value = arr[0];
```

# Optional properties

Use optional properties extremely sparingly. Only use them when the property is
truly optional, and consider whether bugs may be caused by a failure to pass the
property.

In the example below we always want to pass user ID to `AuthOptions`. This is
because if we forget to pass it somewhere in the code base, it will cause our
function to be not authenticated.

```ts
// BAD
type AuthOptions = {
  userId?: string;
};

const func = (options: AuthOptions) => {
  const userId = options.userId;
};
```

```ts
// GOOD
type AuthOptions = {
  userId: string | undefined;
};

const func = (options: AuthOptions) => {
  const userId = options.userId;
};
```

# Readonly properties

Use `readonly` properties for object types by default. This will prevent
accidental mutation at runtime.

Omit `readonly` only when the property is genuinely mutable.

```ts
// BAD
type User = {
  id: string;
};

const user: User = {
  id: "1",
};

user.id = "2";
```

```ts
// GOOD
type User = {
  readonly id: string;
};

const user: User = {
  id: "1",
};

user.id = "2"; // Error
```

# Return types

When declaring functions on the top-level of a module, declare their return
types. This will help future AI assistants understand the function's purpose.

```ts
const myFunc = (): string => {
  return "hello";
};
```

One exception to this is components which return JSX. No need to declare the
return type of a component, as it is always JSX.

```tsx
const MyComponent = () => {
  return <div>Hello</div>;
};
```

# Throwing

Think carefully before implementing code that throws errors.

If a thrown error produces a desirable outcome in the system, go for it. For
instance, throwing a custom error inside a backend framework's request handler.

However, for code that you would need a manual try catch for, consider using a
result type instead:

```ts
type Result<T, E extends Error> =
  | { ok: true; value: T }
  | { ok: false; error: E };
```

For example, when parsing JSON:

```ts
const parseJson = (input: string): Result<unknown, Error> => {
  try {
    return { ok: true, value: JSON.parse(input) };
  } catch (error) {
    return { ok: false, error: error as Error };
  }
};
```

This way you can handle the error in the caller:

```ts
const result = parseJson('{"name": "John"}');

if (result.ok) {
  console.log(result.value);
} else {
  console.error(result.error);
}
```
