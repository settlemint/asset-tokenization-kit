---
description: Next 15
globs: kit/dapp/*
---
# Next.js 15 and React 19 Rules

## 1. Page and Layout Components

### Route Parameters and Search Params
- Always use Promise types and await for params and searchParams
- This applies to pages, layouts, and generateMetadata

```typescript
// ✅ Correct
export default async function Page({
  params,
  searchParams
}: {
  params: Promise<{ slug: string }>,
  searchParams: Promise<{ q?: string }>
}) {
  const { slug } = await params;
  const { q } = await searchParams;
}

// ❌ Wrong
export default function Page({
  params,
  searchParams
}: {
  params: { slug: string },
  searchParams: { q?: string }
}) {
  // Will cause type errors
}
```

### Metadata Generation
```typescript
// ✅ Correct
export async function generateMetadata({
  params,
  searchParams
}: {
  params: Promise<{ slug: string }>,
  searchParams: Promise<{ q?: string }>
}) {
  const { slug } = await params;
  return {
    title: `Page ${slug}`,
  };
}
```

## 2. Server vs Client Components

### Default to Server Components
- Server Components are the default in Next.js 15
- Only add 'use client' when needed for interactivity
- Keep client components small and focused

```typescript
// ✅ Correct: Server Component
export default async function Page() {
  const data = await fetchData();
  return <ClientComponent initialData={data} />;
}

// ✅ Correct: Client Component
'use client';
export function ClientComponent({ initialData }) {
  const [data, setData] = useState(initialData);
  // Client-side interactivity
}

// ❌ Wrong: Don't mix server and client features
'use client';
export default async function Component() { // Error: Can't use async in client components
  const data = await fetchData(); // Error: Can't use server-side data fetching
}
```

## 3. Data Fetching

### Server Component Data Fetching
- Use fetch with caching options
- Implement parallel data fetching where possible
- Avoid useEffect for data that can be fetched on the server

```typescript
// ✅ Correct: Fetch with caching
async function getData() {
  const res = await fetch('https://api.example.com', {
    next: { revalidate: 3600 }, // Cache for 1 hour
  });
  return res.json();
}

// ✅ Correct: Parallel fetching
async function getMultipleData() {
  const [users, posts] = await Promise.all([
    getUsers(),
    getPosts(),
  ]);
  return { users, posts };
}
```

## 4. Forms and Actions

### Server Actions
- Use Server Actions for form submissions
- Implement proper error handling and validation
- Use formAction for multiple actions in one form

```typescript
// ✅ Correct: Server Action in Server Component
export default function Form() {
  async function handleSubmit(formData: FormData) {
    'use server';
    // Server-side logic
  }
  return <form action={handleSubmit}>{/*...*/}</form>;
}

// ✅ Correct: Multiple actions
<form>
  <button formAction={action1}>Action 1</button>
  <button formAction={action2}>Action 2</button>
</form>
```

## 5. Route Handlers

### Type-Safe Route Handlers
- Use proper types for request and response
- Implement proper error handling
- Use Next.js Response helpers

```typescript
// ✅ Correct
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  return Response.json({ data });
}

// ✅ Correct: Error handling
export async function POST(request: Request) {
  try {
    const data = await request.json();
    return Response.json({ data }, { status: 201 });
  } catch (error) {
    return Response.json(
      { error: 'Invalid request' },
      { status: 400 }
    );
  }
}
```

## 6. Client Components

### State Management
- Use hooks appropriately
- Implement proper cleanup in useEffect
- Use React.memo and useMemo wisely

```typescript
// ✅ Correct: Proper cleanup
'use client';
export function Component() {
  useEffect(() => {
    const subscription = subscribe();
    return () => subscription.unsubscribe();
  }, []);
}

// ✅ Correct: Event handling
'use client';
export function Component() {
  const handleClick = useCallback(() => {
    // Handle click
  }, []);
}
```

## 7. Error Handling

### Error and Loading States
- Implement error.tsx for error boundaries
- Use loading.tsx for loading states
- Handle errors gracefully in Server Actions

```typescript
// ✅ Correct: error.tsx
'use client';
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}

// ✅ Correct: loading.tsx
export default function Loading() {
  return <div>Loading...</div>;
}
```

## 8. Performance

### Optimization Techniques
- Use React.Suspense for loading states
- Implement proper caching strategies
- Use streaming where appropriate

```typescript
// ✅ Correct: Suspense usage
export default function Page() {
  return (
    <Suspense fallback={<Loading />}>
      <SlowComponent />
    </Suspense>
  );
}

// ✅ Correct: Streaming
export default async function Page() {
  return (
    <>
      <header>Instant Load</header>
      <Suspense fallback={<Loading />}>
        {/* @ts-expect-error Async Server Component */}
        <SlowComponent />
      </Suspense>
    </>
  );
}
```

## 9. Type Safety

### TypeScript Best Practices
- Use proper types for all components and functions
- Implement proper error handling types
- Use discriminated unions for complex states

```typescript
// ✅ Correct: Proper typing
interface Props {
  data: {
    id: string;
    title: string;
  };
  onAction: (id: string) => Promise<void>;
}

// ✅ Correct: Discriminated unions
type State =
  | { status: 'loading' }
  | { status: 'error'; error: Error }
  | { status: 'success'; data: Data };
```

## 10. Common Gotchas

### Things to Avoid
- Don't mix client and server code
- Don't use client hooks in Server Components
- Don't fetch data in client components when it can be done on the server
- Don't use window/document in Server Components

```typescript
// ❌ Wrong: Mixing client and server
export default async function Page() {
  'use client'; // Error: 'use client' must be at the top
  const data = await fetchData(); // Error: Can't use server-side fetch
}

// ❌ Wrong: Using window in Server Component
export default function Page() {
  const width = window.innerWidth; // Error: window is not defined
}
```